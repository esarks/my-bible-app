{
  "version": 3,
  "sources": ["../../@plasmicapp/react-web/lib/auth/index.js", "../../@plasmicapp/auth-api/src/api.ts", "../../@plasmicapp/auth-react/src/index.ts", "../../@plasmicapp/auth-react/src/hooks.ts"],
  "sourcesContent": ["export * from '@plasmicapp/auth-react';\n//# sourceMappingURL=index.js.map\n", "import fetch from \"@plasmicapp/isomorphic-unfetch\";\n\nconst PLASMIC_HOST = \"https://data.plasmic.app\";\n\nexport interface PlasmicUser {\n  email: string;\n  properties: Record<string, unknown> | null;\n  roleId: string;\n  roleName: string;\n  roleIds: string[];\n  roleNames: string[];\n}\n\nexport type PlasmicUserResult =\n  | {\n      user: null;\n      token: null;\n      error: Error;\n    }\n  | {\n      user: PlasmicUser;\n      token: string;\n      error?: never;\n    };\n\nexport async function getPlasmicAppUserFromToken(opts: {\n  host?: string;\n  token: string;\n}): Promise<PlasmicUserResult> {\n  const { host, token } = opts;\n  const url = `${host || PLASMIC_HOST}/api/v1/app-auth/userinfo`;\n  const result = await fetch(url, {\n    headers: {\n      \"x-plasmic-data-user-auth-token\": token,\n    },\n  });\n\n  const user = await result.json();\n\n  if (result.status >= 400) {\n    return {\n      user: null,\n      token: null,\n      error: new Error(\"Invalid token\"),\n    };\n  }\n\n  return {\n    user,\n    token,\n  };\n}\n\nexport async function getPlasmicAppUser(opts: {\n  host?: string;\n  appId: string;\n  codeVerifier: string;\n  code: string;\n}): Promise<PlasmicUserResult> {\n  const { host, appId, codeVerifier, code } = opts;\n\n  const requestParams = new URLSearchParams();\n  requestParams.set(\"grant_type\", \"authorization_code\");\n  requestParams.set(\"code\", code);\n  requestParams.set(\"code_verifier\", codeVerifier);\n  requestParams.set(\"client_id\", appId);\n\n  const url = `${\n    host || PLASMIC_HOST\n  }/api/v1/app-auth/token?${requestParams.toString()}`;\n  const result = await fetch(url);\n\n  const { token, user, error } = await result.json();\n\n  if (result.status >= 400 || error) {\n    return {\n      user: null,\n      token: null,\n      error: error ?? new Error(\"Internal error\"),\n    };\n  }\n\n  return {\n    user,\n    token,\n  };\n}\n\ntype UserIdentifier = { email: string } | { externalId: string };\n\nexport async function ensurePlasmicAppUser(\n  opts: {\n    host?: string;\n    appSecret: string;\n    roleId?: string;\n  } & UserIdentifier\n): Promise<PlasmicUserResult> {\n  const { host, appSecret, roleId } = opts;\n\n  const email = \"email\" in opts ? opts.email : undefined;\n  const externalId = \"externalId\" in opts ? opts.externalId : undefined;\n\n  const url = `${host || PLASMIC_HOST}/api/v1/app-auth/user`;\n  const result = await fetch(url, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"x-plasmic-app-auth-api-token\": appSecret,\n    },\n    body: JSON.stringify({\n      email,\n      externalId,\n      roleId,\n    }),\n  });\n\n  const { user, token, error } = await result.json();\n\n  if (result.status >= 400 || error) {\n    return {\n      user: null,\n      token: null,\n      error: error ?? new Error(\"Internal error\"),\n    };\n  }\n\n  return {\n    user,\n    token,\n  };\n}\n\nexport const createPlasmicAppUser = ensurePlasmicAppUser;\n", "export * from '@plasmicapp/auth-api';\nexport * from './hooks';\n", "import {\n  getPlasmicAppUser,\n  getPlasmicAppUserFromToken,\n  PlasmicUser,\n} from \"@plasmicapp/auth-api\";\nimport { useMutablePlasmicQueryData } from \"@plasmicapp/query\";\n\ninterface PlasmicAuthData {\n  user: PlasmicUser | null;\n  token: string | null;\n}\n\nconst storageUserKey = (appId: string) => `$user.${appId}`;\n\nconst isBrowser = typeof window !== \"undefined\";\n\nfunction getCallbackParams() {\n  const params = new URLSearchParams(window.location.search);\n  const error = params.get(\"error\");\n  const code = params.get(\"code\");\n  const state = params.get(\"state\");\n\n  return {\n    isCallbackError: !!error,\n    isCodeExchange: !!code && !!state,\n    error,\n    code,\n    state,\n  };\n}\n\nfunction getCodeVerifier() {\n  try {\n    return localStorage.getItem(\"code_verifier\");\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction removeCallbackParams() {\n  try {\n    window.history.replaceState({}, \"\", location.pathname);\n  } catch (err) {\n    console.error(`Error while removing callback params: ${err}`);\n  }\n}\n\n// continueTo can be only a pathname or a full url with origin\n// we can consider that currently we are at the callback page\n// with callback params, so ignore the search params\nfunction isContinueToSameLocation(continueTo: string) {\n  const pathname = window.location.pathname;\n  const origin = window.location.origin;\n  return continueTo === pathname || continueTo === origin + pathname;\n}\n\nasync function handleCallback(opts: {\n  host?: string;\n  appId: string;\n  code: string;\n  state: string;\n  codeVerifier: string;\n}): Promise<PlasmicAuthData | undefined> {\n  const { host, appId, code, state, codeVerifier } = opts;\n\n  let continueTo = \"/\";\n  try {\n    if (state) {\n      const parsedState = JSON.parse(state);\n      continueTo = parsedState.continueTo;\n    }\n  } catch (err) {\n    console.error(`Error while parsing state: ${err}`);\n  }\n\n  const result = await getPlasmicAppUser({\n    host,\n    appId,\n    code,\n    codeVerifier,\n  });\n\n  if (result.error) {\n    console.log(`Error while performing code exchange: ${result.error}`);\n    return undefined;\n  }\n\n  localStorage.setItem(storageUserKey(appId), result.token);\n\n  if (!isContinueToSameLocation(continueTo)) {\n    window.location.assign(continueTo);\n  } else {\n    removeCallbackParams();\n  }\n\n  return { token: result.token, user: result.user };\n}\n\nasync function checkAlreadyLoggedUser(opts: {\n  appId: string;\n  host?: string;\n}): Promise<PlasmicAuthData> {\n  const { appId, host } = opts;\n\n  const token = localStorage.getItem(storageUserKey(appId));\n  if (!token) {\n    return { user: null, token: null };\n  }\n\n  const { user, error } = await getPlasmicAppUserFromToken({\n    host,\n    token,\n  });\n\n  if (error) {\n    // If there is an error, we just remove the token\n    // But ideally we should check if the reason is token expired\n    localStorage.removeItem(storageUserKey(appId));\n    console.log(`Error while checking logged user`);\n    return { user: null, token: null };\n  }\n\n  return { user, token };\n}\n\n/**\n * Handles the authentication flow for Plasmic Auth and returns the user and token\n */\nexport function usePlasmicAuth(opts: { host?: string; appId?: string }) {\n  const { host, appId } = opts;\n  const authKey = `$csq$plasmic-auth-${appId}`;\n  const { data: userData, isLoading } = useMutablePlasmicQueryData(\n    authKey,\n    async (): Promise<PlasmicAuthData> => {\n      if (!appId || !isBrowser) {\n        return { user: null, token: null };\n      }\n\n      // Fail silently for now\n      try {\n        // We first check if we are currently in the callback flow\n        const callbackParams = getCallbackParams();\n        if (callbackParams.isCallbackError || callbackParams.isCodeExchange) {\n          if (callbackParams.isCallbackError) {\n            // If there is an error, we just remove the callback params\n            removeCallbackParams();\n            console.error(`Error: ${callbackParams.error}`);\n            return { user: null, token: null };\n          } else {\n            const codeVerifier = getCodeVerifier();\n            if (!codeVerifier) {\n              // If there is no codeVerifier, we just remove the callback params\n              removeCallbackParams();\n              console.error(\"No code verifier found\");\n              return { user: null, token: null };\n            } else {\n              // Perform code exchange, by the end of the callback handling we will either still be\n              // in the callback page or we will be redirected to the continueTo page.\n\n              const result = await handleCallback({\n                host,\n                appId,\n                code: callbackParams.code!,\n                state: callbackParams.state!,\n                codeVerifier,\n              });\n\n              // Undefined result means that the code exchange failed\n              if (!result) {\n                removeCallbackParams();\n                return { user: null, token: null };\n              }\n\n              // In the above case where the code exchange failed and the callback page requires login\n              // a login redirect will be triggered\n              return result;\n            }\n          }\n        } else {\n          return await checkAlreadyLoggedUser({\n            appId,\n            host,\n          });\n        }\n      } catch (err) {\n        console.error(`Error while handling auth: ${err}`);\n      }\n\n      return { user: null, token: null };\n    }\n  );\n\n  return {\n    user: userData?.user ?? null,\n    token: userData?.token ?? null,\n    isUserLoading: isLoading,\n  };\n}\n"],
  "mappings": "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",
  "names": ["fetch", "__async"]
}
