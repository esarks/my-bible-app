{
  "version": 3,
  "sources": ["../../@plasmicapp/host/src/lang-utils.ts", "../../@plasmicapp/host/src/useForceUpdate.ts", "../../@plasmicapp/host/src/canvas-host.tsx", "../../@plasmicapp/host/src/common.ts", "../../@plasmicapp/host/src/data.tsx", "../../@plasmicapp/host/src/fetcher.ts", "../../@plasmicapp/host/src/global-actions.tsx", "../../@plasmicapp/host/src/link.tsx", "../../@plasmicapp/host/src/registerComponent.ts", "../../@plasmicapp/host/src/registerFunction.ts", "../../@plasmicapp/host/src/registerGlobalContext.ts", "../../@plasmicapp/host/src/registerToken.ts", "../../@plasmicapp/host/src/registerTrait.ts", "../../@plasmicapp/host/src/repeatedElement.ts", "../../@plasmicapp/host/src/translation.tsx", "../../@plasmicapp/host/src/version.ts", "../../@plasmicapp/host/src/index.ts"],
  "sourcesContent": ["function isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n\ntype StringGen = string | (() => string);\n\nexport function ensure<T>(x: T | null | undefined, msg: StringGen = \"\"): T {\n  if (x === null || x === undefined) {\n    debugger;\n    msg = (isString(msg) ? msg : msg()) || \"\";\n    throw new Error(\n      `Value must not be undefined or null${msg ? `- ${msg}` : \"\"}`\n    );\n  } else {\n    return x;\n  }\n}\n", "import { useCallback, useState } from \"react\";\n\nexport default function useForceUpdate() {\n  const [, setTick] = useState(0);\n  const update = useCallback(() => {\n    setTick((tick) => tick + 1);\n  }, []);\n  return update;\n}\n", "import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { ensure } from \"./lang-utils\";\nimport useForceUpdate from \"./useForceUpdate\";\n\ndeclare global {\n  interface Window {\n    __PlasmicHostVersion: string;\n  }\n}\n\nif ((globalThis as any).__PlasmicHostVersion == null) {\n  (globalThis as any).__PlasmicHostVersion = \"3\";\n}\n\nconst rootChangeListeners: (() => void)[] = [];\nclass PlasmicRootNodeWrapper {\n  constructor(private value: null | React.ReactElement) {}\n  set = (val: null | React.ReactElement) => {\n    this.value = val;\n    rootChangeListeners.forEach((f) => f());\n  };\n  get = () => this.value;\n}\n\nconst plasmicRootNode = new PlasmicRootNodeWrapper(null);\n\nfunction getHashParams() {\n  return new URLSearchParams(location.hash.replace(/^#/, \"?\"));\n}\n\nfunction getPlasmicOrigin() {\n  const params = getHashParams();\n  return ensure(\n    params.get(\"origin\"),\n    \"Missing information from Plasmic window.\"\n  );\n}\n\nfunction getStudioHash() {\n  const hashParams = getHashParams();\n  if (hashParams.has(\"studioHash\")) {\n    return hashParams.get(\"studioHash\");\n  }\n  const urlParams = new URL(location.href).searchParams;\n  return urlParams.get(\"studio-hash\");\n}\n\nfunction renderStudioIntoIframe() {\n  const script = document.createElement(\"script\");\n  const plasmicOrigin = getPlasmicOrigin();\n  const hash = getStudioHash();\n  script.src = `${plasmicOrigin}/static/js/studio${\n    hash ? `.${hash}.js` : `.js`\n  }`;\n  document.body.appendChild(script);\n}\n\nlet renderCount = 0;\nexport function setPlasmicRootNode(node: React.ReactElement | null) {\n  // Keep track of renderCount, which we use as key to ErrorBoundary, so\n  // we can reset the error on each render\n  renderCount++;\n  plasmicRootNode.set(node);\n}\n\nexport interface PlasmicCanvasContextValue {\n  componentName: string | null;\n  globalVariants: Record<string, string>;\n  interactive?: boolean;\n}\n\n/**\n * React context to detect whether the component is rendered on Plasmic editor.\n * If not, return false.\n * If so, return an object with more information about the component\n */\nexport const PlasmicCanvasContext = React.createContext<\n  PlasmicCanvasContextValue | false\n>(false);\nexport const usePlasmicCanvasContext = () =>\n  React.useContext(PlasmicCanvasContext);\n\nfunction _PlasmicCanvasHost() {\n  // If window.parent is null, then this is a window whose containing iframe\n  // has been detached from the DOM (for the top window, window.parent === window).\n  // In that case, we shouldn't do anything.  If window.parent is null, by the way,\n  // location.hash will also be null.\n  const isFrameAttached = !!window.parent;\n  const isCanvas = !!location.hash?.match(/\\bcanvas=true\\b/);\n  const isLive = !!location.hash?.match(/\\blive=true\\b/) || !isFrameAttached;\n  const shouldRenderStudio =\n    isFrameAttached &&\n    !document.querySelector(\"#plasmic-studio-tag\") &&\n    !isCanvas &&\n    !isLive;\n  const forceUpdate = useForceUpdate();\n  React.useLayoutEffect(() => {\n    rootChangeListeners.push(forceUpdate);\n    return () => {\n      const index = rootChangeListeners.indexOf(forceUpdate);\n      if (index >= 0) {\n        rootChangeListeners.splice(index, 1);\n      }\n    };\n  }, [forceUpdate]);\n  React.useEffect(() => {\n    if (shouldRenderStudio && isFrameAttached && window.parent !== window) {\n      renderStudioIntoIframe();\n    }\n  }, [shouldRenderStudio, isFrameAttached]);\n  React.useEffect(() => {\n    if (!shouldRenderStudio && !document.querySelector(\"#getlibs\") && isLive) {\n      const scriptElt = document.createElement(\"script\");\n      scriptElt.id = \"getlibs\";\n      scriptElt.src = getPlasmicOrigin() + \"/static/js/getlibs.js\";\n      scriptElt.async = false;\n      scriptElt.onload = () => {\n        (window as any).__GetlibsReadyResolver?.();\n      };\n      document.head.append(scriptElt);\n    }\n  }, [shouldRenderStudio]);\n\n  const [canvasContextValue, setCanvasContextValue] = React.useState(() =>\n    deriveCanvasContextValue()\n  );\n\n  React.useEffect(() => {\n    if (isCanvas) {\n      const listener = () => {\n        setCanvasContextValue(deriveCanvasContextValue());\n      };\n      window.addEventListener(\"hashchange\", listener);\n      return () => window.removeEventListener(\"hashchange\", listener);\n    }\n    return undefined;\n  }, [isCanvas]);\n  if (!isFrameAttached) {\n    return null;\n  }\n  if (isCanvas || isLive) {\n    let appDiv = document.querySelector(\"#plasmic-app.__wab_user-body\");\n    if (!appDiv) {\n      appDiv = document.createElement(\"div\");\n      appDiv.id = \"plasmic-app\";\n      appDiv.classList.add(\"__wab_user-body\");\n      document.body.prepend(appDiv);\n    }\n    return ReactDOM.createPortal(\n      <ErrorBoundary key={`${renderCount}`}>\n        <PlasmicCanvasContext.Provider value={canvasContextValue}>\n          {plasmicRootNode.get()}\n        </PlasmicCanvasContext.Provider>\n      </ErrorBoundary>,\n      appDiv,\n      \"plasmic-app\"\n    );\n  }\n  if (shouldRenderStudio && window.parent === window) {\n    return (\n      <iframe\n        src={`https://docs.plasmic.app/app-content/app-host-ready#appHostUrl=${encodeURIComponent(\n          location.href\n        )}`}\n        style={{\n          width: \"100vw\",\n          height: \"100vh\",\n          border: \"none\",\n          position: \"fixed\",\n          top: 0,\n          left: 0,\n          zIndex: 99999999,\n        }}\n      ></iframe>\n    );\n  }\n  return null;\n}\n\ninterface PlasmicCanvasHostProps {\n  /**\n   * Webpack hmr uses EventSource to\tlisten to hot reloads, but that\n   * resultsin a persistent\tconnection from\teach window.  In Plasmic\n   * Studio, if a project is configured to use app-hosting with a\n   * nextjs or gatsby server running in dev mode, each artboard will\n   * be holding a persistent connection to the dev server.\n   * Because browsers\thave a limit to\thow many connections can\n   * be held\tat a time by domain, this means\tafter X\tartboards, new\n   * artboards will freeze and not load.\n   *\n   * By default, <PlasmicCanvasHost /> will globally mutate\n   * window.EventSource to avoid using EventSource for HMR, which you\n   * typically don't need for your custom host page.  If you do still\n   * want to retain HRM, then youc an pass enableWebpackHmr={true}.\n   */\n  enableWebpackHmr?: boolean;\n}\n\nexport const PlasmicCanvasHost: React.FunctionComponent<\n  PlasmicCanvasHostProps\n> = (props) => {\n  const { enableWebpackHmr } = props;\n  const [node, setNode] = React.useState<React.ReactElement<any, any> | null>(\n    null\n  );\n  React.useEffect(() => {\n    setNode(<_PlasmicCanvasHost />);\n  }, []);\n  return (\n    <>\n      {!enableWebpackHmr && <DisableWebpackHmr />}\n      {node}\n    </>\n  );\n};\n\ntype RenderErrorListener = (err: Error) => void;\nconst renderErrorListeners: RenderErrorListener[] = [];\nexport function registerRenderErrorListener(listener: RenderErrorListener) {\n  renderErrorListeners.push(listener);\n  return () => {\n    const index = renderErrorListeners.indexOf(listener);\n    if (index >= 0) {\n      renderErrorListeners.splice(index, 1);\n    }\n  };\n}\n\ninterface ErrorBoundaryProps {\n  children?: React.ReactNode;\n}\n\ninterface ErrorBoundaryState {\n  error?: Error;\n}\n\nclass ErrorBoundary extends React.Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = {};\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    return { error };\n  }\n\n  componentDidCatch(error: Error) {\n    renderErrorListeners.forEach((listener) => listener(error));\n  }\n\n  render() {\n    if (this.state.error) {\n      return <div>Error: {`${this.state.error.message}`}</div>;\n    } else {\n      return <>{this.props.children}</>;\n    }\n  }\n}\n\nfunction DisableWebpackHmr() {\n  if (process.env.NODE_ENV === \"production\") {\n    return null;\n  }\n  return (\n    <script\n      type=\"text/javascript\"\n      dangerouslySetInnerHTML={{\n        __html: `\n      if (typeof window !== \"undefined\") {\n        const RealEventSource = window.EventSource;\n        window.EventSource = function(url, config) {\n          if (/[^a-zA-Z]hmr($|[^a-zA-Z])/.test(url)) {\n            console.warn(\"Plasmic: disabled EventSource request for\", url);\n            return {\n              onerror() {}, onmessage() {}, onopen() {}, close() {}\n            };\n          } else {\n            return new RealEventSource(url, config);\n          }\n        }\n      }\n      `,\n      }}\n    ></script>\n  );\n}\n\nfunction deriveCanvasContextValue(): PlasmicCanvasContextValue | false {\n  const hash = window.location.hash;\n  if (hash && hash.length > 0) {\n    // create URLsearchParams skipping the initial # character\n    const params = new URLSearchParams(hash.substring(1));\n    if (params.get(\"canvas\") === \"true\") {\n      const globalVariants = params.get(\"globalVariants\");\n      return {\n        componentName: params.get(\"componentName\") ?? null,\n        globalVariants: globalVariants ? JSON.parse(globalVariants) : {},\n        interactive: params.get(\"interactive\") === \"true\",\n      };\n    }\n  }\n  return false;\n}\n\nconst INTERNAL_CC_CANVAS_SELECTION_PROP = \"__plasmic_selection_prop__\";\n\nexport function usePlasmicCanvasComponentInfo(props: any) {\n  return React.useMemo(() => {\n    // Inside Plasmic Studio, code components will receive an additional prop\n    // that contains selection information for that specific code component.\n    // This hook will return that selection information which is useful for\n    // changing the behavior of the code component when it is selected, making\n    // it easier to interact with code components and slots that aren't always\n    // visible in the canvas. (e.g. automatically opening a modal when it's selected)\n    const selectionInfo = props?.[INTERNAL_CC_CANVAS_SELECTION_PROP];\n    if (selectionInfo) {\n      return {\n        isSelected: selectionInfo.isSelected as boolean,\n        selectedSlotName: selectionInfo.selectedSlotName as string | undefined,\n      };\n    }\n    return null;\n  }, [props]);\n}\n", "export const tuple = <T extends any[]>(...args: T): T => args;\n", "import React, {\n  createContext,\n  ReactElement,\n  ReactNode,\n  useContext,\n  useMemo,\n} from \"react\";\nimport { tuple } from \"./common\";\n\nexport type DataDict = Record<string, any>;\n\nexport const DataContext = createContext<DataDict | undefined>(undefined);\n\nexport type DataMeta = {\n  advanced?: boolean;\n  hidden?: boolean;\n  label?: string;\n};\n\nexport function mkMetaName(name: string) {\n  return `__plasmic_meta_${name}`;\n}\n\nexport function mkMetaValue(meta: Partial<DataMeta>): DataMeta {\n  return meta;\n}\n\nexport function applySelector(\n  rawData: DataDict | undefined,\n  selector: string | undefined\n): any {\n  if (!selector) {\n    return undefined;\n  }\n  let curData = rawData;\n  for (const key of selector.split(\".\")) {\n    curData = curData?.[key];\n  }\n  return curData;\n}\n\nexport type SelectorDict = Record<string, string | undefined>;\n\nexport function useSelector(selector: string | undefined): any {\n  const rawData = useDataEnv();\n  return applySelector(rawData, selector);\n}\n\nexport function useSelectors(selectors: SelectorDict = {}): any {\n  const rawData = useDataEnv();\n  return Object.fromEntries(\n    Object.entries(selectors)\n      .filter(([key, selector]) => !!key && !!selector)\n      .map(([key, selector]) => tuple(key, applySelector(rawData, selector)))\n  );\n}\n\nexport function useDataEnv() {\n  return useContext(DataContext);\n}\n\nexport interface DataProviderProps {\n  /**\n   * Key to set in data context.\n   */\n  name?: string;\n  /**\n   * Value to set for `name` in data context.\n   */\n  data?: any;\n  /**\n   * If true, hide this item in studio data picker.\n   */\n  hidden?: boolean;\n  /**\n   * If true, mark this item as advanced in studio.\n   */\n  advanced?: boolean;\n  /**\n   * Label to be shown in the studio data picker for easier navigation (data binding).\n   */\n  label?: string;\n  children?: ReactNode;\n}\n\nexport function DataProvider({\n  name,\n  data,\n  hidden,\n  advanced,\n  label,\n  children,\n}: DataProviderProps) {\n  const parentContext = useDataEnv();\n  const childContext = useMemo(() => {\n    if (!name) {\n      return null;\n    }\n    return {\n      ...parentContext,\n      [name]: data,\n      [mkMetaName(name)]: mkMetaValue({ hidden, advanced, label }),\n    };\n  }, [parentContext, name, data, hidden, advanced, label]);\n\n  if (childContext === null) {\n    return <>{children}</>;\n  } else {\n    return (\n      <DataContext.Provider value={childContext}>\n        {children}\n      </DataContext.Provider>\n    );\n  }\n}\n\n/**\n * This transforms `{ \"...slug\": \"a/b/c\" }` into `{ \"slug\": [\"a\", \"b\", \"c\"] }.\n */\nfunction fixCatchallParams(\n  params: Record<string, string | string[] | undefined>\n) {\n  const newParams: Record<string, string | string[]> = {};\n  for (const [key, value] of Object.entries(params)) {\n    if (!value) {\n      continue;\n    }\n    if (key.startsWith(\"...\")) {\n      newParams[key.slice(3)] =\n        typeof value === \"string\"\n          ? value.replace(/^\\/|\\/$/g, \"\").split(\"/\")\n          : value;\n    } else {\n      newParams[key] = value;\n    }\n  }\n  return newParams;\n}\n\nfunction mkPathFromRouteAndParams(\n  route: string,\n  params: Record<string, string | string[] | undefined>\n) {\n  if (!params) {\n    return route;\n  }\n  let path = route;\n  for (const [key, value] of Object.entries(params)) {\n    if (typeof value === \"string\") {\n      path = path.replace(`[${key}]`, value);\n    } else if (Array.isArray(value)) {\n      if (path.includes(`[[...${key}]]`)) {\n        path = path.replace(`[[...${key}]]`, value.join(\"/\"));\n      } else if (path.includes(`[...${key}]`)) {\n        path = path.replace(`[...${key}]`, value.join(\"/\"));\n      }\n    }\n  }\n  return path;\n}\n\nexport interface PageParamsProviderProps {\n  children?: ReactNode;\n\n  /**\n   * Page route without params substituted (e.g. /products/[slug]).\n   */\n  route?: string;\n\n  /**\n   * Page params (e.g. { slug: \"jacket\" })\n   */\n  params?: Record<string, string | string[] | undefined>;\n\n  /**\n   * Page query params (e.g. { q: \"search term\" })\n   */\n  query?: Record<string, string | string[] | undefined>;\n\n  /**\n   * @deprecated Use `route` instead.\n   */\n  path?: string;\n}\n\nexport function PageParamsProvider({\n  children,\n  route,\n  path: deprecatedRoute,\n  params = {},\n  query = {},\n}: PageParamsProviderProps) {\n  route = route ?? deprecatedRoute;\n  params = fixCatchallParams(params);\n  const $ctx = useDataEnv() || {};\n  const path = route ? mkPathFromRouteAndParams(route, params) : undefined;\n  return (\n    <DataProvider\n      name={\"pageRoute\"}\n      data={route}\n      label={\"Page route\"}\n      advanced={true}\n    >\n      <DataProvider name={\"pagePath\"} data={path} label={\"Page path\"}>\n        <DataProvider\n          name={\"params\"}\n          data={{ ...$ctx.params, ...params }}\n          label={\"Page URL path params\"}\n        >\n          <DataProvider\n            name={\"query\"}\n            data={{ ...$ctx.query, ...query }}\n            label={\"Page URL query params\"}\n          >\n            {children}\n          </DataProvider>\n        </DataProvider>\n      </DataProvider>\n    </DataProvider>\n  );\n}\n\nexport function DataCtxReader({\n  children,\n}: {\n  children: ($ctx: DataDict | undefined) => ReactNode;\n}) {\n  const $ctx = useDataEnv();\n  return children($ctx) as ReactElement | null;\n}\n", "import { PrimitiveType } from \"./prop-types\";\n\nconst root = globalThis as any;\n\nexport type Fetcher = (...args: any[]) => Promise<any>;\n\nexport interface FetcherMeta {\n  /**\n   * Any unique identifying string for this fetcher.\n   */\n  name: string;\n  /**\n   * The Studio-user-friendly display name.\n   */\n  displayName?: string;\n  /**\n   * The symbol to import from the importPath.\n   */\n  importName?: string;\n  args: { name: string; type: PrimitiveType }[];\n  returns: PrimitiveType;\n  /**\n   * Either the path to the fetcher relative to `rootDir` or the npm\n   * package name\n   */\n  importPath: string;\n  /**\n   * Whether it's a default export or named export\n   */\n  isDefaultExport?: boolean;\n}\n\nexport interface FetcherRegistration {\n  fetcher: Fetcher;\n  meta: FetcherMeta;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicFetcherRegistry: FetcherRegistration[];\n  }\n}\n\nroot.__PlasmicFetcherRegistry = [];\n\nexport function registerFetcher(fetcher: Fetcher, meta: FetcherMeta) {\n  root.__PlasmicFetcherRegistry.push({ fetcher, meta });\n}\n", "import React from \"react\";\n\nexport type GlobalActionDict = Record<string, Function>;\n\nexport const GlobalActionsContext = React.createContext<\n  GlobalActionDict | undefined\n>(undefined);\n\nexport function GlobalActionsProvider(props: {\n  contextName: string;\n  children?: React.ReactNode;\n  actions: GlobalActionDict;\n}) {\n  const { contextName, children, actions } = props;\n  const existingActions = useGlobalActions();\n  const namespacedActions = React.useMemo(\n    () =>\n      Object.fromEntries(\n        Object.entries(actions).map(([key, val]) => [\n          `${contextName}.${key}`,\n          val,\n        ])\n      ),\n    [contextName, actions]\n  );\n  return (\n    <GlobalActionsContext.Provider\n      value={{\n        ...existingActions,\n        ...namespacedActions,\n      }}\n    >\n      {children}\n    </GlobalActionsContext.Provider>\n  );\n}\n\nexport function useGlobalActions() {\n  return React.useContext(GlobalActionsContext) ?? {};\n}\n", "import React from \"react\";\n\nconst PlasmicLinkContext = React.createContext<\n  React.ComponentType<any> | undefined\n>(undefined);\n\nexport function usePlasmicLinkMaybe():\n  | React.ComponentType<React.ComponentProps<\"a\">>\n  | undefined {\n  return React.useContext(PlasmicLinkContext);\n}\n\nconst AnchorLink = React.forwardRef(function AnchorLink(\n  props: React.ComponentProps<\"a\">,\n  ref: React.Ref<HTMLAnchorElement>\n) {\n  return <a {...props} ref={ref} />;\n});\n\nexport function usePlasmicLink(): React.ComponentType<\n  React.ComponentProps<\"a\">\n> {\n  const Link = React.useContext(PlasmicLinkContext);\n  if (Link) {\n    return Link;\n  } else {\n    return AnchorLink as React.ComponentType<React.ComponentProps<\"a\">>;\n  }\n}\n\nexport function PlasmicLinkProvider(props: {\n  Link: React.ComponentType<any> | undefined;\n  children?: React.ReactNode;\n}) {\n  const { Link, children } = props;\n  return (\n    <PlasmicLinkContext.Provider value={Link}>\n      {children}\n    </PlasmicLinkContext.Provider>\n  );\n}\n", "import { CodeComponentElement, CSSProperties } from \"./element-types\";\nimport {\n  ContextDependentConfig,\n  InferDataType,\n  ProjectData,\n  PropType,\n  RestrictPropType,\n  StudioOps,\n} from \"./prop-types\";\nimport { TupleUnion } from \"./type-utils\";\nexport type * from \"./prop-types\";\n\nconst root = globalThis as any;\n\nexport interface ActionProps<P> {\n  componentProps: P;\n  /**\n   * `contextData` can be `null` if the prop controls are rendering before\n   * the component instance itself (it will re-render once the component\n   * calls `setControlContextData`)\n   */\n  contextData: InferDataType<P> | null;\n  /**\n   * Operations available to the editor that allow modifying the entire component.\n   */\n  studioOps: StudioOps;\n  /**\n   * Metadata from the studio project.\n   */\n  projectData: ProjectData;\n  /**\n   * The document that the component will be rendered into; instead of using\n   * `document` directly (for, say, `document.querySelector()` etc.), you\n   * should use this instead.\n   */\n  studioDocument: typeof document;\n}\n\nexport type Action<P> =\n  | {\n      type: \"button-action\";\n      label: string;\n      onClick: (props: ActionProps<P>) => void;\n      hidden?: ContextDependentConfig<P, boolean>;\n    }\n  | {\n      type: \"custom-action\";\n      control: React.ComponentType<ActionProps<P>>;\n      hidden?: ContextDependentConfig<P, boolean>;\n    };\n\ntype DistributedKeyOf<T> = T extends any ? keyof T : never;\n\ninterface ComponentTemplate<P>\n  extends Omit<CodeComponentElement<P>, \"type\" | \"name\"> {\n  /**\n   * A preview picture for the template.\n   */\n  previewImg?: string;\n}\n\nexport interface ComponentTemplates<P> {\n  [name: string]: ComponentTemplate<P>;\n}\n\nexport type StateSpec<P> = {\n  onChangeProp: string;\n\n  /**\n   * If true, will hide the state on studio.\n   */\n  hidden?: ContextDependentConfig<P, boolean>;\n\n  /**\n   * If true, will hide the state in a collapsed section; good for states that\n   * should not usually be used.\n   */\n  advanced?: ContextDependentConfig<P, boolean>;\n} & (\n  | {\n      type: \"readonly\";\n      variableType: \"text\";\n      initVal?: string;\n    }\n  | {\n      type: \"readonly\";\n      variableType: \"number\";\n      initVal?: number;\n    }\n  | {\n      type: \"readonly\";\n      variableType: \"boolean\";\n      initVal?: boolean;\n    }\n  | {\n      type: \"readonly\";\n      variableType: \"array\";\n      initVal?: any[];\n    }\n  | {\n      type: \"readonly\";\n      variableType: \"object\";\n      initVal?: object;\n    }\n  | {\n      type: \"readonly\";\n      variableType: \"dateString\";\n      initVal?: string;\n    }\n  | {\n      type: \"readonly\";\n      variableType: \"dateRangeStrings\";\n      initVal?: [string, string];\n    }\n  | {\n      type: \"writable\";\n      variableType:\n        | \"text\"\n        | \"number\"\n        | \"boolean\"\n        | \"array\"\n        | \"object\"\n        | \"dateString\"\n        | \"dateRangeStrings\";\n      valueProp: string;\n    }\n);\n\nexport interface StateHelpers<P, T> {\n  initFunc?: ($props: P) => T;\n  onChangeArgsToValue?: (...args: any) => T;\n  onMutate?: (stateValue: T, $ref: any) => void;\n}\n\n// A compile-time error will occur if a new field is added to the StateHelper\n// interface but not included in the keys array of state helper.\nexport const stateHelpersKeys: TupleUnion<keyof StateHelpers<any, any>> = [\n  \"initFunc\",\n  \"onChangeArgsToValue\",\n  \"onMutate\",\n];\n\nexport type ComponentHelpers<P> = {\n  states: Record<string, StateHelpers<P, any>>;\n};\n\nexport type ExternalComponentHelpers<P> = {\n  helpers: ComponentHelpers<P>;\n  importPath: string;\n} & (\n  | {\n      importName: string;\n    }\n  | {\n      isDefaultExport: true;\n    }\n);\n\nexport type StyleSection =\n  | \"visibility\"\n  | \"typography\"\n  | \"sizing\"\n  | \"spacing\"\n  | \"background\"\n  | \"transform\"\n  | \"transitions\"\n  | \"layout\"\n  | \"overflow\"\n  | \"border\"\n  | \"shadows\"\n  | \"effects\";\n\nexport interface CodeComponentMeta<P> {\n  /**\n   * Any unique string name used to identify that component. Each component\n   * should be registered with a different `meta.name`, even if they have the\n   * same name in the code.\n   */\n  name: string;\n  /**\n   * The name to be displayed for the component in Studio. Optional: if not\n   * specified, `meta.name` is used.\n   */\n  displayName?: string;\n  /**\n   * The description of the component to be shown in Studio.\n   */\n  description?: string;\n  /**\n   * A specific section to which the component should be displayed in Studio. By default, the component will be displayed in the \"Custom Components\" section.\n   * A new section will be created to display the components with the same `section` value.\n   */\n  section?: string;\n  /**\n   * A link to an image that will be displayed as a thumbnail of the component in the Studio, if the component has a `section` specified.\n   */\n  thumbnailUrl?: string;\n  /**\n   * The javascript name to be used when generating code. Optional: if not\n   * provided, `meta.name` is used.\n   */\n  importName?: string;\n  /**\n   * An object describing the component properties to be used in Studio.\n   * For each `prop`, there should be an entry `meta.props[prop]` describing\n   * its type.\n   */\n  props: { [prop in DistributedKeyOf<P>]?: RestrictPropType<P[prop], P> } & {\n    [prop: string]: PropType<P>;\n  };\n  /**\n   * An object describing the component states to be used in Studio.\n   */\n  states?: Record<string, StateSpec<P>>;\n  /**\n   * An object describing the components helpers to be used in Studio.\n   *   1. states helpers: Each state can receive an \"initFunc\" prop to initialize\n   *      the implicit state in Studio, and an \"onChangeArgsToValue\" prop to\n   *      transform the event handler arguments into a value\n   */\n  componentHelpers?: ExternalComponentHelpers<P>;\n  /**\n   * An array describing the component actions to be used in Studio.\n   */\n  actions?: Action<P>[];\n  /**\n   * Whether style sections should be shown in Studio. For styles to work, the\n   * component must accept a `className` prop. If unset, defaults to all styles.\n   * Set to `false` if this component cannot be styled (for example, if it doesn't\n   * render any DOM elements).\n   */\n  styleSections?: StyleSection[] | boolean;\n  /**\n   * Whether the element can be repeated in Studio. If unset, defaults to true.\n   */\n  isRepeatable?: boolean;\n  /**\n   * The path to be used when importing the component in the generated code.\n   * It can be the name of the package that contains the component, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   *  Whether the component is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n  /**\n   * The prop that expects the CSS classes with styles to be applied to the\n   * component. Optional: if not specified, Plasmic will expect it to be\n   * `className`. Notice that if the component does not accept CSS classes, the\n   * component will not be able to receive styles from the Studio.\n   */\n  classNameProp?: string;\n  /**\n   * The prop that receives and forwards a React `ref`. Plasmic only uses `ref`\n   * to interact with components, so it's not used in the generated code.\n   * Optional: If not provided, the usual `ref` is used.\n   */\n  refProp?: string;\n  /**\n   * Default styles to start with when instantiating the component in Plasmic.\n   */\n  defaultStyles?: CSSProperties;\n  /**\n   * Component templates to start with on Plasmic.\n   */\n  templates?: ComponentTemplates<P>;\n  /**\n   * Registered name of parent component, used for grouping related components.\n   */\n  parentComponentName?: string;\n  /**\n   * Whether the component can be used as an attachment to an element.\n   */\n  isAttachment?: boolean;\n  /**\n   * Whether the component provides data to its slots using DataProvider.\n   */\n  providesData?: boolean;\n\n  /**\n   * If specified, then Figma components with the specified names will be mapped\n   * to this component when you paste Figma content into Plasmic\n   */\n  figmaMappings?: {\n    figmaComponentName: string;\n  }[];\n\n  /**\n   * If specified, then Figma components will have their properties transformed\n   * before being applied to this component. This is useful for transforming Figma\n   * properties to the format expected by the component.\n   */\n  figmaPropsTransform?: (\n    props: Record<string, string | number | boolean>\n  ) => Record<\n    string,\n    string | number | boolean | null | unknown[] | Record<string, unknown>\n  >;\n\n  /**\n   * If true, when an instance of this component is added, the element\n   * will always be named by the name of this component.\n   */\n  alwaysAutoName?: boolean;\n\n  /**\n   * If true, then won't be listed in the insert menu for content creators.\n   */\n  hideFromContentCreators?: boolean;\n\n  refActions?: Record<string, RefActionRegistration<P>>;\n\n  /**\n   * Optional function that takes in component props and context, and returns\n   * a string that will be used for labeling this element in the Outline panel\n   * on the left of the Studio.  This makes it easy to identify an element when\n   * looking at the tree.\n   */\n  treeLabel?: ContextDependentConfig<P, string>;\n\n  /**\n   * The value of the CSS display property used by this component.\n   * Plasmic passes in a class name prop to components to let users style them,\n   * but normally this does not include layout properties like display.\n   * However, if the user has set the components visibility to be visible\n   * (for instance, in the base variant it was set to not visible ie display none,\n   * but in a variant it's overridden to be visible), then Plasmic needs to know\n   * what display property to set.\n   * Defaults to \"flex\".\n   */\n  defaultDisplay?: string;\n\n  /**\n   * When true, when you click for the first time anywhere in the component including its slots, the component itself is\n   * selected, making it easier to select the component instead of slot contents. So for instance, setting this on a\n   * Button ensures that clicking on the Buttonâ€™s text will still select the Button and not the text element in its\n   * slot. Clicking again will deep-select the slot content.\n   */\n  trapsFocus?: boolean;\n\n  /**\n   * An object registering code component's variants that should be allowed in Studio, when the component is\n   * used as the root of a Studio component.\n   */\n  variants?: Record<\n    string,\n    {\n      cssSelector: string;\n      displayName: string;\n    }\n  >;\n}\n\nexport type CodeComponentMode =\n  | \"advanced\"\n  | \"simplified\"\n  | \"database-schema-driven\";\n\n/**\n * @deprecated use CodeComponentMeta instead\n */\nexport type ComponentMeta<P> = CodeComponentMeta<P>;\n\nexport interface FunctionParam<P> {\n  name: string;\n  displayName?: string;\n  type: PropType<P>;\n}\n\nexport interface RefActionRegistration<P> {\n  displayName?: string;\n  description?: string;\n  argTypes: FunctionParam<P>[];\n}\n\nexport interface ComponentRegistration {\n  component: React.ComponentType<any>;\n  meta: CodeComponentMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicComponentRegistry: ComponentRegistration[];\n  }\n}\n\nif (root.__PlasmicComponentRegistry == null) {\n  root.__PlasmicComponentRegistry = [];\n}\n\nexport default function registerComponent<T extends React.ComponentType<any>>(\n  component: T,\n  meta: CodeComponentMeta<React.ComponentProps<T>>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicComponentRegistry.some(\n      (r: ComponentRegistration) =>\n        r.component === component && r.meta.name === meta.name\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicComponentRegistry.push({ component, meta });\n}\n", "import { Nullish } from \"./type-utils\";\n\nconst root = globalThis as any;\n\n/**\n * Context that we pass back to control functions.\n */\nexport type ControlContext<P> = [\n  /**\n   * props\n   */\n  Partial<P>,\n  /**\n   * context data\n   */\n  any\n];\n\n/**\n * Config option that takes the context (e.g., props) of the function call\n * to dynamically set its value.\n */\nexport type ContextDependentConfig<P, R> = (...args: ControlContext<P>) => R;\n\nexport interface BaseParam {\n  name: string;\n  description?: string;\n  isOptional?: boolean;\n  isRestParameter?: boolean;\n}\n\nexport interface ChoiceTypeBase<P, T> extends BaseParam {\n  type: \"choice\";\n  options:\n    | T[]\n    | {\n        label: string;\n        value: T;\n      }[]\n    | ContextDependentConfig<\n        P,\n        | T[]\n        | {\n            label: string;\n            value: T;\n          }[]\n      >;\n  allowSearch?: boolean;\n  filterOption?: boolean;\n  onSearch?: ContextDependentConfig<P, ((value: string) => void) | undefined>;\n}\n\nexport interface SingleChoiceType<P, T> extends ChoiceTypeBase<P, T> {\n  multiSelect?: false;\n}\n\nexport interface MultiChoiceType<P, T> extends ChoiceTypeBase<P, T[]> {\n  multiSelect: true;\n}\n\nexport interface CustomChoiceType<P, T> extends ChoiceTypeBase<P, T | T[]> {\n  multiSelect: ContextDependentConfig<P, boolean>;\n}\n\nexport type ChoiceType<P, T> =\n  | SingleChoiceType<P, T>\n  | MultiChoiceType<P, T>\n  | CustomChoiceType<P, T>;\n\nexport interface PlainStringType<T extends Nullish<string> = string>\n  extends BaseParam {\n  type: \"string\" | `'${T}'`;\n}\n\nexport type StringType<P, T extends Nullish<string> = string> =\n  | \"string\"\n  | PlainStringType<T>\n  | ChoiceType<P, T>\n  | AnyType;\n\nexport interface PlainNumberType<T extends Nullish<number> = number>\n  extends BaseParam {\n  type: \"number\" | `${number extends T ? number : T}`;\n}\n\nexport type NumberType<P, T extends Nullish<number> = number> =\n  | PlainNumberType<T>\n  | ChoiceType<P, T>\n  | AnyType;\n\nexport interface PlainBooleanType<T extends Nullish<boolean> = boolean>\n  extends BaseParam {\n  type: \"boolean\" | `${boolean extends T ? boolean : T}`;\n}\n\nexport type BooleanType<P, T extends Nullish<boolean> = boolean> =\n  | PlainBooleanType<T>\n  | ChoiceType<P, T>\n  | AnyType;\n\nexport type GraphQLValue = {\n  query: string;\n  variables?: Record<string, any>;\n};\n\nexport interface GraphQLType<P> extends BaseParam {\n  type: \"code\";\n  lang: \"graphql\";\n  endpoint: string | ContextDependentConfig<P, string>;\n  method?: string | ContextDependentConfig<P, string>;\n  headers?: object | ContextDependentConfig<P, object>;\n}\n\nexport interface PlainNullType extends BaseParam {\n  type: \"null\";\n}\nexport type NullType = PlainNullType | AnyType;\n\nexport interface PlainUndefinedType extends BaseParam {\n  type: \"undefined\";\n}\nexport type UndefinedType = PlainUndefinedType | AnyType;\n\nexport interface PlainArrayType extends BaseParam {\n  type: \"array\";\n}\nexport type ArrayType = PlainArrayType | AnyType;\n\nexport interface PlainObjectType extends BaseParam {\n  type: \"object\";\n}\nexport type ObjectType = PlainObjectType | AnyType;\n\nexport interface PlainAnyType extends BaseParam {\n  type: \"any\";\n}\nexport type AnyType = PlainAnyType;\n\nexport interface PlainVoidType extends BaseParam {\n  type: \"void\";\n}\nexport type VoidType = PlainVoidType | AnyType;\n\ntype IsAny<T> = 0 extends 1 & T ? true : false;\n\ntype CommonType<P, T> = T extends GraphQLValue\n  ? GraphQLType<P>\n  : T extends null\n  ? NullType\n  : T extends undefined\n  ? UndefinedType\n  : T extends Array<any>\n  ? ArrayType\n  : T extends object\n  ? ObjectType\n  : AnyType;\n\ntype AnyTyping<P, T> = T extends string\n  ? StringType<P, T>\n  : T extends number\n  ? NumberType<P, T>\n  : T extends boolean\n  ? BooleanType<P, T>\n  : CommonType<P, T>;\n\nexport type RestrictedType<P, T> = IsAny<T> extends true\n  ? AnyTyping<P, T>\n  : [T] extends [Nullish<string>]\n  ? StringType<P, T>\n  : [T] extends [Nullish<number>]\n  ? NumberType<P, T>\n  : [T] extends [Nullish<boolean>]\n  ? BooleanType<P, T>\n  : CommonType<P, T>;\n\nexport type ParamType<P, T> = RestrictedType<P, T>;\n\nexport type RequiredParam<P, T> = ParamType<P, T> & {\n  isOptional?: false;\n  isRestParameter?: false;\n};\n\nexport type OptionalParam<P, T> = ParamType<P, T> & {\n  isRestParameter?: false;\n};\n\nexport type RestParam<P, T> = ParamType<P, T> & {\n  isOptional?: false;\n  isRestParameter: true;\n};\n\n// https://stackoverflow.com/questions/70684030/remove-all-optional-items-from-a-tuple-type\ntype RequiredParams<\n  T extends any[],\n  U extends any[] = []\n> = Partial<T> extends T\n  ? U\n  : T extends [infer F, ...infer R]\n  ? RequiredParams<R, [...U, F]>\n  : U;\n\ntype OptionalParams<T extends any[]> = T extends [\n  ...RequiredParams<T>,\n  ...infer R\n]\n  ? [...R]\n  : [];\n\ntype HandleRequiredParams<P, R extends any[]> = R extends [infer H, ...infer T]\n  ? [string | RequiredParam<P, H>, ...HandleRequiredParams<P, T>]\n  : [];\n\ntype HandleOptionalParams<P, R extends any[]> = R extends [infer H, ...infer T]\n  ?\n      | []\n      | [\n          string | OptionalParam<P, H | undefined>,\n          ...HandleOptionalParams<P, T>\n        ]\n  : R extends []\n  ? []\n  : R extends Array<infer T>\n  ? [] | [RestParam<P, T[]>]\n  : [];\n\nexport type HandleParams<P extends any[]> = [\n  ...HandleRequiredParams<P, RequiredParams<P>>,\n  ...HandleOptionalParams<P, Required<OptionalParams<P>>>\n];\n\nexport type HandleReturnType<P, T> = VoidType | ParamType<P, T>;\n\nexport interface CustomFunctionMeta<F extends (...args: any[]) => any> {\n  /**\n   * The javascript name of the function. Notice it must be unique across all\n   * other functions and function namespaces. If two functions have the same\n   * name, they should be registered with different `meta.namespace`.\n   */\n  name: string;\n  /**\n   * A namespace for organizing groups of functions. It's also used to handle\n   * function name collisions. If a function has a namespace, it will be used\n   * whenever accessing the function.\n   */\n  namespace?: string;\n  /**\n   * A display name for the function. It will be shown only in studio.\n   */\n  displayName?: string;\n  /**\n   * Documentation for the registered function.\n   */\n  description?: string;\n  /**\n   * An array containing the list of parameters names the function takes.\n   * Optionally they can also be registered with the expected param types.\n   */\n  params?: HandleParams<Parameters<F>>;\n  /**\n   * Return value information.\n   */\n  returnValue?: {\n    /**\n     * The function return type.\n     */\n    type?: HandleReturnType<Parameters<F>, ReturnType<F>>;\n    /**\n     * The function return value description.\n     */\n    description?: string;\n  };\n  /**\n   * Typescript function declaration. If specified, it ignores the types\n   * provided by `params` and `returnValue`.\n   */\n  typescriptDeclaration?: string;\n\n  /**\n   * Whether this function can be used as a query in the editor.\n   */\n  isQuery?: boolean;\n  /**\n   * The path to be used when importing the function in the generated code.\n   * It can be the name of the package that contains the function, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   * Whether the function is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n\n  /**\n   * A function that takes the function arguments and returns a data key\n   * and a fetcher function.\n   * The data key is used to cache the result of the fetcher, and should only\n   * include the arguments that are used to fetch the data.\n   * The result of the fetcher will be used as the context of the function\n   * in studio and should return a promise.\n   */\n  fnContext?: (...args: Partial<Parameters<F>>) => {\n    dataKey: string;\n    fetcher: () => Promise<any>;\n  };\n}\n\nexport interface CustomFunctionRegistration {\n  function: (...args: any[]) => any;\n  meta: CustomFunctionMeta<any>;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicFunctionsRegistry: CustomFunctionRegistration[];\n  }\n}\n\nif (root.__PlasmicFunctionsRegistry == null) {\n  root.__PlasmicFunctionsRegistry = [];\n}\n\nexport default function registerFunction<F extends (...args: any[]) => any>(\n  fn: F,\n  meta: CustomFunctionMeta<F>\n) {\n  // Check for duplicates\n  if (\n    root.__PlasmicFunctionsRegistry.some(\n      (r: CustomFunctionRegistration) =>\n        r.function === fn &&\n        r.meta.name === meta.name &&\n        r.meta.namespace == meta.namespace\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicFunctionsRegistry.push({ function: fn, meta });\n}\n", "import {\n  BooleanType,\n  ChoiceType,\n  CustomType,\n  DataSourceType,\n  JSONLikeType,\n  NumberType,\n  StringType,\n} from \"./prop-types\";\nimport { FunctionParam } from \"./registerComponent\";\n\nconst root = globalThis as any;\n\n// Using just a subset of types from prop-types\nexport type PropType<P> =\n  | StringType<P>\n  | BooleanType<P>\n  | NumberType<P>\n  | JSONLikeType<P>\n  | ChoiceType<P>\n  | DataSourceType<P>\n  | CustomType<P>;\n\ntype RestrictPropType<T, P> = T extends string\n  ? StringType<P> | ChoiceType<P> | JSONLikeType<P> | CustomType<P>\n  : T extends boolean\n  ? BooleanType<P> | JSONLikeType<P> | CustomType<P>\n  : T extends number\n  ? NumberType<P> | JSONLikeType<P> | CustomType<P>\n  : PropType<P>;\n\ntype DistributedKeyOf<T> = T extends any ? keyof T : never;\n\nexport interface GlobalContextMeta<P> {\n  /**\n   * Any unique string name used to identify that context. Each context\n   * should be registered with a different `meta.name`, even if they have the\n   * same name in the code.\n   */\n  name: string;\n  /**\n   * The name to be displayed for the context in Studio. Optional: if not\n   * specified, `meta.name` is used.\n   */\n  displayName?: string;\n  /**\n   * The description of the context to be shown in Studio.\n   */\n  description?: string;\n  /**\n   * The javascript name to be used when generating code. Optional: if not\n   * provided, `meta.name` is used.\n   */\n  importName?: string;\n  /**\n   * An object describing the context properties to be used in Studio.\n   * For each `prop`, there should be an entry `meta.props[prop]` describing\n   * its type.\n   */\n  props: { [prop in DistributedKeyOf<P>]?: RestrictPropType<P[prop], P> } & {\n    [prop: string]: PropType<P>;\n  };\n  /**\n   * The path to be used when importing the context in the generated code.\n   * It can be the name of the package that contains the context, or the path\n   * to the file in the project (relative to the root directory).\n   */\n  importPath: string;\n  /**\n   *  Whether the context is the default export from that path. Optional: if\n   * not specified, it's considered `false`.\n   */\n  isDefaultExport?: boolean;\n  /**\n   * The prop that receives and forwards a React `ref`. Plasmic only uses `ref`\n   * to interact with components, so it's not used in the generated code.\n   * Optional: If not provided, the usual `ref` is used.\n   */\n  refProp?: string;\n  /**\n   * Whether the global context provides data to its children using DataProvider.\n   */\n  providesData?: boolean;\n\n  globalActions?: Record<string, GlobalActionRegistration<P>>;\n}\n\nexport interface GlobalContextRegistration {\n  component: React.ComponentType<any>;\n  meta: GlobalContextMeta<any>;\n}\n\nexport interface GlobalActionRegistration<P> {\n  displayName?: string;\n  description?: string;\n  parameters: FunctionParam<P>[];\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicContextRegistry: GlobalContextRegistration[];\n  }\n}\n\nif (root.__PlasmicContextRegistry == null) {\n  root.__PlasmicContextRegistry = [];\n}\n\nexport default function registerGlobalContext<\n  T extends React.ComponentType<any>\n>(component: T, meta: GlobalContextMeta<React.ComponentProps<T>>) {\n  // Check for duplicates\n  if (\n    root.__PlasmicContextRegistry.some(\n      (r: GlobalContextRegistration) =>\n        r.component === component && r.meta.name === meta.name\n    )\n  ) {\n    return;\n  }\n  root.__PlasmicContextRegistry.push({ component, meta });\n}\n", "export type TokenType =\n  | \"color\"\n  | \"spacing\"\n  | \"font-family\"\n  | \"font-size\"\n  | \"line-height\"\n  | \"opacity\";\n\nexport interface TokenRegistration {\n  /**\n   * Name for this token; should be stable across updates\n   */\n  name: string;\n  /**\n   * Value for the token, which can either be a valid css value or a css reference\n   * to a css variable provided by your host app, like `var(--my-token)`\n   */\n  value: string;\n  /**\n   * Type of token\n   */\n  type: TokenType;\n  /**\n   * Optional display name to use for this token, if you'd like to use a friendlier\n   * name to display to Studio users\n   */\n  displayName?: string;\n  /**\n   * By default, if this token is a css variable reference like `var(--my-token)`,\n   * then it is assumed that `--my-token` is defined on `:root`.  If it is defined\n   * in another element, then you can pass in a selector for that element,\n   * like `.themeRoot`.\n   */\n  selector?: string;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicTokenRegistry: TokenRegistration[];\n  }\n}\n\nconst root = globalThis as any;\n\nif (root.__PlasmicTokenRegistry == null) {\n  root.__PlasmicTokenRegistry = [];\n}\n\nexport default function registerToken(token: TokenRegistration) {\n  root.__PlasmicTokenRegistry.push(token);\n}\n", "const root = globalThis as any;\n\nexport interface BasicTrait {\n  label?: string;\n  type: \"text\" | \"number\" | \"boolean\";\n}\n\nexport interface ChoiceTrait {\n  label?: string;\n  type: \"choice\";\n  options: string[];\n}\n\nexport type TraitMeta = BasicTrait | ChoiceTrait;\n\nexport interface TraitRegistration {\n  trait: string;\n  meta: TraitMeta;\n}\n\ndeclare global {\n  interface Window {\n    __PlasmicTraitRegistry: TraitRegistration[];\n  }\n}\n\nif (root.__PlasmicTraitRegistry == null) {\n  root.__PlasmicTraitRegistry = [];\n}\n\nexport default function registerTrait(trait: string, meta: TraitMeta) {\n  root.__PlasmicTraitRegistry.push({\n    trait,\n    meta,\n  });\n}\n", "import { cloneElement, isValidElement } from \"react\";\n\n/**\n * Allows elements to be repeated in Plasmic Studio.\n * @param index The index of the copy (starting at 0).\n * @param elt the React element to be repeated (or an array of such).\n */\nexport default function repeatedElement<T>(index: number, elt: T): T;\n/**\n * Allows elements to be repeated in Plasmic Studio.\n * @param isPrimary should be true for at most one instance of the element, and\n * indicates which copy of the element will be highlighted when the element is\n * selected in Studio.\n * @param elt the React element to be repeated (or an array of such).\n */\nexport default function repeatedElement<T>(isPrimary: boolean, elt: T): T;\nexport default function repeatedElement<T>(index: boolean | number, elt: T): T {\n  return repeatedElementFn(index as any, elt);\n}\n\nlet repeatedElementFn: typeof repeatedElement = (\n  index: boolean | number,\n  elt: any\n) => {\n  if (Array.isArray(elt)) {\n    return elt.map((v) => repeatedElementFn(index as any, v)) as any;\n  }\n  if (elt && isValidElement(elt) && typeof elt !== \"string\") {\n    return cloneElement(elt) as any;\n  }\n  return elt;\n};\n\nconst root = globalThis as any;\nexport const setRepeatedElementFn: (fn: typeof repeatedElement) => void =\n  root?.__Sub?.setRepeatedElementFn ??\n  function (fn: typeof repeatedElement) {\n    repeatedElementFn = fn;\n  };\n", "import React from \"react\";\n\nexport type PlasmicTranslator = (\n  str: string,\n  opts?: {\n    components?: {\n      [key: string]: React.ReactElement;\n    };\n  }\n) => React.ReactNode;\n\nexport interface PlasmicI18NContextValue {\n  translator?: PlasmicTranslator;\n  tagPrefix?: string;\n}\n\nexport const PlasmicTranslatorContext = React.createContext<\n  PlasmicI18NContextValue | PlasmicTranslator | undefined\n>(undefined);\n\nexport function usePlasmicTranslator() {\n  const _t = React.useContext(PlasmicTranslatorContext);\n  const translator = _t\n    ? typeof _t === \"function\"\n      ? _t\n      : _t.translator\n    : undefined;\n  return translator;\n}\n", "export const hostVersion = \"1.0.222\";\n", "import * as PlasmicQuery from \"@plasmicapp/query\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport * as jsxDevRuntime from \"react/jsx-dev-runtime\";\nimport * as jsxRuntime from \"react/jsx-runtime\";\nimport { registerRenderErrorListener, setPlasmicRootNode } from \"./canvas-host\";\nimport * as hostModule from \"./exports\";\nimport { setRepeatedElementFn } from \"./repeatedElement\";\n// version.ts is automatically generated by `yarn build` and not committed.\nimport { hostVersion } from \"./version\";\n\n// All exports must come from \"./exports\"\nexport * from \"./exports\";\n\nconst root = globalThis as any;\n\nif (root.__Sub == null) {\n  // Creating a side effect here by logging, so that vite won't\n  // ignore this block for whatever reason. Hiding this for now\n  // as users are complaining; will have to check if this has\n  // been fixed with vite.\n  // console.log(\"Plasmic: Setting up app host dependencies\");\n  root.__Sub = {\n    React,\n    ReactDOM,\n    jsxRuntime,\n    jsxDevRuntime,\n    PlasmicQuery,\n    hostModule,\n    hostVersion,\n    hostUtils: {\n      setPlasmicRootNode,\n      registerRenderErrorListener,\n      setRepeatedElementFn,\n    },\n\n    // For backwards compatibility:\n    setPlasmicRootNode,\n    registerRenderErrorListener,\n    setRepeatedElementFn,\n    ...hostModule,\n  };\n} else {\n  console.warn(\n    `Encountered likely duplicate host version: ${root.__Sub.hostVersion} vs ${hostVersion}`\n  );\n  root.__Sub.duplicateHostVersions = root.__Sub.duplicateHostVersions ?? [];\n  root.__Sub.duplicateHostVersions.push(hostVersion);\n}\n"],
  "mappings": "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",
  "names": ["_a", "PlasmicRootNodeWrapper", "_b", "ErrorBoundary", "React", "root", "AnchorLink"]
}
