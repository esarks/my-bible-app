import {
  registerComponent as registerComponent2
} from "./chunk-QCEALG4N.js";
import {
  DataProvider,
  PlasmicCanvasContext,
  applySelector,
  registerComponent,
  repeatedElement,
  useDataEnv,
  usePlasmicCanvasContext,
  useSelector,
  useSelectors
} from "./chunk-5TQMQLDD.js";
import {
  isPlasmicPrepass
} from "./chunk-BZYHGTYI.js";
import "./chunk-G5QNMKBJ.js";
import "./chunk-2DA65X2N.js";
import "./chunk-RLIK6ROT.js";
import {
  require_react
} from "./chunk-6JVJAL25.js";
import {
  __toESM,
  init_buffer,
  init_process
} from "./chunk-5AFJP5ZI.js";

// node_modules/@plasmicpkgs/plasmic-basic-components/dist/plasmic-basic-components.esm.js
init_process();
init_buffer();
var import_react = __toESM(require_react());
function ConditionGuardOnNotSatisfied(_ref) {
  var onNotSatisfied = _ref.onNotSatisfied;
  var ref = import_react.default.useRef(false);
  import_react.default.useEffect(function() {
    if (!ref.current) {
      ref.current = true;
      onNotSatisfied == null || onNotSatisfied();
    }
  }, [onNotSatisfied]);
  return null;
}
function isCurrentLocationInSkipPaths(skipPaths) {
  var _globalThis$__PLASMIC;
  var pathname = window.location.pathname;
  var currentPath = window.location.origin + pathname;
  var plasmicPathname = globalThis == null || (_globalThis$__PLASMIC = globalThis["__PLASMIC_STUDIO_PATH"]) == null ? void 0 : _globalThis$__PLASMIC.call(globalThis);
  return skipPaths == null ? void 0 : skipPaths.some(function(_ref2) {
    var path = _ref2.path;
    return path === pathname || path === currentPath || path === plasmicPathname;
  });
}
function ConditionGuard(_ref3) {
  var condition = _ref3.condition, onNotSatisfied = _ref3.onNotSatisfied, children = _ref3.children, skipPaths = _ref3.skipPaths;
  if (!condition && !isCurrentLocationInSkipPaths(skipPaths)) {
    return import_react.default.createElement(ConditionGuardOnNotSatisfied, {
      onNotSatisfied
    });
  }
  return import_react.default.createElement(import_react.default.Fragment, null, children);
}
var conditionGuardMeta = {
  name: "hostless-condition-guard",
  displayName: "Condition Guard",
  description: "Ensure some condition, or else run an interaction. Examples: ensure all users have a database row, or require new users to setup a profile.",
  importName: "ConditionGuard",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    children: "slot",
    condition: {
      type: "boolean",
      displayName: "Condition",
      description: "The condition to guard against",
      helpText: "Condition to check. Render contents only if true. Run interaction if false.",
      defaultValue: true
    },
    onNotSatisfied: {
      type: "eventHandler",
      displayName: "On condition false",
      description: "The action to run when the condition is not satisfied",
      argTypes: []
    },
    skipPaths: {
      type: "array",
      displayName: "Skip Paths",
      description: "Paths that the action should not run",
      itemType: {
        type: "object",
        fields: {
          path: "href"
        },
        nameFunc: function nameFunc(item) {
          return item == null ? void 0 : item.path;
        }
      }
    }
  }
};
function registerConditionGuard(loader, customConditionGuardMeta) {
  if (loader) {
    loader.registerComponent(ConditionGuard, customConditionGuardMeta != null ? customConditionGuardMeta : conditionGuardMeta);
  } else {
    registerComponent2(ConditionGuard, customConditionGuardMeta != null ? customConditionGuardMeta : conditionGuardMeta);
  }
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
    t2[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t2, e2, r2) {
    return Object.defineProperty(t2, e2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }), t2[e2];
  }
  try {
    define({}, "");
  } catch (t2) {
    define = function(t3, e2, r2) {
      return t3[e2] = r2;
    };
  }
  function wrap(t2, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
    return o(a2, "_invoke", {
      value: makeInvokeMethod(t2, r2, c2)
    }), a2;
  }
  function tryCatch(t2, e2, r2) {
    try {
      return {
        type: "normal",
        arg: t2.call(e2, r2)
      };
    } catch (t3) {
      return {
        type: "throw",
        arg: t3
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p = {};
  define(p, a, function() {
    return this;
  });
  var d = Object.getPrototypeOf, v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t2) {
    ["next", "throw", "return"].forEach(function(e2) {
      define(t2, e2, function(t3) {
        return this._invoke(e2, t3);
      });
    });
  }
  function AsyncIterator(t2, e2) {
    function invoke(r3, o2, i2, a2) {
      var c2 = tryCatch(t2[r3], t2, o2);
      if ("throw" !== c2.type) {
        var u2 = c2.arg, h2 = u2.value;
        return h2 && "object" == typeof h2 && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
          invoke("next", t3, i2, a2);
        }, function(t3) {
          invoke("throw", t3, i2, a2);
        }) : e2.resolve(h2).then(function(t3) {
          u2.value = t3, i2(u2);
        }, function(t3) {
          return invoke("throw", t3, i2, a2);
        });
      }
      a2(c2.arg);
    }
    var r2;
    o(this, "_invoke", {
      value: function(t3, n2) {
        function callInvokeWithMethodAndArg() {
          return new e2(function(e3, r3) {
            invoke(t3, n2, e3, r3);
          });
        }
        return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h;
    return function(i2, a2) {
      if (o2 === f) throw Error("Generator is already running");
      if (o2 === s) {
        if ("throw" === i2) throw a2;
        return {
          value: t,
          done: true
        };
      }
      for (n2.method = i2, n2.arg = a2; ; ) {
        var c2 = n2.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n2);
          if (u2) {
            if (u2 === y) continue;
            return u2;
          }
        }
        if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h) throw o2 = s, n2.arg;
          n2.dispatchException(n2.arg);
        } else "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f;
        var p2 = tryCatch(e2, r2, n2);
        if ("normal" === p2.type) {
          if (o2 = n2.done ? s : l, p2.arg === y) continue;
          return {
            value: p2.arg,
            done: n2.done
          };
        }
        "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
  }
  function pushTryEntry(t2) {
    var e2 = {
      tryLoc: t2[0]
    };
    1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t2) {
    var e2 = t2.completion || {};
    e2.type = "normal", delete e2.arg, t2.completion = e2;
  }
  function Context(t2) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t2.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a];
      if (r2) return r2.call(e2);
      if ("function" == typeof e2.next) return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
          return next.value = t, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(typeof e2 + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
    var e2 = "function" == typeof t2 && t2.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
  }, e.awrap = function(t2) {
    return {
      __await: t2
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
      return t3.done ? t3.value : a2.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
    return this;
  }), define(g, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t2) {
    var e2 = Object(t2), r2 = [];
    for (var n2 in e2) r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t3 = r2.pop();
        if (t3 in e2) return next.value = t3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function(e2) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
    },
    stop: function() {
      this.done = true;
      var t2 = this.tryEntries[0].completion;
      if ("throw" === t2.type) throw t2.arg;
      return this.rval;
    },
    dispatchException: function(e2) {
      if (this.done) throw e2;
      var r2 = this;
      function handle(n2, o3) {
        return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
      }
      for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
        var i2 = this.tryEntries[o2], a2 = i2.completion;
        if ("root" === i2.tryLoc) return handle("end");
        if (i2.tryLoc <= this.prev) {
          var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
          if (c2 && u2) {
            if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
          } else if (c2) {
            if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
          } else {
            if (!u2) throw Error("try statement without catch or finally");
            if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
          }
        }
      }
    },
    abrupt: function(t2, e2) {
      for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
        var o2 = this.tryEntries[r2];
        if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
          var i2 = o2;
          break;
        }
      }
      i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
      var a2 = i2 ? i2.completion : {};
      return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
    },
    complete: function(t2, e2) {
      if ("throw" === t2.type) throw t2.arg;
      return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
    },
    finish: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
      }
    },
    catch: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.tryLoc === t2) {
          var n2 = r2.completion;
          if ("throw" === n2.type) {
            var o2 = n2.arg;
            resetTryEntry(r2);
          }
          return o2;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(e2, r2, n2) {
      return this.delegate = {
        iterator: values(e2),
        resultName: r2,
        nextLoc: n2
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
var _excluded = ["tag", "className", "children", "propSelectors"];
var _excluded2 = ["selector", "propSelectors"];
var _excluded3 = ["selector", "propSelectors"];
var thisModule = "@plasmicpkgs/plasmic-basic-components";
var applySelector2 = function applySelector3() {
  console.warn("DEPRECATED: Import applySelector from @plasmicapp/host instead.");
  return applySelector.apply(void 0, arguments);
};
var useSelector2 = function useSelector3() {
  console.warn("DEPRECATED: Import useSelector from @plasmicapp/host instead.");
  return useSelector.apply(void 0, arguments);
};
var useSelectors2 = function useSelectors3() {
  console.warn("DEPRECATED: Import useSelectors from @plasmicapp/host instead.");
  return useSelectors.apply(void 0, arguments);
};
var useDataEnv2 = function useDataEnv3() {
  console.warn("DEPRECATED: Import useDataEnv from @plasmicapp/host instead.");
  return useDataEnv.apply(void 0, arguments);
};
var DataProvider2 = function DataProvider3() {
  return DataProvider.apply(void 0, arguments);
};
function DynamicElement(_ref) {
  var _ref$tag = _ref.tag, tag = _ref$tag === void 0 ? "div" : _ref$tag, className = _ref.className, children = _ref.children, propSelectors = _ref.propSelectors, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var computed = useSelectors(propSelectors);
  return (0, import_react.createElement)(tag, _extends({
    children
  }, props, computed, {
    className: className + " " + computed.className
  }));
}
function DynamicText(_ref2) {
  var selector = _ref2.selector, propSelectors = _ref2.propSelectors, props = _objectWithoutPropertiesLoose(_ref2, _excluded2);
  return import_react.default.createElement(DynamicElement, Object.assign({}, props, {
    propSelectors: _extends({}, propSelectors, {
      children: selector
    })
  }), "(DynamicText requires a selector)");
}
function DynamicImage(_ref3) {
  var selector = _ref3.selector, propSelectors = _ref3.propSelectors, props = _objectWithoutPropertiesLoose(_ref3, _excluded3);
  return import_react.default.createElement(DynamicElement, Object.assign({
    tag: "img",
    loading: "lazy",
    style: {
      objectFit: "cover"
    }
  }, props, {
    propSelectors: _extends({}, propSelectors, {
      src: selector
    }),
    // Default image placeholder
    src: "https://studio.plasmic.app/static/img/placeholder.png"
  }));
}
function DynamicRepeater(_ref4) {
  var _ref5;
  var children = _ref4.children, loopItemName = _ref4.loopItemName, keySelector = _ref4.keySelector, selector = _ref4.selector, data = _ref4.data;
  var finalData = (_ref5 = data != null ? data : useSelector(selector)) != null ? _ref5 : [1, 2, 3];
  return import_react.default.createElement(import_react.default.Fragment, null, finalData == null || finalData.map == null ? void 0 : finalData.map(function(item, index) {
    var _applySelector2;
    return import_react.default.createElement(DataProvider, {
      key: (_applySelector2 = applySelector(item, keySelector)) != null ? _applySelector2 : index,
      name: loopItemName,
      data: item
    }, repeatedElement(index, children));
  }));
}
var dynamicRepeaterProps = {
  selector: {
    type: "string",
    description: "The selector expression to use to get the array of data to loop over, such as: someVariable.0.someField"
  },
  loopItemName: {
    type: "string",
    defaultValue: "item",
    description: "The name of the variable to use to store the current item in the loop"
  },
  children: {
    type: "slot",
    isRepeated: true
  }
};
var dynamicRepeaterMeta = {
  name: "hostless-dynamic-repeater",
  displayName: "Dynamic Repeater",
  importName: "DynamicRepeater",
  importPath: thisModule,
  props: dynamicRepeaterProps
};
function registerDynamicRepeater(loader, customDynamicRepeaterMeta) {
  if (loader) {
    loader.registerComponent(DynamicRepeater, customDynamicRepeaterMeta != null ? customDynamicRepeaterMeta : dynamicRepeaterMeta);
  } else {
    registerComponent2(DynamicRepeater, customDynamicRepeaterMeta != null ? customDynamicRepeaterMeta : dynamicRepeaterMeta);
  }
}
var dataProviderMeta = {
  name: "hostless-data-provider",
  displayName: "Data Provider",
  importName: "DataProvider",
  importPath: thisModule,
  providesData: true,
  // description: "Makes some specified data available to the subtree in a context",
  props: {
    name: {
      type: "string",
      defaultValue: "celebrities",
      description: "The name of the variable to store the data in"
    },
    data: {
      type: "object",
      defaultValue: [{
        name: "Fill Murray",
        birthYear: 1950,
        profilePicture: ["https://www.fillmurray.com/200/300"]
      }, {
        name: "Place Cage",
        birthYear: 1950,
        profilePicture: ["https://www.placecage.com/200/300"]
      }]
    },
    children: {
      type: "slot"
    }
  }
};
function registerDataProvider(loader, customDataProviderMeta) {
  if (loader) {
    loader.registerComponent(DataProvider, customDataProviderMeta != null ? customDataProviderMeta : dataProviderMeta);
  } else {
    registerComponent2(DataProvider, customDataProviderMeta != null ? customDataProviderMeta : dataProviderMeta);
  }
}
var dynamicPropsWithoutTag = {
  propSelectors: {
    type: "object",
    defaultValueHint: {},
    description: "An object whose keys are prop names and values are selector expressions. Use this to set any prop to a dynamic value."
  }
};
var dynamicProps = _extends({}, dynamicPropsWithoutTag, {
  tag: {
    type: "string",
    defaultValueHint: "div",
    description: "The HTML tag to use"
  }
});
var dynamicElementMeta = {
  name: "hostless-dynamic-element",
  displayName: "Dynamic Element",
  importName: "DynamicElement",
  importPath: thisModule,
  props: _extends({}, dynamicProps, {
    children: "slot"
  })
};
function registerDynamicElement(loader, customDynamicElementMeta) {
  if (loader) {
    loader.registerComponent(DynamicElement, customDynamicElementMeta != null ? customDynamicElementMeta : dynamicElementMeta);
  } else {
    registerComponent2(DynamicElement, customDynamicElementMeta != null ? customDynamicElementMeta : dynamicElementMeta);
  }
}
var dynamicTextMeta = {
  name: "hostless-dynamic-text",
  importName: "DynamicText",
  displayName: "Dynamic Text",
  importPath: thisModule,
  props: _extends({}, dynamicProps, {
    selector: {
      type: "string",
      description: "The selector expression to use to get the text, such as: someVariable.0.someField"
    }
  })
};
function registerDynamicText(loader, customDynamicTextMeta) {
  if (loader) {
    loader.registerComponent(DynamicText, customDynamicTextMeta != null ? customDynamicTextMeta : dynamicTextMeta);
  } else {
    registerComponent2(DynamicText, customDynamicTextMeta != null ? customDynamicTextMeta : dynamicTextMeta);
  }
}
var dynamicImageMeta = {
  name: "hostless-dynamic-image",
  displayName: "Dynamic Image",
  importName: "DynamicImage",
  importPath: thisModule,
  props: _extends({}, dynamicPropsWithoutTag, {
    selector: {
      type: "string",
      description: "The selector expression to use to get the image source URL, such as: someVariable.0.someField"
    }
  })
};
function registerDynamicImage(loader, customDynamicImageMeta) {
  if (loader) {
    loader.registerComponent(DynamicImage, customDynamicImageMeta != null ? customDynamicImageMeta : dynamicImageMeta);
  } else {
    registerComponent2(DynamicImage, customDynamicImageMeta != null ? customDynamicImageMeta : dynamicImageMeta);
  }
}
function ensure(x) {
  if (x === null || x === void 0) {
    debugger;
    throw new Error("Value must not be undefined or null");
  } else {
    return x;
  }
}
var isBrowser = typeof window !== "undefined";
var useIsomorphicLayoutEffect = isBrowser ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function useFirstRender() {
  var ref = import_react.default.useRef(true);
  var firstRender = ref.current;
  ref.current = false;
  return firstRender;
}
var useId = import_react.default.useId;
function Embed(_ref) {
  var className = _ref.className, code = _ref.code, _ref$hideInEditor = _ref.hideInEditor, hideInEditor = _ref$hideInEditor === void 0 ? false : _ref$hideInEditor;
  var rootElt = (0, import_react.useRef)(null);
  var inEditor = usePlasmicCanvasContext();
  var htmlId = useId == null ? void 0 : useId();
  var firstRender = useFirstRender();
  (0, import_react.useEffect)(function() {
    if (hideInEditor && inEditor) {
      return;
    }
    if (htmlId && !inEditor && firstRender && window[makePlasmicVarName(htmlId)]) {
      return;
    }
    var cleanup = false;
    _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
      var _loop, _ret, _i, _Array$from;
      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _loop = _regeneratorRuntime().mark(function _loop2() {
              var oldScript, newScript;
              return _regeneratorRuntime().wrap(function _loop$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    oldScript = _Array$from[_i];
                    newScript = document.createElement("script");
                    newScript.async = false;
                    Array.from(oldScript.attributes).forEach(function(attr) {
                      return newScript.setAttribute(attr.name, attr.value);
                    });
                    newScript.appendChild(document.createTextNode(oldScript.innerHTML));
                    ensure(oldScript.parentNode).replaceChild(newScript, oldScript);
                    if (!newScript.src) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 9;
                    return new Promise(function(resolve) {
                      return newScript.addEventListener("load", resolve);
                    });
                  case 9:
                    if (!cleanup) {
                      _context.next = 11;
                      break;
                    }
                    return _context.abrupt("return", {
                      v: void 0
                    });
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }, _loop2);
            });
            _i = 0, _Array$from = Array.from(ensure(rootElt.current).querySelectorAll("script"));
          case 2:
            if (!(_i < _Array$from.length)) {
              _context2.next = 10;
              break;
            }
            return _context2.delegateYield(_loop(), "t0", 4);
          case 4:
            _ret = _context2.t0;
            if (!_ret) {
              _context2.next = 7;
              break;
            }
            return _context2.abrupt("return", _ret.v);
          case 7:
            _i++;
            _context2.next = 2;
            break;
          case 10:
            return _context2.abrupt("return", function() {
              cleanup = true;
            });
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee);
    }))();
  }, [htmlId, code, hideInEditor, inEditor]);
  var effectiveCode = hideInEditor && inEditor ? "" : inEditor || !htmlId ? code : addIdentifierScript(htmlId, code);
  return import_react.default.createElement("div", {
    ref: rootElt,
    className,
    dangerouslySetInnerHTML: {
      __html: effectiveCode
    },
    style: {
      whiteSpace: "normal"
    }
  });
}
function makePlasmicVarName(id) {
  return "__plasmic_" + id.replace(/[^a-z0-9]/gi, "");
}
function addIdentifierScript(id, code) {
  return "<script>\n    var " + makePlasmicVarName(id) + " = 1;\n  <\/script>\n  " + code;
}
var embedMeta = {
  name: "hostless-embed",
  displayName: "Embed HTML",
  importName: "Embed",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    code: {
      type: "code",
      lang: "html",
      defaultValue: "<div>Paste your embed code via the right sidebar</div>",
      description: "The HTML code to be embedded"
    },
    hideInEditor: {
      type: "boolean",
      displayName: "Hide in editor",
      description: "Disable running the code while editing in Plasmic Studio (may require reload)",
      editOnly: true
    }
  },
  defaultStyles: {
    maxWidth: "100%"
  }
};
function registerEmbed(loader, customEmbedMeta) {
  if (loader) {
    loader.registerComponent(Embed, customEmbedMeta != null ? customEmbedMeta : embedMeta);
  } else {
    registerComponent2(Embed, customEmbedMeta != null ? customEmbedMeta : embedMeta);
  }
}
function Iframe(_ref) {
  var preview = _ref.preview, src = _ref.src, srcDoc = _ref.srcDoc, useHtml = _ref.useHtml, className = _ref.className, onLoad = _ref.onLoad;
  var isEditing = (0, import_react.useContext)(PlasmicCanvasContext);
  if (isEditing && !preview) {
    return import_react.default.createElement("div", {
      className
    }, import_react.default.createElement("div", {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: "#eee",
        color: "#888",
        fontSize: "36px",
        fontFamily: "sans-serif",
        fontWeight: "bold",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
      }
    }, "Iframe placeholder"));
  }
  var srcProps = useHtml ? {
    srcDoc
  } : {
    src
  };
  return import_react.default.createElement("iframe", Object.assign({}, srcProps, {
    className,
    onLoad
  }));
}
var iframeMeta = {
  name: "hostless-iframe",
  displayName: "Iframe",
  importName: "Iframe",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    useHtml: {
      type: "boolean",
      displayName: "Use HTML source",
      description: "Insert custom HTML directly into the iframe instead of using a URL.",
      defaultValue: false,
      advanced: true
    },
    srcDoc: {
      type: "code",
      lang: "html",
      displayName: "HTML source",
      description: "Raw HTML content that will be rendered inside an iframe.",
      defaultValue: "<div><h3>Heading</h3><p>Example text...</p></div>",
      hidden: function hidden(props) {
        return !props.useHtml;
      }
    },
    src: {
      type: "string",
      defaultValue: "https://www.example.com",
      hidden: function hidden2(props) {
        return !!props.useHtml;
      }
    },
    preview: {
      type: "boolean",
      description: "Load the iframe while editing in Plasmic Studio"
    },
    onLoad: {
      type: "eventHandler",
      argTypes: [{
        name: "event",
        type: "object"
      }]
    }
  },
  defaultStyles: {
    width: "300px",
    height: "150px",
    maxWidth: "100%"
  }
};
function registerIframe(loader, customIframeMeta) {
  if (loader) {
    loader.registerComponent(Iframe, customIframeMeta != null ? customIframeMeta : iframeMeta);
  } else {
    registerComponent2(Iframe, customIframeMeta != null ? customIframeMeta : iframeMeta);
  }
}
var reactMajorVersion = +import_react.default.version.split(".")[0];
if (reactMajorVersion < 18) {
  console.warn("The LoadingBoundary component only works with React 18+");
}
var enableLoadingBoundaryKey = "plasmicInternalEnableLoadingBoundary";
var hasLoadingBoundaryKey = "plasmicInternalHasLoadingBoundary";
function useIsClient() {
  var _useState = (0, import_react.useState)(false), loaded = _useState[0], setLoaded = _useState[1];
  useIsomorphicLayoutEffect(function() {
    setLoaded(true);
  }, []);
  return loaded;
}
var hasWarnedDisabledLoadingBoundary = false;
function warnDisabledLoadingBoundary() {
  if (!hasWarnedDisabledLoadingBoundary) {
    hasWarnedDisabledLoadingBoundary = true;
    console.warn("LoadingBoundary feature is not enabled. To use the LoadingBoundary component make sure to upgrade your @plasmicapp/* dependencies to the latest version and to wrap you App inside <PlasmicRootProvider />");
  }
}
function LoadingBoundary(_ref) {
  var _useDataEnv;
  var children = _ref.children, forceLoading = _ref.forceLoading, loadingState = _ref.loadingState;
  var isClient = useIsClient();
  var enableLoadingBoundary = !!((_useDataEnv = useDataEnv()) != null && _useDataEnv[enableLoadingBoundaryKey]);
  if (!isClient && !(isPlasmicPrepass != null && isPlasmicPrepass()) || forceLoading) {
    return import_react.default.createElement(import_react.default.Fragment, null, loadingState != null ? loadingState : null);
  }
  if (reactMajorVersion < 18) {
    return import_react.default.createElement(import_react.default.Fragment, null, children != null ? children : null);
  }
  if (!enableLoadingBoundary) {
    warnDisabledLoadingBoundary();
    return import_react.default.createElement(import_react.default.Fragment, null, children != null ? children : null);
  }
  return import_react.default.createElement(import_react.Suspense, {
    fallback: import_react.default.createElement(import_react.default.Fragment, null, loadingState != null ? loadingState : null)
  }, import_react.default.createElement(DataProvider, {
    hidden: true,
    name: hasLoadingBoundaryKey,
    data: true
  }, children != null ? children : null));
}
var loadingBoundaryMeta = {
  name: "hostless-loading-boundary",
  displayName: "Loading Boundary",
  importName: "LoadingBoundary",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    children: "slot",
    loadingState: {
      type: "slot",
      displayName: "Loading state",
      defaultValue: {
        type: "text",
        value: "Loading..."
      }
    },
    forceLoading: {
      type: "boolean",
      editOnly: true,
      displayName: "Preview loading",
      description: "Force preview the 'Loading' state - impacts only editor, and not published page behavior"
    }
  },
  providesData: true,
  styleSections: false,
  description: "Handle the loading state of queries and integrations"
};
function registerLoadingBoundary(loader, customLoadingBoundaryMeta) {
  if (loader) {
    loader.registerComponent(LoadingBoundary, customLoadingBoundaryMeta != null ? customLoadingBoundaryMeta : loadingBoundaryMeta);
  } else {
    registerComponent2(LoadingBoundary, customLoadingBoundaryMeta != null ? customLoadingBoundaryMeta : loadingBoundaryMeta);
  }
}
var thisModule$1 = "@plasmicpkgs/plasmic-basic-components";
var defaultItemName = "currentItem";
var defaultIndexName = "currentIndex";
function Repeater(props) {
  var children = props.children, items = props.items, itemName = props.itemName, indexName = props.indexName;
  if (!Array.isArray(items)) {
    throw new Error("Repeater received an invalid collection: not an array.");
  }
  return import_react.default.createElement(import_react.default.Fragment, null, items.map(function(item, index) {
    return import_react.default.createElement(DataProvider, {
      key: index.toString(),
      name: itemName || defaultItemName,
      data: item
    }, import_react.default.createElement(DataProvider, {
      name: indexName || defaultIndexName,
      data: index
    }, repeatedElement(index, children)));
  }));
}
var repeaterMeta = {
  name: "plasmic-repeater",
  displayName: "Repeater",
  importName: "Repeater",
  importPath: thisModule$1,
  providesData: true,
  props: {
    children: {
      type: "slot",
      isRepeated: true
    },
    items: {
      type: "array",
      defaultValue: [1, 2, 3],
      displayName: "Collection",
      description: "Items array (JavaScript expression)."
    },
    itemName: {
      type: "string",
      defaultValue: defaultItemName,
      defaultValueHint: defaultItemName,
      displayName: "Item",
      description: "Data context key for the current item."
    },
    indexName: {
      type: "string",
      defaultValue: defaultIndexName,
      defaultValueHint: defaultIndexName,
      displayName: "Index",
      description: "Data context key for the index of the current item."
    }
  }
};
function registerRepeater(loader, customRepeaterMeta) {
  if (loader) {
    loader.registerComponent(Repeater, customRepeaterMeta != null ? customRepeaterMeta : repeaterMeta);
  } else {
    registerComponent(Repeater, customRepeaterMeta != null ? customRepeaterMeta : repeaterMeta);
  }
}
function useDirectionalIntersection(_ref) {
  var ref = _ref.ref, _ref$scrollDownThresh = _ref.scrollDownThreshold, scrollDownThreshold = _ref$scrollDownThresh === void 0 ? 0.5 : _ref$scrollDownThresh, _ref$scrollUpThreshol = _ref.scrollUpThreshold, scrollUpThreshold = _ref$scrollUpThreshol === void 0 ? 0 : _ref$scrollUpThreshol;
  var _useState = (0, import_react.useState)(false), revealed = _useState[0], setRevealed = _useState[1];
  (0, import_react.useEffect)(function() {
    if (ref.current && typeof IntersectionObserver === "function") {
      var handler = function handler2(entries) {
        if (entries[0].intersectionRatio >= scrollDownThreshold) {
          setRevealed(true);
        } else if (entries[0].intersectionRatio <= scrollUpThreshold) {
          setRevealed(false);
        }
      };
      var observer = new IntersectionObserver(handler, {
        root: null,
        rootMargin: "0%",
        threshold: [scrollUpThreshold, scrollDownThreshold]
      });
      observer.observe(ref.current);
      return function() {
        setRevealed(false);
        observer.disconnect();
      };
    }
    return function() {
    };
  }, [ref.current, scrollDownThreshold, scrollUpThreshold]);
  return revealed;
}
function ScrollRevealer(_ref2) {
  var children = _ref2.children, className = _ref2.className, _ref2$scrollDownThres = _ref2.scrollDownThreshold, scrollDownThreshold = _ref2$scrollDownThres === void 0 ? 0.5 : _ref2$scrollDownThres, _ref2$scrollUpThresho = _ref2.scrollUpThreshold, scrollUpThreshold = _ref2$scrollUpThresho === void 0 ? 0 : _ref2$scrollUpThresho;
  var intersectionRef = (0, import_react.useRef)(null);
  var revealed = useDirectionalIntersection({
    ref: intersectionRef,
    scrollUpThreshold,
    scrollDownThreshold
  });
  return import_react.default.createElement("div", {
    className,
    ref: intersectionRef
  }, revealed ? children : null);
}
var scrollRevealerMeta = {
  name: "hostless-scroll-revealer",
  importName: "ScrollRevealer",
  displayName: "Scroll Revealer",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    children: "slot",
    scrollDownThreshold: {
      type: "number",
      displayName: "Scroll down threshold",
      defaultValueHint: 0.5,
      description: "How much of the element (as a fraction) must you scroll into view for it to appear (defaults to 0.5)"
    },
    scrollUpThreshold: {
      type: "number",
      displayName: "Scroll up threshold",
      defaultValueHint: 0,
      description: "While scrolling up, how much of the element (as a fraction) can still be scrolled in view before it disappears (defaults to 0, meaning you must scroll up until it's completely out of view)"
    }
  },
  defaultStyles: {
    width: "stretch",
    maxWidth: "100%"
  }
};
function registerScrollRevealer(loader, customScrollRevealerMeta) {
  if (loader) {
    loader.registerComponent(ScrollRevealer, customScrollRevealerMeta != null ? customScrollRevealerMeta : scrollRevealerMeta);
  } else {
    registerComponent2(ScrollRevealer, customScrollRevealerMeta != null ? customScrollRevealerMeta : scrollRevealerMeta);
  }
}
function SideEffect(_ref) {
  var deps = _ref.deps, onMount = _ref.onMount, onUnmount = _ref.onUnmount;
  import_react.default.useEffect(function() {
    onMount == null || onMount();
    return function() {
      onUnmount == null || onUnmount();
    };
  }, deps != null ? deps : []);
  return null;
}
var sideEffectMeta = {
  name: "hostless-side-effect",
  displayName: "Side Effect",
  description: "Run actions on load, unload, and when data changes.",
  importName: "SideEffect",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    onMount: {
      type: "eventHandler",
      displayName: "On load",
      description: "Actions to run when this Side Effect component is mounted.",
      argTypes: []
    },
    onUnmount: {
      type: "eventHandler",
      displayName: "On unload",
      description: "Actions to run when this Side Effect component is unmounted.",
      argTypes: []
    },
    deps: {
      type: "array",
      displayName: "When data changes",
      description: "List of values which should trigger a re-run of the actions if changed."
    }
  }
};
function registerSideEffect(loader, customMeta) {
  if (loader) {
    loader.registerComponent(SideEffect, customMeta != null ? customMeta : sideEffectMeta);
  } else {
    registerComponent2(SideEffect, customMeta != null ? customMeta : sideEffectMeta);
  }
}
function useInterval(callback, delay) {
  var savedCallback = (0, import_react.useRef)(callback);
  useIsomorphicLayoutEffect(function() {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react.useEffect)(function() {
    if (!delay && delay !== 0) {
      return;
    }
    var id = setInterval(function() {
      return savedCallback.current();
    }, delay);
    return function() {
      return clearInterval(id);
    };
  }, [delay]);
}
function Timer(_ref) {
  var _ref$intervalSeconds = _ref.intervalSeconds, intervalSeconds = _ref$intervalSeconds === void 0 ? 1 : _ref$intervalSeconds, _ref$isRunning = _ref.isRunning, isRunning = _ref$isRunning === void 0 ? false : _ref$isRunning, _ref$onTick = _ref.onTick, onTick = _ref$onTick === void 0 ? function() {
  } : _ref$onTick, runWhileEditing = _ref.runWhileEditing, canvasId = _ref["data-plasmic-canvas-envs"];
  var isEditMode = (0, import_react.useMemo)(function() {
    return canvasId !== void 0;
  }, [canvasId]);
  useInterval(
    onTick,
    // Delay in milliseconds or null to stop it
    isRunning && (isEditMode ? runWhileEditing : true) ? intervalSeconds * 1e3 : null
  );
  return null;
}
var timerMeta = {
  name: "hostless-timer",
  displayName: "Timer",
  description: "Run something periodically",
  importName: "Timer",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    onTick: {
      type: "eventHandler",
      displayName: "Run this every interval",
      description: "Actions to run periodically",
      argTypes: []
    },
    isRunning: {
      type: "boolean",
      displayName: "Is Running?",
      defaultValue: true
    },
    runWhileEditing: {
      type: "boolean",
      displayName: "Run while editing",
      description: "Normally this only runs in the live site or in preview mode, but you can force it to run even while you are editing in the canvas (Please enable interactive mode to observe state changes)",
      defaultValue: false
    },
    intervalSeconds: {
      type: "number",
      displayName: "Interval (seconds)",
      description: "Interval in seconds"
    }
  }
};
function registerTimer(loader, customMeta) {
  if (loader) {
    loader.registerComponent(Timer, customMeta != null ? customMeta : timerMeta);
  } else {
    registerComponent2(Timer, customMeta != null ? customMeta : timerMeta);
  }
}
var Video = import_react.default.forwardRef(function(props, ref) {
  return import_react.default.createElement("video", Object.assign({
    ref
  }, props));
});
var videoMeta = {
  name: "hostless-html-video",
  importName: "Video",
  displayName: "HTML Video",
  importPath: "@plasmicpkgs/plasmic-basic-components",
  props: {
    src: {
      type: "string",
      defaultValue: "https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.webm",
      displayName: "Source URL",
      description: "URL to a video file."
    },
    autoPlay: {
      type: "boolean",
      displayName: "Auto Play",
      description: "Whether the video show automatically start playing when the player loads. Chrome and other browsers require 'muted' to also be set for 'autoplay' to work.",
      helpText: "Requires 'Muted' to also be set for 'Auto Play' to work."
    },
    controls: {
      type: "boolean",
      displayName: "Show Controls",
      description: "Whether the video player controls should be displayed",
      defaultValue: true
    },
    playsInline: {
      type: "boolean",
      displayName: "Plays inline",
      description: "Usually on mobile, when tilted landscape, videos can play fullscreen. Turn this on to prevent that."
    },
    loop: {
      type: "boolean",
      displayName: "Loop",
      description: "Whether the video should be played again after it finishes"
    },
    muted: {
      type: "boolean",
      displayName: "Muted",
      description: "Whether audio should be muted"
    },
    poster: {
      type: "imageUrl",
      displayName: "Poster (placeholder) image",
      description: "Image to show while video is downloading"
    },
    preload: {
      type: "choice",
      options: ["none", "metadata", "auto"],
      displayName: "Preload",
      description: "Whether to preload nothing, metadata only, or the full video"
    }
  },
  defaultStyles: {
    height: "hug",
    width: "640px",
    maxWidth: "100%"
  }
};
function registerVideo(loader, customVideoMeta) {
  if (loader) {
    loader.registerComponent(Video, customVideoMeta != null ? customVideoMeta : videoMeta);
  } else {
    registerComponent2(Video, customVideoMeta != null ? customVideoMeta : videoMeta);
  }
}
export {
  ConditionGuard,
  DataProvider2 as DataProvider,
  DynamicElement,
  DynamicImage,
  DynamicRepeater,
  DynamicText,
  Embed,
  Iframe,
  LoadingBoundary,
  Repeater,
  ScrollRevealer,
  SideEffect,
  Timer,
  Video,
  applySelector2 as applySelector,
  conditionGuardMeta,
  dataProviderMeta,
  dynamicElementMeta,
  dynamicImageMeta,
  dynamicRepeaterMeta,
  dynamicRepeaterProps,
  dynamicTextMeta,
  embedMeta,
  iframeMeta,
  loadingBoundaryMeta,
  registerConditionGuard,
  registerDataProvider,
  registerDynamicElement,
  registerDynamicImage,
  registerDynamicRepeater,
  registerDynamicText,
  registerEmbed,
  registerIframe,
  registerLoadingBoundary,
  registerRepeater,
  registerScrollRevealer,
  registerSideEffect,
  registerTimer,
  registerVideo,
  repeaterMeta,
  scrollRevealerMeta,
  sideEffectMeta,
  timerMeta,
  useDataEnv2 as useDataEnv,
  useDirectionalIntersection,
  useInterval,
  useSelector2 as useSelector,
  useSelectors2 as useSelectors,
  videoMeta
};
//# sourceMappingURL=@plasmicpkgs_plasmic-basic-components.js.map
