{"version":3,"file":"luxon.js","sources":["../../src/errors.js","../../src/zone.js","../../src/zones/systemZone.js","../../src/impl/util.js","../../src/zones/IANAZone.js","../../src/impl/english.js","../../src/zones/fixedOffsetZone.js","../../src/zones/invalidZone.js","../../src/impl/zoneUtil.js","../../src/settings.js","../../src/impl/regexParser.js","../../src/impl/invalid.js","../../src/impl/conversions.js","../../src/datetime.js","../../src/luxon.js"],"sourcesContent":["// these aren't really private, but nor are they really useful to document\n\n/**\n * @private\n */\nclass LuxonError extends Error {}\n\n/**\n * @private\n */\nexport class InvalidDateTimeError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid DateTime: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nexport class InvalidIntervalError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Interval: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nexport class InvalidDurationError extends LuxonError {\n  constructor(reason) {\n    super(`Invalid Duration: ${reason.toMessage()}`);\n  }\n}\n\n/**\n * @private\n */\nexport class ConflictingSpecificationError extends LuxonError {}\n\n/**\n * @private\n */\nexport class InvalidUnitError extends LuxonError {\n  constructor(unit) {\n    super(`Invalid unit ${unit}`);\n  }\n}\n\n/**\n * @private\n */\nexport class InvalidArgumentError extends LuxonError {}\n\n/**\n * @private\n */\nexport class ZoneIsAbstractError extends LuxonError {\n  constructor() {\n    super(\"Zone is an abstract class\");\n  }\n}\n","import { ZoneIsAbstractError } from \"./errors.js\";\n\n/**\n * @interface\n */\nexport default class Zone {\n  /**\n   * The type of zone\n   * @abstract\n   * @type {string}\n   */\n  get type() {\n    throw new ZoneIsAbstractError();\n  }\n\n  /**\n   * The name of this zone.\n   * @abstract\n   * @type {string}\n   */\n  get name() {\n    throw new ZoneIsAbstractError();\n  }\n\n  /**\n   * Returns whether the offset is known to be fixed for the whole year.\n   * @abstract\n   * @type {boolean}\n   */\n  get isUniversal() {\n    throw new ZoneIsAbstractError();\n  }\n\n  /**\n   * Return the offset in minutes for this zone at the specified timestamp.\n   * @abstract\n   * @param {number} ts - Epoch milliseconds for which to compute the offset\n   * @return {number}\n   */\n  offset(ts) {\n    throw new ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is equal to another zone\n   * @abstract\n   * @param {Zone} otherZone - the zone to compare\n   * @return {boolean}\n   */\n  equals(otherZone) {\n    throw new ZoneIsAbstractError();\n  }\n\n  /**\n   * Return whether this Zone is valid.\n   * @abstract\n   * @type {boolean}\n   */\n  get isValid() {\n    throw new ZoneIsAbstractError();\n  }\n}\n","import Zone from \"../zone.js\";\n\nlet singleton = null;\n\n/**\n * Represents the local zone for this JavaScript environment.\n * @implements {Zone}\n */\nexport default class SystemZone extends Zone {\n  /**\n   * Get a singleton instance of the local zone\n   * @return {SystemZone}\n   */\n  static get instance() {\n    if (singleton === null) {\n      singleton = new SystemZone();\n    }\n    return singleton;\n  }\n  1;\n\n  /** @override **/\n  get type() {\n    return \"system\";\n  }\n\n  /** @override **/\n  get name() {\n    return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offset(ts) {\n    return -new Date(ts).getTimezoneOffset();\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"system\";\n  }\n\n  /** @override **/\n  get isValid() {\n    return true;\n  }\n}\n","/*\n  This is just a junk drawer, containing anything used across multiple classes.\n  Because Luxon is small(ish), this should stay small and we won't worry about splitting\n  it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.\n*/\n\nimport { InvalidArgumentError } from \"../errors.js\";\nimport Settings from \"../settings.js\";\n\n/**\n * @private\n */\n\n// TYPES\n\nexport function isUndefined(o) {\n  return typeof o === \"undefined\";\n}\n\nexport function isNumber(o) {\n  return typeof o === \"number\";\n}\n\nexport function isInteger(o) {\n  return typeof o === \"number\" && o % 1 === 0;\n}\n\nexport function isString(o) {\n  return typeof o === \"string\";\n}\n\nexport function isDate(o) {\n  return Object.prototype.toString.call(o) === \"[object Date]\";\n}\n\n// CAPABILITIES\n\nexport function hasRelative() {\n  try {\n    return typeof Intl !== \"undefined\" && !!Intl.RelativeTimeFormat;\n  } catch (e) {\n    return false;\n  }\n}\n\n// OBJECTS AND ARRAYS\n\nexport function maybeArray(thing) {\n  return Array.isArray(thing) ? thing : [thing];\n}\n\nexport function bestBy(arr, by, compare) {\n  if (arr.length === 0) {\n    return undefined;\n  }\n  return arr.reduce((best, next) => {\n    const pair = [by(next), next];\n    if (!best) {\n      return pair;\n    } else if (compare(best[0], pair[0]) === best[0]) {\n      return best;\n    } else {\n      return pair;\n    }\n  }, null)[1];\n}\n\nexport function pick(obj, keys) {\n  return keys.reduce((a, k) => {\n    a[k] = obj[k];\n    return a;\n  }, {});\n}\n\nexport function hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n// NUMBERS AND STRINGS\n\nexport function integerBetween(thing, bottom, top) {\n  return isInteger(thing) && thing >= bottom && thing <= top;\n}\n\n// x % n but takes the sign of n instead of x\nexport function floorMod(x, n) {\n  return x - n * Math.floor(x / n);\n}\n\nexport function padStart(input, n = 2) {\n  const isNeg = input < 0;\n  let padded;\n  if (isNeg) {\n    padded = \"-\" + (\"\" + -input).padStart(n, \"0\");\n  } else {\n    padded = (\"\" + input).padStart(n, \"0\");\n  }\n  return padded;\n}\n\nexport function parseInteger(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseInt(string, 10);\n  }\n}\n\nexport function parseFloating(string) {\n  if (isUndefined(string) || string === null || string === \"\") {\n    return undefined;\n  } else {\n    return parseFloat(string);\n  }\n}\n\nexport function parseMillis(fraction) {\n  // Return undefined (instead of 0) in these cases, where fraction is not set\n  if (isUndefined(fraction) || fraction === null || fraction === \"\") {\n    return undefined;\n  } else {\n    const f = parseFloat(\"0.\" + fraction) * 1000;\n    return Math.floor(f);\n  }\n}\n\nexport function roundTo(number, digits, towardZero = false) {\n  const factor = 10 ** digits,\n    rounder = towardZero ? Math.trunc : Math.round;\n  return rounder(number * factor) / factor;\n}\n\n// DATE BASICS\n\nexport function isLeapYear(year) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\nexport function daysInYear(year) {\n  return isLeapYear(year) ? 366 : 365;\n}\n\nexport function daysInMonth(year, month) {\n  const modMonth = floorMod(month - 1, 12) + 1,\n    modYear = year + (month - modMonth) / 12;\n\n  if (modMonth === 2) {\n    return isLeapYear(modYear) ? 29 : 28;\n  } else {\n    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];\n  }\n}\n\n// convert a calendar object to a local timestamp (epoch, but with the offset baked in)\nexport function objToLocalTS(obj) {\n  let d = Date.UTC(\n    obj.year,\n    obj.month - 1,\n    obj.day,\n    obj.hour,\n    obj.minute,\n    obj.second,\n    obj.millisecond\n  );\n\n  // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that\n  if (obj.year < 100 && obj.year >= 0) {\n    d = new Date(d);\n    // set the month and day again, this is necessary because year 2000 is a leap year, but year 100 is not\n    // so if obj.year is in 99, but obj.day makes it roll over into year 100,\n    // the calculations done by Date.UTC are using year 2000 - which is incorrect\n    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);\n  }\n  return +d;\n}\n\nexport function weeksInWeekYear(weekYear) {\n  const p1 =\n      (weekYear +\n        Math.floor(weekYear / 4) -\n        Math.floor(weekYear / 100) +\n        Math.floor(weekYear / 400)) %\n      7,\n    last = weekYear - 1,\n    p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;\n  return p1 === 4 || p2 === 3 ? 53 : 52;\n}\n\nexport function untruncateYear(year) {\n  if (year > 99) {\n    return year;\n  } else return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;\n}\n\n// PARSING\n\nexport function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {\n  const date = new Date(ts),\n    intlOpts = {\n      hourCycle: \"h23\",\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n    };\n\n  if (timeZone) {\n    intlOpts.timeZone = timeZone;\n  }\n\n  const modified = { timeZoneName: offsetFormat, ...intlOpts };\n\n  const parsed = new Intl.DateTimeFormat(locale, modified)\n    .formatToParts(date)\n    .find((m) => m.type.toLowerCase() === \"timezonename\");\n  return parsed ? parsed.value : null;\n}\n\n// signedOffset('-5', '30') -> -330\nexport function signedOffset(offHourStr, offMinuteStr) {\n  let offHour = parseInt(offHourStr, 10);\n\n  // don't || this because we want to preserve -0\n  if (Number.isNaN(offHour)) {\n    offHour = 0;\n  }\n\n  const offMin = parseInt(offMinuteStr, 10) || 0,\n    offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;\n  return offHour * 60 + offMinSigned;\n}\n\n// COERCION\n\nexport function asNumber(value) {\n  const numericValue = Number(value);\n  if (typeof value === \"boolean\" || value === \"\" || Number.isNaN(numericValue))\n    throw new InvalidArgumentError(`Invalid unit value ${value}`);\n  return numericValue;\n}\n\nexport function normalizeObject(obj, normalizer) {\n  const normalized = {};\n  for (const u in obj) {\n    if (hasOwnProperty(obj, u)) {\n      const v = obj[u];\n      if (v === undefined || v === null) continue;\n      normalized[normalizer(u)] = asNumber(v);\n    }\n  }\n  return normalized;\n}\n\nexport function formatOffset(offset, format) {\n  const hours = Math.trunc(Math.abs(offset / 60)),\n    minutes = Math.trunc(Math.abs(offset % 60)),\n    sign = offset >= 0 ? \"+\" : \"-\";\n\n  switch (format) {\n    case \"short\":\n      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;\n    case \"narrow\":\n      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : \"\"}`;\n    case \"techie\":\n      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;\n    default:\n      throw new RangeError(`Value format ${format} is out of range for property format`);\n  }\n}\n\nexport function timeObject(obj) {\n  return pick(obj, [\"hour\", \"minute\", \"second\", \"millisecond\"]);\n}\n","import { isUndefined, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n      era: \"short\",\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  era: 3,\n  hour: 4,\n  minute: 5,\n  second: 6,\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+) (AD|BC),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date);\n  const filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i];\n    const pos = typeToPos[type];\n\n    if (type === \"era\") {\n      filled[pos] = value;\n    } else if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return this.isValidZone(s);\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    if (!zone) {\n      return false;\n    }\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts);\n\n    if (isNaN(date)) return NaN;\n\n    const dtf = makeDTF(this.name);\n    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts\n      ? partsOffset(dtf, date)\n      : hackyOffset(dtf, date);\n\n    if (adOrBc === \"BC\") {\n      year = -Math.abs(year) + 1;\n    }\n\n    // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    const adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0,\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n","import * as Formats from \"./formats.js\";\nimport { pick } from \"./util.js\";\n\nfunction stringify(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\n\n/**\n * @private\n */\n\nexport const monthsLong = [\n  \"January\",\n  \"February\",\n  \"March\",\n  \"April\",\n  \"May\",\n  \"June\",\n  \"July\",\n  \"August\",\n  \"September\",\n  \"October\",\n  \"November\",\n  \"December\",\n];\n\nexport const monthsShort = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\nexport const monthsNarrow = [\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"];\n\nexport function months(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...monthsNarrow];\n    case \"short\":\n      return [...monthsShort];\n    case \"long\":\n      return [...monthsLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"];\n    case \"2-digit\":\n      return [\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    default:\n      return null;\n  }\n}\n\nexport const weekdaysLong = [\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\",\n  \"Sunday\",\n];\n\nexport const weekdaysShort = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n\nexport const weekdaysNarrow = [\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\"];\n\nexport function weekdays(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...weekdaysNarrow];\n    case \"short\":\n      return [...weekdaysShort];\n    case \"long\":\n      return [...weekdaysLong];\n    case \"numeric\":\n      return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\"];\n    default:\n      return null;\n  }\n}\n\nexport const meridiems = [\"AM\", \"PM\"];\n\nexport const erasLong = [\"Before Christ\", \"Anno Domini\"];\n\nexport const erasShort = [\"BC\", \"AD\"];\n\nexport const erasNarrow = [\"B\", \"A\"];\n\nexport function eras(length) {\n  switch (length) {\n    case \"narrow\":\n      return [...erasNarrow];\n    case \"short\":\n      return [...erasShort];\n    case \"long\":\n      return [...erasLong];\n    default:\n      return null;\n  }\n}\n\nexport function meridiemForDateTime(dt) {\n  return meridiems[dt.hour < 12 ? 0 : 1];\n}\n\nexport function weekdayForDateTime(dt, length) {\n  return weekdays(length)[dt.weekday - 1];\n}\n\nexport function monthForDateTime(dt, length) {\n  return months(length)[dt.month - 1];\n}\n\nexport function eraForDateTime(dt, length) {\n  return eras(length)[dt.year < 0 ? 0 : 1];\n}\n\nexport function formatRelativeTime(unit, count, numeric = \"always\", narrow = false) {\n  const units = {\n    years: [\"year\", \"yr.\"],\n    quarters: [\"quarter\", \"qtr.\"],\n    months: [\"month\", \"mo.\"],\n    weeks: [\"week\", \"wk.\"],\n    days: [\"day\", \"day\", \"days\"],\n    hours: [\"hour\", \"hr.\"],\n    minutes: [\"minute\", \"min.\"],\n    seconds: [\"second\", \"sec.\"],\n  };\n\n  const lastable = [\"hours\", \"minutes\", \"seconds\"].indexOf(unit) === -1;\n\n  if (numeric === \"auto\" && lastable) {\n    const isDay = unit === \"days\";\n    switch (count) {\n      case 1:\n        return isDay ? \"tomorrow\" : `next ${units[unit][0]}`;\n      case -1:\n        return isDay ? \"yesterday\" : `last ${units[unit][0]}`;\n      case 0:\n        return isDay ? \"today\" : `this ${units[unit][0]}`;\n      default: // fall through\n    }\n  }\n\n  const isInPast = Object.is(count, -0) || count < 0,\n    fmtValue = Math.abs(count),\n    singular = fmtValue === 1,\n    lilUnits = units[unit],\n    fmtUnit = narrow\n      ? singular\n        ? lilUnits[1]\n        : lilUnits[2] || lilUnits[1]\n      : singular\n      ? units[unit][0]\n      : unit;\n  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;\n}\n\nexport function formatString(knownFormat) {\n  // these all have the offsets removed because we don't have access to them\n  // without all the intl stuff this is backfilling\n  const filtered = pick(knownFormat, [\n      \"weekday\",\n      \"era\",\n      \"year\",\n      \"month\",\n      \"day\",\n      \"hour\",\n      \"minute\",\n      \"second\",\n      \"timeZoneName\",\n      \"hourCycle\",\n    ]),\n    key = stringify(filtered),\n    dateTimeHuge = \"EEEE, LLLL d, yyyy, h:mm a\";\n  switch (key) {\n    case stringify(Formats.DATE_SHORT):\n      return \"M/d/yyyy\";\n    case stringify(Formats.DATE_MED):\n      return \"LLL d, yyyy\";\n    case stringify(Formats.DATE_MED_WITH_WEEKDAY):\n      return \"EEE, LLL d, yyyy\";\n    case stringify(Formats.DATE_FULL):\n      return \"LLLL d, yyyy\";\n    case stringify(Formats.DATE_HUGE):\n      return \"EEEE, LLLL d, yyyy\";\n    case stringify(Formats.TIME_SIMPLE):\n      return \"h:mm a\";\n    case stringify(Formats.TIME_WITH_SECONDS):\n      return \"h:mm:ss a\";\n    case stringify(Formats.TIME_WITH_SHORT_OFFSET):\n      return \"h:mm a\";\n    case stringify(Formats.TIME_WITH_LONG_OFFSET):\n      return \"h:mm a\";\n    case stringify(Formats.TIME_24_SIMPLE):\n      return \"HH:mm\";\n    case stringify(Formats.TIME_24_WITH_SECONDS):\n      return \"HH:mm:ss\";\n    case stringify(Formats.TIME_24_WITH_SHORT_OFFSET):\n      return \"HH:mm\";\n    case stringify(Formats.TIME_24_WITH_LONG_OFFSET):\n      return \"HH:mm\";\n    case stringify(Formats.DATETIME_SHORT):\n      return \"M/d/yyyy, h:mm a\";\n    case stringify(Formats.DATETIME_MED):\n      return \"LLL d, yyyy, h:mm a\";\n    case stringify(Formats.DATETIME_FULL):\n      return \"LLLL d, yyyy, h:mm a\";\n    case stringify(Formats.DATETIME_HUGE):\n      return dateTimeHuge;\n    case stringify(Formats.DATETIME_SHORT_WITH_SECONDS):\n      return \"M/d/yyyy, h:mm:ss a\";\n    case stringify(Formats.DATETIME_MED_WITH_SECONDS):\n      return \"LLL d, yyyy, h:mm:ss a\";\n    case stringify(Formats.DATETIME_MED_WITH_WEEKDAY):\n      return \"EEE, d LLL yyyy, h:mm a\";\n    case stringify(Formats.DATETIME_FULL_WITH_SECONDS):\n      return \"LLLL d, yyyy, h:mm:ss a\";\n    case stringify(Formats.DATETIME_HUGE_WITH_SECONDS):\n      return \"EEEE, LLLL d, yyyy, h:mm:ss a\";\n    default:\n      return dateTimeHuge;\n  }\n}\n","import { formatOffset, signedOffset } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nlet singleton = null;\n\n/**\n * A zone with a fixed offset (meaning no DST)\n * @implements {Zone}\n */\nexport default class FixedOffsetZone extends Zone {\n  /**\n   * Get a singleton instance of UTC\n   * @return {FixedOffsetZone}\n   */\n  static get utcInstance() {\n    if (singleton === null) {\n      singleton = new FixedOffsetZone(0);\n    }\n    return singleton;\n  }\n\n  /**\n   * Get an instance with a specified offset\n   * @param {number} offset - The offset in minutes\n   * @return {FixedOffsetZone}\n   */\n  static instance(offset) {\n    return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);\n  }\n\n  /**\n   * Get an instance of FixedOffsetZone from a UTC offset string, like \"UTC+6\"\n   * @param {string} s - The offset string to parse\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+6\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC+06\")\n   * @example FixedOffsetZone.parseSpecifier(\"UTC-6:00\")\n   * @return {FixedOffsetZone}\n   */\n  static parseSpecifier(s) {\n    if (s) {\n      const r = s.match(/^utc(?:([+-]\\d{1,2})(?::(\\d{2}))?)?$/i);\n      if (r) {\n        return new FixedOffsetZone(signedOffset(r[1], r[2]));\n      }\n    }\n    return null;\n  }\n\n  constructor(offset) {\n    super();\n    /** @private **/\n    this.fixed = offset;\n  }\n\n  /** @override **/\n  get type() {\n    return \"fixed\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.fixed === 0 ? \"UTC\" : `UTC${formatOffset(this.fixed, \"narrow\")}`;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return true;\n  }\n\n  /** @override **/\n  offset() {\n    return this.fixed;\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"fixed\" && otherZone.fixed === this.fixed;\n  }\n\n  /** @override **/\n  get isValid() {\n    return true;\n  }\n}\n","import Zone from \"../zone.js\";\n\n/**\n * A zone that failed to parse. You should never need to instantiate this.\n * @implements {Zone}\n */\nexport default class InvalidZone extends Zone {\n  constructor(zoneName) {\n    super();\n    /**  @private */\n    this.zoneName = zoneName;\n  }\n\n  /** @override **/\n  get type() {\n    return \"invalid\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get isUniversal() {\n    return false;\n  }\n\n  /** @override **/\n  offset() {\n    return NaN;\n  }\n\n  /** @override **/\n  equals() {\n    return false;\n  }\n\n  /** @override **/\n  get isValid() {\n    return false;\n  }\n}\n","/**\n * @private\n */\n\nimport Zone from \"../zone.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\nimport FixedOffsetZone from \"../zones/fixedOffsetZone.js\";\nimport InvalidZone from \"../zones/invalidZone.js\";\n\nimport { isUndefined, isString, isNumber } from \"./util.js\";\nimport SystemZone from \"../zones/systemZone.js\";\n\nexport function normalizeZone(input, defaultZone) {\n  let offset;\n  if (isUndefined(input) || input === null) {\n    return defaultZone;\n  } else if (input instanceof Zone) {\n    return input;\n  } else if (isString(input)) {\n    const lowered = input.toLowerCase();\n    if (lowered === \"default\") return defaultZone;\n    else if (lowered === \"local\" || lowered === \"system\") return SystemZone.instance;\n    else if (lowered === \"utc\" || lowered === \"gmt\") return FixedOffsetZone.utcInstance;\n    else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);\n  } else if (isNumber(input)) {\n    return FixedOffsetZone.instance(input);\n  } else if (typeof input === \"object\" && \"offset\" in input && typeof input.offset === \"function\") {\n    // This is dumb, but the instanceof check above doesn't seem to really work\n    // so we're duck checking it\n    return input;\n  } else {\n    return new InvalidZone(input);\n  }\n}\n","import SystemZone from \"./zones/systemZone.js\";\nimport IANAZone from \"./zones/IANAZone.js\";\nimport Locale from \"./impl/locale.js\";\n\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\n\nlet now = () => Date.now(),\n  defaultZone = \"system\",\n  defaultLocale = null,\n  defaultNumberingSystem = null,\n  defaultOutputCalendar = null,\n  twoDigitCutoffYear = 60,\n  throwOnInvalid;\n\n/**\n * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.\n */\nexport default class Settings {\n  /**\n   * Get the callback for returning the current timestamp.\n   * @type {function}\n   */\n  static get now() {\n    return now;\n  }\n\n  /**\n   * Set the callback for returning the current timestamp.\n   * The function should return a number, which will be interpreted as an Epoch millisecond count\n   * @type {function}\n   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future\n   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time\n   */\n  static set now(n) {\n    now = n;\n  }\n\n  /**\n   * Set the default time zone to create DateTimes in. Does not affect existing instances.\n   * Use the value \"system\" to reset this value to the system's time zone.\n   * @type {string}\n   */\n  static set defaultZone(zone) {\n    defaultZone = zone;\n  }\n\n  /**\n   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.\n   * The default value is the system's time zone (the one set on the machine that runs this code).\n   * @type {Zone}\n   */\n  static get defaultZone() {\n    return normalizeZone(defaultZone, SystemZone.instance);\n  }\n\n  /**\n   * Get the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultLocale() {\n    return defaultLocale;\n  }\n\n  /**\n   * Set the default locale to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultLocale(locale) {\n    defaultLocale = locale;\n  }\n\n  /**\n   * Get the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultNumberingSystem() {\n    return defaultNumberingSystem;\n  }\n\n  /**\n   * Set the default numbering system to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultNumberingSystem(numberingSystem) {\n    defaultNumberingSystem = numberingSystem;\n  }\n\n  /**\n   * Get the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static get defaultOutputCalendar() {\n    return defaultOutputCalendar;\n  }\n\n  /**\n   * Set the default output calendar to create DateTimes with. Does not affect existing instances.\n   * @type {string}\n   */\n  static set defaultOutputCalendar(outputCalendar) {\n    defaultOutputCalendar = outputCalendar;\n  }\n\n  /**\n   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.\n   * @type {number}\n   */\n  static get twoDigitCutoffYear() {\n    return twoDigitCutoffYear;\n  }\n\n  /**\n   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.\n   * @type {number}\n   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century\n   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050\n   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50\n   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50\n   */\n  static set twoDigitCutoffYear(cutoffYear) {\n    twoDigitCutoffYear = cutoffYear % 100;\n  }\n\n  /**\n   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static get throwOnInvalid() {\n    return throwOnInvalid;\n  }\n\n  /**\n   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals\n   * @type {boolean}\n   */\n  static set throwOnInvalid(t) {\n    throwOnInvalid = t;\n  }\n\n  /**\n   * Reset Luxon's global caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCaches() {\n    Locale.resetCache();\n    IANAZone.resetCache();\n  }\n}\n","import {\n  untruncateYear,\n  signedOffset,\n  parseInteger,\n  parseMillis,\n  isUndefined,\n  parseFloating,\n} from \"./util.js\";\nimport * as English from \"./english.js\";\nimport FixedOffsetZone from \"../zones/fixedOffsetZone.js\";\nimport IANAZone from \"../zones/IANAZone.js\";\n\n/*\n * This file handles parsing for well-specified formats. Here's how it works:\n * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.\n * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object\n * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.\n * Extractors can take a \"cursor\" representing the offset in the match to look at. This makes it easy to combine extractors.\n * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.\n * Some extractions are super dumb and simpleParse and fromStrings help DRY them.\n */\n\nconst ianaRegex = /[A-Za-z_+-]{1,256}(?::?\\/[A-Za-z0-9_+-]{1,256}(?:\\/[A-Za-z0-9_+-]{1,256})?)?/;\n\nfunction combineRegexes(...regexes) {\n  const full = regexes.reduce((f, r) => f + r.source, \"\");\n  return RegExp(`^${full}$`);\n}\n\nfunction combineExtractors(...extractors) {\n  return (m) =>\n    extractors\n      .reduce(\n        ([mergedVals, mergedZone, cursor], ex) => {\n          const [val, zone, next] = ex(m, cursor);\n          return [{ ...mergedVals, ...val }, zone || mergedZone, next];\n        },\n        [{}, null, 1]\n      )\n      .slice(0, 2);\n}\n\nfunction parse(s, ...patterns) {\n  if (s == null) {\n    return [null, null];\n  }\n\n  for (const [regex, extractor] of patterns) {\n    const m = regex.exec(s);\n    if (m) {\n      return extractor(m);\n    }\n  }\n  return [null, null];\n}\n\n// ISO and SQL parsing\nconst offsetRegex = /(?:(Z)|([+-]\\d\\d)(?::?(\\d\\d))?)/;\nconst isoExtendedZone = `(?:${offsetRegex.source}?(?:\\\\[(${ianaRegex.source})\\\\])?)?`;\nconst isoTimeBaseRegex = /(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:[.,](\\d{1,30}))?)?)?/;\nconst isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);\nconst isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);\nconst isoYmdRegex = /([+-]\\d{6}|\\d{4})(?:-?(\\d\\d)(?:-?(\\d\\d))?)?/;\nconst sqlYmdRegex = /(\\d{4})-(\\d\\d)-(\\d\\d)/; // dumbed-down version of the ISO one\nconst sqlTimeRegex = RegExp(\n  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`\n);\nconst sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);\n\nfunction int(match, pos, fallback) {\n  const m = match[pos];\n  return isUndefined(m) ? fallback : parseInteger(m);\n}\n\nfunction extractISOYmd(match, cursor) {\n  const item = {\n    year: int(match, cursor),\n    month: int(match, cursor + 1, 1),\n    day: int(match, cursor + 2, 1),\n  };\n\n  return [item, null, cursor + 3];\n}\n\nfunction extractISOTime(match, cursor) {\n  const item = {\n    hours: int(match, cursor, 0),\n    minutes: int(match, cursor + 1, 0),\n    seconds: int(match, cursor + 2, 0),\n    milliseconds: parseMillis(match[cursor + 3]),\n  };\n\n  return [item, null, cursor + 4];\n}\n\nfunction extractISOOffset(match, cursor) {\n  const local = !match[cursor] && !match[cursor + 1],\n    fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),\n    zone = local ? null : FixedOffsetZone.instance(fullOffset);\n  return [{}, zone, cursor + 3];\n}\n\nfunction extractIANAZone(match, cursor) {\n  const zone = match[cursor] ? IANAZone.create(match[cursor]) : null;\n  return [{}, zone, cursor + 1];\n}\n\n// ISO time parsing\n\nconst isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);\n\n// ISO duration parsing\n\nconst isoDuration =\n  /^-?P(?:(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)Y)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)W)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)D)?(?:T(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)H)?(?:(-?\\d{1,20}(?:\\.\\d{1,20})?)M)?(?:(-?\\d{1,20})(?:[.,](-?\\d{1,20}))?S)?)?)$/;\n\nfunction extractISODuration(match) {\n  const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] =\n    match;\n\n  const hasNegativePrefix = s[0] === \"-\";\n  const negativeSeconds = secondStr && secondStr[0] === \"-\";\n\n  const maybeNegate = (num, force = false) =>\n    num !== undefined && (force || (num && hasNegativePrefix)) ? -num : num;\n\n  return [\n    {\n      years: maybeNegate(parseFloating(yearStr)),\n      months: maybeNegate(parseFloating(monthStr)),\n      weeks: maybeNegate(parseFloating(weekStr)),\n      days: maybeNegate(parseFloating(dayStr)),\n      hours: maybeNegate(parseFloating(hourStr)),\n      minutes: maybeNegate(parseFloating(minuteStr)),\n      seconds: maybeNegate(parseFloating(secondStr), secondStr === \"-0\"),\n      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds),\n    },\n  ];\n}\n\n// These are a little braindead. EDT *should* tell us that we're in, say, America/New_York\n// and not just that we're in -240 *right now*. But since I don't think these are used that often\n// I'm just going to ignore that\nconst obsOffsets = {\n  GMT: 0,\n  EDT: -4 * 60,\n  EST: -5 * 60,\n  CDT: -5 * 60,\n  CST: -6 * 60,\n  MDT: -6 * 60,\n  MST: -7 * 60,\n  PDT: -7 * 60,\n  PST: -8 * 60,\n};\n\nfunction fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n  const result = {\n    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),\n    month: English.monthsShort.indexOf(monthStr) + 1,\n    day: parseInteger(dayStr),\n    hour: parseInteger(hourStr),\n    minute: parseInteger(minuteStr),\n  };\n\n  if (secondStr) result.second = parseInteger(secondStr);\n  if (weekdayStr) {\n    result.weekday =\n      weekdayStr.length > 3\n        ? English.weekdaysLong.indexOf(weekdayStr) + 1\n        : English.weekdaysShort.indexOf(weekdayStr) + 1;\n  }\n\n  return result;\n}\n\n// RFC 2822/5322\nconst rfc2822 =\n  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\\d\\d)(\\d\\d)))$/;\n\nfunction extractRFC2822(match) {\n  const [\n      ,\n      weekdayStr,\n      dayStr,\n      monthStr,\n      yearStr,\n      hourStr,\n      minuteStr,\n      secondStr,\n      obsOffset,\n      milOffset,\n      offHourStr,\n      offMinuteStr,\n    ] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n\n  let offset;\n  if (obsOffset) {\n    offset = obsOffsets[obsOffset];\n  } else if (milOffset) {\n    offset = 0;\n  } else {\n    offset = signedOffset(offHourStr, offMinuteStr);\n  }\n\n  return [result, new FixedOffsetZone(offset)];\n}\n\nfunction preprocessRFC2822(s) {\n  // Remove comments and folding whitespace and replace multiple-spaces with a single space\n  return s\n    .replace(/\\([^()]*\\)|[\\n\\t]/g, \" \")\n    .replace(/(\\s\\s+)/g, \" \")\n    .trim();\n}\n\n// http date\n\nconst rfc1123 =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\\d\\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  rfc850 =\n    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\\d\\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) GMT$/,\n  ascii =\n    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \\d|\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) (\\d{4})$/;\n\nfunction extractRFC1123Or850(match) {\n  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, FixedOffsetZone.utcInstance];\n}\n\nfunction extractASCII(match) {\n  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match,\n    result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);\n  return [result, FixedOffsetZone.utcInstance];\n}\n\nconst isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);\nconst isoTimeCombinedRegex = combineRegexes(isoTimeRegex);\n\nconst extractISOYmdTimeAndOffset = combineExtractors(\n  extractISOYmd,\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\nconst extractISOTimeAndOffset = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\n/*\n * @private\n */\n\nexport function parseISODate(s) {\n  return parse(\n    s,\n    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [isoTimeCombinedRegex, extractISOTimeAndOffset]\n  );\n}\n\nexport function parseRFC2822Date(s) {\n  return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);\n}\n\nexport function parseHTTPDate(s) {\n  return parse(\n    s,\n    [rfc1123, extractRFC1123Or850],\n    [rfc850, extractRFC1123Or850],\n    [ascii, extractASCII]\n  );\n}\n\nexport function parseISODuration(s) {\n  return parse(s, [isoDuration, extractISODuration]);\n}\n\nconst extractISOTimeOnly = combineExtractors(extractISOTime);\n\nexport function parseISOTimeOnly(s) {\n  return parse(s, [isoTimeOnly, extractISOTimeOnly]);\n}\n\nconst sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);\nconst sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);\n\nconst extractISOTimeOffsetAndIANAZone = combineExtractors(\n  extractISOTime,\n  extractISOOffset,\n  extractIANAZone\n);\n\nexport function parseSQL(s) {\n  return parse(\n    s,\n    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],\n    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]\n  );\n}\n","export default class Invalid {\n  constructor(reason, explanation) {\n    this.reason = reason;\n    this.explanation = explanation;\n  }\n\n  toMessage() {\n    if (this.explanation) {\n      return `${this.reason}: ${this.explanation}`;\n    } else {\n      return this.reason;\n    }\n  }\n}\n","import {\n  integerBetween,\n  isLeapYear,\n  timeObject,\n  daysInYear,\n  daysInMonth,\n  weeksInWeekYear,\n  isInteger,\n} from \"./util.js\";\nimport Invalid from \"./invalid.js\";\n\nconst nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];\n\nfunction unitOutOfRange(unit, value) {\n  return new Invalid(\n    \"unit out of range\",\n    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`\n  );\n}\n\nfunction dayOfWeek(year, month, day) {\n  const d = new Date(Date.UTC(year, month - 1, day));\n\n  if (year < 100 && year >= 0) {\n    d.setUTCFullYear(d.getUTCFullYear() - 1900);\n  }\n\n  const js = d.getUTCDay();\n\n  return js === 0 ? 7 : js;\n}\n\nfunction computeOrdinal(year, month, day) {\n  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];\n}\n\nfunction uncomputeOrdinal(year, ordinal) {\n  const table = isLeapYear(year) ? leapLadder : nonLeapLadder,\n    month0 = table.findIndex((i) => i < ordinal),\n    day = ordinal - table[month0];\n  return { month: month0 + 1, day };\n}\n\n/**\n * @private\n */\n\nexport function gregorianToWeek(gregObj) {\n  const { year, month, day } = gregObj,\n    ordinal = computeOrdinal(year, month, day),\n    weekday = dayOfWeek(year, month, day);\n\n  let weekNumber = Math.floor((ordinal - weekday + 10) / 7),\n    weekYear;\n\n  if (weekNumber < 1) {\n    weekYear = year - 1;\n    weekNumber = weeksInWeekYear(weekYear);\n  } else if (weekNumber > weeksInWeekYear(year)) {\n    weekYear = year + 1;\n    weekNumber = 1;\n  } else {\n    weekYear = year;\n  }\n\n  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };\n}\n\nexport function weekToGregorian(weekData) {\n  const { weekYear, weekNumber, weekday } = weekData,\n    weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),\n    yearInDays = daysInYear(weekYear);\n\n  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,\n    year;\n\n  if (ordinal < 1) {\n    year = weekYear - 1;\n    ordinal += daysInYear(year);\n  } else if (ordinal > yearInDays) {\n    year = weekYear + 1;\n    ordinal -= daysInYear(weekYear);\n  } else {\n    year = weekYear;\n  }\n\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...timeObject(weekData) };\n}\n\nexport function gregorianToOrdinal(gregData) {\n  const { year, month, day } = gregData;\n  const ordinal = computeOrdinal(year, month, day);\n  return { year, ordinal, ...timeObject(gregData) };\n}\n\nexport function ordinalToGregorian(ordinalData) {\n  const { year, ordinal } = ordinalData;\n  const { month, day } = uncomputeOrdinal(year, ordinal);\n  return { year, month, day, ...timeObject(ordinalData) };\n}\n\nexport function hasInvalidWeekData(obj) {\n  const validYear = isInteger(obj.weekYear),\n    validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),\n    validWeekday = integerBetween(obj.weekday, 1, 7);\n\n  if (!validYear) {\n    return unitOutOfRange(\"weekYear\", obj.weekYear);\n  } else if (!validWeek) {\n    return unitOutOfRange(\"week\", obj.week);\n  } else if (!validWeekday) {\n    return unitOutOfRange(\"weekday\", obj.weekday);\n  } else return false;\n}\n\nexport function hasInvalidOrdinalData(obj) {\n  const validYear = isInteger(obj.year),\n    validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validOrdinal) {\n    return unitOutOfRange(\"ordinal\", obj.ordinal);\n  } else return false;\n}\n\nexport function hasInvalidGregorianData(obj) {\n  const validYear = isInteger(obj.year),\n    validMonth = integerBetween(obj.month, 1, 12),\n    validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));\n\n  if (!validYear) {\n    return unitOutOfRange(\"year\", obj.year);\n  } else if (!validMonth) {\n    return unitOutOfRange(\"month\", obj.month);\n  } else if (!validDay) {\n    return unitOutOfRange(\"day\", obj.day);\n  } else return false;\n}\n\nexport function hasInvalidTimeData(obj) {\n  const { hour, minute, second, millisecond } = obj;\n  const validHour =\n      integerBetween(hour, 0, 23) ||\n      (hour === 24 && minute === 0 && second === 0 && millisecond === 0),\n    validMinute = integerBetween(minute, 0, 59),\n    validSecond = integerBetween(second, 0, 59),\n    validMillisecond = integerBetween(millisecond, 0, 999);\n\n  if (!validHour) {\n    return unitOutOfRange(\"hour\", hour);\n  } else if (!validMinute) {\n    return unitOutOfRange(\"minute\", minute);\n  } else if (!validSecond) {\n    return unitOutOfRange(\"second\", second);\n  } else if (!validMillisecond) {\n    return unitOutOfRange(\"millisecond\", millisecond);\n  } else return false;\n}\n","import Settings from \"./settings.js\";\nimport { isUndefined, isDate, isNumber, normalizeObject, objToLocalTS } from \"./impl/util.js\";\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\nimport { parseRFC2822Date, parseISODate, parseHTTPDate, parseSQL } from \"./impl/regexParser.js\";\nimport { hasInvalidGregorianData, hasInvalidTimeData } from \"./impl/conversions.js\";\nimport {\n  InvalidArgumentError,\n  ConflictingSpecificationError,\n  InvalidUnitError,\n  InvalidDateTimeError,\n} from \"./errors.js\";\nimport Invalid from \"./impl/invalid.js\";\nimport FixedOffsetZone from \"./zones/fixedOffsetZone.js\";\n\nconst MAX_DATE = 8.64e15;\n\nfunction unsupportedZone(zone) {\n  return new Invalid(\"unsupported zone\", `the zone \"${zone.name}\" is not supported`);\n}\n\n// clone really means, \"make a new object with these modifications\". all \"setters\" really use this\n// to create a new object while only changing some of the properties\nfunction clone(inst, alts) {\n  const current = {\n    ts: inst.ts,\n    zone: inst.zone,\n    c: inst.c,\n    o: inst.o,\n    loc: inst.loc,\n    invalid: inst.invalid,\n  };\n  return new DateTime({ ...current, ...alts, old: current });\n}\n\n// find the right offset a given local time. The o input is our guess, which determines which\n// offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)\nfunction fixOffset(localTS, o, tz) {\n  // Our UTC time is just a guess because our offset is just a guess\n  let utcGuess = localTS - o * 60 * 1000;\n\n  // Test whether the zone matches the offset for this ts\n  const o2 = tz.offset(utcGuess);\n\n  // If so, offset didn't change and we're done\n  if (o === o2) {\n    return [utcGuess, o];\n  }\n\n  // If not, change the ts by the difference in the offset\n  utcGuess -= (o2 - o) * 60 * 1000;\n\n  // If that gives us the local time we want, we're done\n  const o3 = tz.offset(utcGuess);\n  if (o2 === o3) {\n    return [utcGuess, o2];\n  }\n\n  // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time\n  return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];\n}\n\n// convert an epoch timestamp into a calendar object with the given offset\nfunction tsToObj(ts, offset) {\n  ts += offset * 60 * 1000;\n\n  const d = new Date(ts);\n\n  return {\n    year: d.getUTCFullYear(),\n    month: d.getUTCMonth() + 1,\n    day: d.getUTCDate(),\n    hour: d.getUTCHours(),\n    minute: d.getUTCMinutes(),\n    second: d.getUTCSeconds(),\n    millisecond: d.getUTCMilliseconds(),\n  };\n}\n\n// convert a calendar object to a epoch timestamp\nfunction objToTS(obj, offset, zone) {\n  return fixOffset(objToLocalTS(obj), offset, zone);\n}\n\n// helper useful in turning the results of parsing into real dates\n// by handling the zone options\nfunction parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {\n  const { setZone, zone } = opts;\n  if ((parsed && Object.keys(parsed).length !== 0) || parsedZone) {\n    const interpretationZone = parsedZone || zone,\n      inst = DateTime.fromObject(parsed, {\n        ...opts,\n        zone: interpretationZone,\n        specificOffset,\n      });\n    return setZone ? inst : inst.setZone(zone);\n  } else {\n    return DateTime.invalid(\n      new Invalid(\"unparsable\", `the input \"${text}\" can't be parsed as ${format}`)\n    );\n  }\n}\n\n// defaults for unspecified units in the supported calendars\nconst defaultUnitValues = {\n  month: 1,\n  day: 1,\n  hour: 0,\n  minute: 0,\n  second: 0,\n  millisecond: 0,\n};\n\n// Units in the supported calendars, sorted by bigness\nconst orderedUnits = [\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\", \"millisecond\"];\n\n// standardize case and plurality in units\nfunction normalizeUnit(unit) {\n  const normalized = {\n    year: \"year\",\n    years: \"year\",\n    month: \"month\",\n    months: \"month\",\n    day: \"day\",\n    days: \"day\",\n    hour: \"hour\",\n    hours: \"hour\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    second: \"second\",\n    seconds: \"second\",\n    millisecond: \"millisecond\",\n    milliseconds: \"millisecond\",\n    weekday: \"weekday\",\n    weekdays: \"weekday\",\n    weeknumber: \"weekNumber\",\n    weeksnumber: \"weekNumber\",\n    weeknumbers: \"weekNumber\",\n    weekyear: \"weekYear\",\n    weekyears: \"weekYear\",\n    ordinal: \"ordinal\",\n  }[unit.toLowerCase()];\n\n  if (!normalized) throw new InvalidUnitError(unit);\n\n  return normalized;\n}\n\n/**\n * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.\n *\n * A DateTime comprises of:\n * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.\n * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).\n * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.\n *\n * Here is a brief overview of the most commonly used functionality it provides:\n *\n * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime.local}, {@link DateTime.utc}, and (most flexibly) {@link DateTime.fromObject}. To create one from a standard string format, use {@link DateTime.fromISO}, {@link DateTime.fromHTTP}, and {@link DateTime.fromRFC2822}. To create one from a custom string format, use {@link DateTime.fromFormat}. To create one from a native JS date, use {@link DateTime.fromJSDate}.\n * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},\n * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.\n * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.\n * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.\n * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.\n * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.\n *\n * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.\n */\nexport default class DateTime {\n  /**\n   * @access private\n   */\n  constructor(config) {\n    const zone = config.zone || Settings.defaultZone;\n\n    let invalid =\n      config.invalid ||\n      (Number.isNaN(config.ts) ? new Invalid(\"invalid input\") : null) ||\n      (!zone.isValid ? unsupportedZone(zone) : null);\n    /**\n     * @access private\n     */\n    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;\n\n    let c = null,\n      o = null;\n    if (!invalid) {\n      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);\n\n      if (unchanged) {\n        [c, o] = [config.old.c, config.old.o];\n      } else {\n        const ot = zone.offset(this.ts);\n        c = tsToObj(this.ts, ot);\n        invalid = Number.isNaN(c.year) ? new Invalid(\"invalid input\") : null;\n        c = invalid ? null : c;\n        o = invalid ? null : ot;\n      }\n    }\n\n    /**\n     * @access private\n     */\n    this._zone = zone;\n    /**\n     * @access private\n     */\n    this.invalid = invalid;\n    /**\n     * @access private\n     */\n    this.weekData = null;\n    /**\n     * @access private\n     */\n    this.c = c;\n    /**\n     * @access private\n     */\n    this.o = o;\n    /**\n     * @access private\n     */\n    this.isLuxonDateTime = true;\n  }\n\n  /**\n   * Create a DateTime for the current instant, in the system's time zone.\n   *\n   * Use Settings to override these default values if needed.\n   * @example DateTime.now().toISO() //~> now in the ISO format\n   * @return {DateTime}\n   */\n  static now() {\n    return new DateTime({});\n  }\n\n  /**\n   * Create a DateTime from a JavaScript Date object. Uses the default zone.\n   * @param {Date} date - a JavaScript Date object\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @return {DateTime}\n   */\n  static fromJSDate(date, options = {}) {\n    const ts = isDate(date) ? date.valueOf() : NaN;\n    if (Number.isNaN(ts)) {\n      return DateTime.invalid(\"invalid input\");\n    }\n\n    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    return new DateTime({\n      ts: ts,\n      zone: zoneToUse,\n    });\n  }\n\n  /**\n   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} milliseconds - a number of milliseconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromMillis(milliseconds, options = {}) {\n    if (!isNumber(milliseconds)) {\n      throw new InvalidArgumentError(\n        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`\n      );\n    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {\n      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start\n      return DateTime.invalid(\"Timestamp out of range\");\n    } else {\n      return new DateTime({\n        ts: milliseconds,\n        zone: normalizeZone(options.zone, Settings.defaultZone),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.\n   * @param {number} seconds - a number of seconds since 1970 UTC\n   * @param {Object} options - configuration options for the DateTime\n   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into\n   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance\n   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @return {DateTime}\n   */\n  static fromSeconds(seconds, options = {}) {\n    if (!isNumber(seconds)) {\n      throw new InvalidArgumentError(\"fromSeconds requires a numerical input\");\n    } else {\n      return new DateTime({\n        ts: seconds * 1000,\n        zone: normalizeZone(options.zone, Settings.defaultZone),\n      });\n    }\n  }\n\n  /**\n   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.\n   * @param {Object} obj - the object to create the DateTime from\n   * @param {number} obj.year - a year, such as 1987\n   * @param {number} obj.month - a month, 1-12\n   * @param {number} obj.day - a day of the month, 1-31, depending on the month\n   * @param {number} obj.ordinal - day of the year, 1-365 or 366\n   * @param {number} obj.weekYear - an ISO week year\n   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year\n   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday\n   * @param {number} obj.hour - hour of the day, 0-23\n   * @param {number} obj.minute - minute of the hour, 0-59\n   * @param {number} obj.second - second of the minute, 0-59\n   * @param {number} obj.millisecond - millisecond of the second, 0-999\n   * @param {Object} opts - options for creating this DateTime\n   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'\n   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })\n   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })\n   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'\n   * @return {DateTime}\n   */\n  static fromObject(obj, opts = {}) {\n    obj = obj || {};\n    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);\n    if (!zoneToUse.isValid) {\n      return DateTime.invalid(unsupportedZone(zoneToUse));\n    }\n\n    const tsNow = Settings.now(),\n      offsetProvis = !isUndefined(opts.specificOffset)\n        ? opts.specificOffset\n        : zoneToUse.offset(tsNow),\n      normalized = normalizeObject(obj, normalizeUnit),\n      containsOrdinal = !isUndefined(normalized.ordinal),\n      containsGregorYear = !isUndefined(normalized.year),\n      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),\n      containsGregor = containsGregorYear || containsGregorMD,\n      definiteWeekDef = normalized.weekYear || normalized.weekNumber;\n\n    // cases:\n    // just a weekday -> this week's instance of that weekday, no worries\n    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error\n    // (gregorian month or day) + ordinal -> error\n    // otherwise just use weeks or ordinals or gregorian, depending on what's specified\n\n    if ((containsGregor || containsOrdinal) && definiteWeekDef) {\n      throw new ConflictingSpecificationError(\n        \"Can't mix weekYear/weekNumber units with year/month/day or ordinals\"\n      );\n    }\n\n    if (containsGregorMD && containsOrdinal) {\n      throw new ConflictingSpecificationError(\"Can't mix ordinal dates with month/day\");\n    }\n\n    const useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);\n\n    if (useWeekData) {\n      throw new Error(`Doesn't support week data`);\n    }\n\n    if (containsOrdinal) {\n      throw new Error(`Doesn't support ordinal`);\n    }\n\n    // configure ourselves to deal with gregorian dates or week stuff\n    let units = orderedUnits,\n      defaultValues = defaultUnitValues,\n      objNow = tsToObj(tsNow, offsetProvis);\n\n    // set default values for missing stuff\n    let foundFirst = false;\n    for (const u of units) {\n      const v = normalized[u];\n      if (!isUndefined(v)) {\n        foundFirst = true;\n      } else if (foundFirst) {\n        normalized[u] = defaultValues[u];\n      } else {\n        normalized[u] = objNow[u];\n      }\n    }\n\n    // make sure the values we have are in range\n    const higherOrderInvalid = hasInvalidGregorianData(normalized),\n      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);\n\n    if (invalid) {\n      return DateTime.invalid(invalid);\n    }\n\n    // compute the actual time\n    const gregorian = normalized,\n      [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse),\n      inst = new DateTime({\n        ts: tsFinal,\n        zone: zoneToUse,\n        o: offsetFinal,\n      });\n\n    return inst;\n  }\n\n  /**\n   * Create a DateTime from an ISO 8601 string\n   * @param {string} text - the ISO string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance\n   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})\n   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})\n   * @example DateTime.fromISO('2016-W05-4')\n   * @return {DateTime}\n   */\n  static fromISO(text, opts = {}) {\n    const [vals, parsedZone] = parseISODate(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"ISO 8601\", text);\n  }\n\n  /**\n   * Create a DateTime from an RFC 2822 string\n   * @param {string} text - the RFC 2822 string\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')\n   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')\n   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')\n   * @return {DateTime}\n   */\n  static fromRFC2822(text, opts = {}) {\n    const [vals, parsedZone] = parseRFC2822Date(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"RFC 2822\", text);\n  }\n\n  /**\n   * Create a DateTime from an HTTP header date\n   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1\n   * @param {string} text - the HTTP header date\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.\n   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.\n   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance\n   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')\n   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')\n   * @return {DateTime}\n   */\n  static fromHTTP(text, opts = {}) {\n    const [vals, parsedZone] = parseHTTPDate(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"HTTP\", opts);\n  }\n\n  /**\n   * Create a DateTime from a SQL date, time, or datetime\n   * Defaults to en-US if no locale has been specified, regardless of the system's locale\n   * @param {string} text - the string to parse\n   * @param {Object} opts - options to affect the creation\n   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone\n   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one\n   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale\n   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system\n   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance\n   * @example DateTime.fromSQL('2017-05-15')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })\n   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })\n   * @example DateTime.fromSQL('09:12:34.342')\n   * @return {DateTime}\n   */\n  static fromSQL(text, opts = {}) {\n    const [vals, parsedZone] = parseSQL(text);\n    return parseDataToDateTime(vals, parsedZone, opts, \"SQL\", text);\n  }\n\n  /**\n   * Create an invalid DateTime.\n   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.\n   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information\n   * @return {DateTime}\n   */\n  static invalid(reason, explanation = null) {\n    if (!reason) {\n      throw new InvalidArgumentError(\"need to specify a reason the DateTime is invalid\");\n    }\n\n    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);\n\n    if (Settings.throwOnInvalid) {\n      throw new InvalidDateTimeError(invalid);\n    } else {\n      return new DateTime({ invalid });\n    }\n  }\n\n  // INFO\n\n  /**\n   * Get the value of unit.\n   * @param {string} unit - a unit such as 'minute' or 'day'\n   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7\n   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4\n   * @return {number}\n   */\n  get(unit) {\n    return this[unit];\n  }\n\n  /**\n   * Returns whether the DateTime is valid. Invalid DateTimes occur when:\n   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30\n   * * The DateTime was created by an operation on another invalid date\n   * @type {boolean}\n   */\n  get isValid() {\n    return this.invalid === null;\n  }\n\n  /**\n   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidReason() {\n    return this.invalid ? this.invalid.reason : null;\n  }\n\n  /**\n   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid\n   * @type {string}\n   */\n  get invalidExplanation() {\n    return this.invalid ? this.invalid.explanation : null;\n  }\n\n  /**\n   * Get the time zone associated with this DateTime.\n   * @type {Zone}\n   */\n  get zone() {\n    return this._zone;\n  }\n\n  /**\n   * Get the name of the time zone.\n   * @type {string}\n   */\n  get zoneName() {\n    return this.isValid ? this.zone.name : null;\n  }\n\n  /**\n   * Get the year\n   * @example DateTime.local(2017, 5, 25).year //=> 2017\n   * @type {number}\n   */\n  get year() {\n    return this.isValid ? this.c.year : NaN;\n  }\n\n  /**\n   * Get the quarter\n   * @example DateTime.local(2017, 5, 25).quarter //=> 2\n   * @type {number}\n   */\n  get quarter() {\n    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;\n  }\n\n  /**\n   * Get the month (1-12).\n   * @example DateTime.local(2017, 5, 25).month //=> 5\n   * @type {number}\n   */\n  get month() {\n    return this.isValid ? this.c.month : NaN;\n  }\n\n  /**\n   * Get the day of the month (1-30ish).\n   * @example DateTime.local(2017, 5, 25).day //=> 25\n   * @type {number}\n   */\n  get day() {\n    return this.isValid ? this.c.day : NaN;\n  }\n\n  /**\n   * Get the hour of the day (0-23).\n   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9\n   * @type {number}\n   */\n  get hour() {\n    return this.isValid ? this.c.hour : NaN;\n  }\n\n  /**\n   * Get the minute of the hour (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30\n   * @type {number}\n   */\n  get minute() {\n    return this.isValid ? this.c.minute : NaN;\n  }\n\n  /**\n   * Get the second of the minute (0-59).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52\n   * @type {number}\n   */\n  get second() {\n    return this.isValid ? this.c.second : NaN;\n  }\n\n  /**\n   * Get the millisecond of the second (0-999).\n   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654\n   * @type {number}\n   */\n  get millisecond() {\n    return this.isValid ? this.c.millisecond : NaN;\n  }\n\n  /**\n   * Get the UTC offset of this DateTime in minutes\n   * @example DateTime.now().offset //=> -240\n   * @example DateTime.utc().offset //=> 0\n   * @type {number}\n   */\n  get offset() {\n    return this.isValid ? +this.o : NaN;\n  }\n\n  /**\n   * Returns a JavaScript Date equivalent to this DateTime.\n   * @return {Date}\n   */\n  toJSDate() {\n    return new Date(this.isValid ? this.ts : NaN);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to UTC. Returns a newly-constructed DateTime.\n   *\n   * Equivalent to {@link DateTime#setZone}('utc')\n   * @param {number} [offset=0] - optionally, an offset from UTC in minutes\n   * @param {Object} [opts={}] - options to pass to `setZone()`\n   * @return {DateTime}\n   */\n  toUTC(offset = 0, opts = {}) {\n    return this.setZone(FixedOffsetZone.instance(offset), opts);\n  }\n\n  /**\n   * \"Set\" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.\n   *\n   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.\n   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.\n   * @param {Object} opts - options\n   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.\n   * @return {DateTime}\n   */\n  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {\n    zone = normalizeZone(zone, Settings.defaultZone);\n    if (zone.equals(this.zone)) {\n      return this;\n    } else if (!zone.isValid) {\n      return DateTime.invalid(unsupportedZone(zone));\n    } else {\n      let newTS = this.ts;\n      if (keepLocalTime || keepCalendarTime) {\n        const offsetGuess = zone.offset(this.ts);\n        const asObj = this.toObject();\n        [newTS] = objToTS(asObj, offsetGuess, zone);\n      }\n      return clone(this, { ts: newTS, zone });\n    }\n  }\n\n  toObject(opts = {}) {\n    if (!this.isValid) return {};\n\n    const base = { ...this.c };\n\n    if (opts.includeConfig) {\n      base.outputCalendar = this.outputCalendar;\n      base.numberingSystem = this.loc.numberingSystem;\n      base.locale = this.loc.locale;\n    }\n    return base;\n  }\n}\n","import DateTime from \"./datetime.js\";\n\nexport { DateTime };\n\nexport function parseDate(value) {\n  const dateTimeParsers = [\n    DateTime.fromISO,\n    DateTime.fromRFC2822,\n    DateTime.fromHTTP,\n    DateTime.fromSQL,\n  ];\n\n  if (!value) return undefined;\n  if (typeof value !== \"string\") return undefined;\n\n  for (const parser of dateTimeParsers) {\n    const parsed = parser(value, { zone: \"utc\" });\n    if (parsed.isValid) {\n      return parsed.toJSDate();\n    }\n  }\n  return undefined;\n}\n"],"names":["LuxonError","Error","InvalidDateTimeError","constructor","reason","toMessage","ConflictingSpecificationError","InvalidUnitError","unit","InvalidArgumentError","ZoneIsAbstractError","Zone","type","name","isUniversal","offset","ts","equals","otherZone","isValid","singleton","SystemZone","instance","Intl","DateTimeFormat","resolvedOptions","timeZone","Date","getTimezoneOffset","isUndefined","o","isNumber","isInteger","isString","isDate","Object","prototype","toString","call","hasOwnProperty","obj","prop","integerBetween","thing","bottom","top","floorMod","x","n","Math","floor","padStart","input","isNeg","padded","parseInteger","string","undefined","parseInt","parseMillis","fraction","f","parseFloat","isLeapYear","year","daysInMonth","month","modMonth","modYear","objToLocalTS","d","UTC","day","hour","minute","second","millisecond","setUTCFullYear","untruncateYear","Settings","twoDigitCutoffYear","signedOffset","offHourStr","offMinuteStr","offHour","Number","isNaN","offMin","offMinSigned","is","asNumber","value","numericValue","normalizeObject","normalizer","normalized","u","v","formatOffset","format","hours","trunc","abs","minutes","sign","RangeError","dtfCache","makeDTF","zone","hour12","era","typeToPos","hackyOffset","dtf","date","formatted","replace","parsed","exec","fMonth","fDay","fYear","fadOrBc","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","pos","ianaZoneCache","IANAZone","create","resetCache","isValidSpecifier","s","isValidZone","e","zoneName","valid","NaN","adOrBc","adjustedHour","asUTC","asTS","over","monthsShort","weekdaysLong","weekdaysShort","FixedOffsetZone","utcInstance","parseSpecifier","r","match","fixed","InvalidZone","normalizeZone","defaultZone","lowered","toLowerCase","now","defaultLocale","defaultNumberingSystem","defaultOutputCalendar","throwOnInvalid","locale","numberingSystem","outputCalendar","cutoffYear","t","resetCaches","ianaRegex","combineRegexes","regexes","full","reduce","source","RegExp","combineExtractors","extractors","m","mergedVals","mergedZone","cursor","ex","val","next","slice","parse","patterns","regex","extractor","offsetRegex","isoExtendedZone","isoTimeBaseRegex","isoTimeRegex","isoTimeExtensionRegex","isoYmdRegex","sqlYmdRegex","sqlTimeRegex","sqlTimeExtensionRegex","int","fallback","extractISOYmd","item","extractISOTime","seconds","milliseconds","extractISOOffset","local","fullOffset","extractIANAZone","obsOffsets","GMT","EDT","EST","CDT","CST","MDT","MST","PDT","PST","fromStrings","weekdayStr","yearStr","monthStr","dayStr","hourStr","minuteStr","secondStr","result","English","indexOf","weekday","rfc2822","extractRFC2822","obsOffset","milOffset","preprocessRFC2822","trim","rfc1123","rfc850","ascii","extractRFC1123Or850","extractASCII","isoYmdWithTimeExtensionRegex","isoTimeCombinedRegex","extractISOYmdTimeAndOffset","extractISOTimeAndOffset","parseISODate","parseRFC2822Date","parseHTTPDate","sqlYmdWithTimeExtensionRegex","sqlTimeCombinedRegex","extractISOTimeOffsetAndIANAZone","parseSQL","Invalid","explanation","unitOutOfRange","hasInvalidGregorianData","validYear","validMonth","validDay","hasInvalidTimeData","validHour","validMinute","validSecond","validMillisecond","MAX_DATE","unsupportedZone","clone","inst","alts","current","c","loc","invalid","DateTime","old","fixOffset","localTS","tz","utcGuess","o2","o3","min","max","tsToObj","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","objToTS","parseDataToDateTime","parsedZone","opts","text","specificOffset","setZone","keys","interpretationZone","fromObject","defaultUnitValues","orderedUnits","normalizeUnit","years","months","days","quarter","quarters","weekdays","weeknumber","weeksnumber","weeknumbers","weekyear","weekyears","ordinal","config","unchanged","ot","_zone","weekData","isLuxonDateTime","fromJSDate","options","valueOf","zoneToUse","fromMillis","fromSeconds","tsNow","offsetProvis","containsOrdinal","containsGregorYear","containsGregorMD","containsGregor","definiteWeekDef","weekYear","weekNumber","useWeekData","units","defaultValues","objNow","foundFirst","higherOrderInvalid","gregorian","tsFinal","offsetFinal","fromISO","vals","fromRFC2822","fromHTTP","fromSQL","get","invalidReason","invalidExplanation","ceil","toJSDate","toUTC","keepLocalTime","keepCalendarTime","newTS","offsetGuess","asObj","toObject","base","includeConfig","parseDate","dateTimeParsers","parser"],"mappings":"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"}