import { ComponentMeta, default as registerComponent } from "@plasmicapp/host/registerComponent";
import { default as registerGlobalContext, GlobalContextMeta } from "@plasmicapp/host/registerGlobalContext";
import { default as registerToken } from "@plasmicapp/host/registerToken";
import React from "react";
export type Registerable = {
    registerComponent: typeof registerComponent;
    registerGlobalContext: typeof registerGlobalContext;
    registerToken: typeof registerToken;
};
export declare function makeRegisterComponent<T extends React.ComponentType<any>>(component: T, meta: ComponentMeta<React.ComponentProps<T>>): (loader?: Registerable) => void;
export declare function makeRegisterGlobalContext<T extends React.ComponentType<any>>(component: T, meta: GlobalContextMeta<React.ComponentProps<T>>): (loader?: Registerable) => void;
export declare function registerComponentHelper<T extends React.ComponentType<any>>(loader: Registerable | undefined, component: T, meta: ComponentMeta<React.ComponentProps<T>>): void;
type ReactElt = {
    children: ReactElt | ReactElt[];
    props: {
        children: ReactElt | ReactElt[];
        [prop: string]: any;
    } | null;
    type: React.ComponentType<any> | null;
    key: string | null;
} | null;
export declare function traverseReactEltTree(children: React.ReactNode, callback: (elt: ReactElt) => void): void;
export declare function asArray<T>(x: T[] | T | undefined | null): T[];
export declare function omit<T extends object>(obj: T, ...keys: (keyof T)[]): Partial<T>;
export declare function has<T extends object>(obj: T, keys: (keyof T)[]): boolean;
export declare function usePrevious<T>(value: T | undefined): T | undefined;
export declare function capitalize(value: string): string;
export declare function ensureArray<T>(x: T | T[]): T[];
export declare function setFieldsToUndefined(obj: any): void;
export declare function arrayEq(xs: ReadonlyArray<any>, ys: ReadonlyArray<any>): boolean;
import type { ErrorInfo } from "react";
interface ErrorBoundaryProps {
    children?: React.ReactNode;
    message?: string;
    canvasEnvId?: number;
}
interface ErrorBoundaryState {
    hasError: boolean;
    errorInfo: string;
}
export declare class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
    state: {
        hasError: boolean;
        errorInfo: string;
    };
    static getDerivedStateFromError(error: Error): {
        hasError: boolean;
        errorInfo: string;
    };
    componentDidCatch(error: any, errorInfo: ErrorInfo): void;
    componentDidUpdate(prevProps: Readonly<ErrorBoundaryProps>, prevState: Readonly<ErrorBoundaryState>): void;
    render(): string | number | boolean | Iterable<React.ReactNode> | React.JSX.Element | null | undefined;
}
export declare function get(obj: any, path: (string | number | symbol)[] | string): any;
export declare function set(obj: any, path: (string | number | symbol)[] | string, value: any): any;
export declare function pick<T extends {}>(obj: T, ...paths: (string | number | symbol)[][]): Partial<T>;
export {};
