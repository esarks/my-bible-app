'use strict';

var host = require('@plasmicapp/host');
var antd = require('antd');
var React = require('react');
var reactUtils = require('./react-utils-11b0221a.cjs.js');
var utils = require('./utils-7711f93b.cjs.js');
var contexts = require('./contexts-a2387bed.cjs.js');
require('classnames');
require('@plasmicapp/host/registerComponent');
require('@plasmicapp/host/registerGlobalContext');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FormItem = antd.Form.Item;
function plasmicRulesToAntdRules(plasmicRules, label) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const effectiveLabel = label || "This field";
  const rules = [];
  for (const plasmicRule of plasmicRules) {
    switch (plasmicRule.ruleType) {
      case "enum":
        rules.push({
          type: "enum",
          enum: (_b = (_a = plasmicRule.options) == null ? void 0 : _a.map((opt) => opt.value)) != null ? _b : [],
          message: (_c = plasmicRule.message) != null ? _c : `${effectiveLabel} must be a valid value`
        });
        break;
      case "required":
        rules.push({
          required: true,
          message: (_d = plasmicRule.message) != null ? _d : `${effectiveLabel} is required`
        });
        break;
      case "regex":
        rules.push({
          pattern: new RegExp((_e = plasmicRule.pattern) != null ? _e : ""),
          message: (_f = plasmicRule.message) != null ? _f : `${effectiveLabel} must be a valid value`
        });
        break;
      case "whitespace":
        rules.push({
          whitespace: true,
          message: (_g = plasmicRule.message) != null ? _g : `${effectiveLabel} is required`
        });
        break;
      case "min":
        rules.push({
          [plasmicRule.ruleType]: plasmicRule.length,
          message: (_h = plasmicRule.message) != null ? _h : `${effectiveLabel} must be at least ${plasmicRule.length} characters`
        });
        break;
      case "max":
        rules.push({
          [plasmicRule.ruleType]: plasmicRule.length,
          message: (_i = plasmicRule.message) != null ? _i : `${effectiveLabel} must be at most ${plasmicRule.length} characters`
        });
        break;
      case "advanced":
        rules.push({
          validator: (...args) => {
            var _a2;
            return ((_a2 = plasmicRule.custom) == null ? void 0 : _a2.apply(null, args)) ? Promise.resolve() : Promise.reject();
          },
          message: plasmicRule.message
        });
    }
  }
  return rules;
}
function FormItemWrapper(props) {
  var _b, _c, _d;
  const _a = props, {
    rules: plasmicRules,
    description,
    noLabel,
    name,
    hideValidationMessage,
    customizeProps,
    setControlContextData,
    alignLabellessWithControls = true
  } = _a, rest = __objRest(_a, [
    "rules",
    "description",
    "noLabel",
    "name",
    "hideValidationMessage",
    "customizeProps",
    "setControlContextData",
    "alignLabellessWithControls"
  ]);
  const relativeFormItemName = contexts.useFormItemRelativeName(name);
  const fullFormItemName = contexts.useFormItemFullName(name);
  const pathCtx = React__default.default.useContext(contexts.PathContext);
  const fieldEntity = React__default.default.useRef({
    preserve: (_b = props.preserve) != null ? _b : true,
    fullPath: pathCtx.fullPath,
    name
  }).current;
  const bestEffortLabel = !noLabel && reactUtils.reactNodeToString(props.label) || utils.ensureArray(props.name).slice(-1)[0];
  const rules = plasmicRules ? plasmicRulesToAntdRules(
    plasmicRules,
    typeof bestEffortLabel === "number" ? "" + bestEffortLabel : bestEffortLabel
  ) : void 0;
  const layoutContext = React__default.default.useContext(contexts.FormLayoutContext);
  const inCanvas = !!host.usePlasmicCanvasContext();
  const {
    fireOnValuesChange,
    forceRemount,
    registerField,
    initialValues,
    internalFieldCtx
  } = (_c = React__default.default.useContext(contexts.InternalFormInstanceContext)) != null ? _c : {};
  if (inCanvas) {
    const form = contexts.useFormInstanceMaybe();
    const prevPropValues = React__default.default.useRef({
      initialValue: props.initialValue,
      name: props.name
    });
    (_d = props.setControlContextData) == null ? void 0 : _d.call(props, {
      internalFieldCtx,
      formInstance: form,
      parentFormItemPath: pathCtx.fullPath,
      layout: layoutContext
    });
    React__default.default.useEffect(() => {
      if (prevPropValues.current.name !== props.name) {
        forceRemount == null ? void 0 : forceRemount();
      }
      if (!fullFormItemName || utils.get(initialValues, fullFormItemName) != null || props.initialValue == null) {
        return;
      }
      form == null ? void 0 : form.setFieldValue(fullFormItemName, props.initialValue);
      prevPropValues.current.initialValue = props.initialValue;
      fireOnValuesChange == null ? void 0 : fireOnValuesChange();
    }, [
      form,
      props.initialValue,
      JSON.stringify(pathCtx.fullPath),
      props.name,
      props.preserve
    ]);
  }
  React__default.default.useEffect(() => {
    var _a2;
    fieldEntity.fullPath = [
      ...pathCtx.fullPath,
      ...props.name != null ? [props.name] : []
    ];
    fieldEntity.name = props.name;
    fieldEntity.preserve = (_a2 = props.preserve) != null ? _a2 : true;
  }, [pathCtx.fullPath, props.name, props.preserve]);
  React__default.default.useEffect(() => {
    const unregister = registerField == null ? void 0 : registerField(fieldEntity);
    return () => unregister == null ? void 0 : unregister();
  }, []);
  return /* @__PURE__ */ React__default.default.createElement(
    FormItem,
    __spreadProps(__spreadValues({}, rest), {
      label: noLabel ? void 0 : props.label,
      name: relativeFormItemName,
      rules,
      extra: description,
      help: hideValidationMessage ? "" : props.help,
      colon: noLabel ? false : void 0,
      valuePropName: deriveValuePropName(props),
      trigger: deriveOnChangePropName(props),
      wrapperCol: (layoutContext == null ? void 0 : layoutContext.layout) === "horizontal" && noLabel && alignLabellessWithControls && layoutContext.labelSpan ? { offset: layoutContext.labelSpan } : void 0
    }),
    /* @__PURE__ */ React__default.default.createElement(FormItemForwarder, { formItemProps: props })
  );
}
function deriveValuePropName(props) {
  var _a;
  if (props.valuePropName) {
    return props.valuePropName;
  }
  const valueProps = ((_a = React__default.default.Children.map(props.children, (child) => {
    var _a2;
    if (React__default.default.isValidElement(child)) {
      const childType = child.type;
      if (childType) {
        const x = (_a2 = childType.__plasmicFormFieldMeta) == null ? void 0 : _a2.valueProp;
        if (x) {
          return x;
        }
        const plumeType = childType.__plumeType;
        if (plumeType && (plumeType === "checkbox" || plumeType === "switch")) {
          return "isChecked";
        }
      }
    }
    return void 0;
  })) != null ? _a : []).filter((x) => !!x);
  if (valueProps.length > 0) {
    return valueProps[0];
  }
  return void 0;
}
function deriveOnChangePropName(props) {
  var _a;
  if (props.trigger) {
    return props.trigger;
  }
  const triggerProps = ((_a = React__default.default.Children.map(props.children, (child) => {
    var _a2;
    if (React__default.default.isValidElement(child)) {
      const childType = child.type;
      if (childType) {
        const x = (_a2 = childType.__plasmicFormFieldMeta) == null ? void 0 : _a2.onChangeProp;
        if (x) {
          return x;
        }
      }
    }
    return void 0;
  })) != null ? _a : []).filter((x) => !!x);
  if (triggerProps.length > 0) {
    return triggerProps[0];
  }
  return void 0;
}
function FormItemForwarder(_a) {
  var _b = _a, { formItemProps } = _b, props = __objRest(_b, ["formItemProps"]);
  var _a2;
  const status = antd.Form.Item.useStatus();
  const internalFormCtx = React__default.default.useContext(contexts.InternalFormInstanceContext);
  const data = {
    status: status.status
  };
  (_a2 = props.setControlContextData) == null ? void 0 : _a2.call(props, {
    internalFormCtx,
    status
  });
  return React__default.default.Children.map(formItemProps.children, (child, i) => {
    var _a3;
    if (i === 0 && React.isValidElement(child)) {
      let newProps = __spreadProps(__spreadValues(__spreadValues({
        name: formItemProps.name
      }, (_a3 = child.props) != null ? _a3 : {}), props), {
        __plasmicFormField: true
      });
      if (formItemProps.customizeProps) {
        newProps = reactUtils.mergeProps(
          newProps,
          formItemProps.customizeProps(data, newProps)
        );
      }
      return React.cloneElement(child, newProps);
    } else {
      return child;
    }
  });
}

exports.FormItemWrapper = FormItemWrapper;
//# sourceMappingURL=FormItem.cjs.js.map
