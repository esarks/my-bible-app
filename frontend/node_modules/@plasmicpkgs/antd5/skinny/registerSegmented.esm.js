import { Segmented } from 'antd';
import React, { useMemo } from 'react';
import { r as registerComponentHelper, t as traverseReactEltTree } from './utils-5ebcaa63.esm.js';
import '@plasmicapp/host/registerComponent';
import '@plasmicapp/host/registerGlobalContext';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdSegmented(props) {
  const _a = props, {
    optionsSlot,
    options: optionLabelObjs,
    useSlotOptions
  } = _a, rest = __objRest(_a, [
    "optionsSlot",
    "options",
    "useSlotOptions"
  ]);
  const options = useMemo(() => {
    var _a2;
    if (useSlotOptions) {
      const optionElts = ((_a2 = optionsSlot == null ? void 0 : optionsSlot.type) == null ? void 0 : _a2.name) == AntdSegmentedOption.name ? [optionsSlot] : optionsSlot == null ? void 0 : optionsSlot.props.children;
      return optionElts == null ? void 0 : optionElts.filter(
        (el) => {
          var _a3;
          return React.isValidElement(el) && ((_a3 = el.type) == null ? void 0 : _a3.name) === AntdSegmentedOption.name;
        }
      ).map((el) => ({
        value: el.props.value,
        label: /* @__PURE__ */ React.createElement(React.Fragment, null, el.props.children)
      }));
    }
    return (optionLabelObjs == null ? void 0 : optionLabelObjs.filter((l) => l.label && l.value)) || [];
  }, [optionsSlot, useSlotOptions, optionLabelObjs]);
  return /* @__PURE__ */ React.createElement(Segmented, __spreadValues({ options }, rest));
}
function AntdSegmentedOption(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, props.children);
}
function OutlineMessage() {
  return /* @__PURE__ */ React.createElement("div", null, "* To re-arrange options, use the Outline panel");
}
function getValueOptions(props) {
  var _a;
  if (props.useSlotOptions) {
    const res = /* @__PURE__ */ new Set();
    traverseReactEltTree(props.optionsSlot, (elt) => {
      var _a2, _b;
      if ((elt == null ? void 0 : elt.type) === AntdSegmentedOption && ((_a2 = elt.props) == null ? void 0 : _a2.value)) {
        res.add((_b = elt.props) == null ? void 0 : _b.value);
      }
    });
    return Array.from(res.keys());
  } else {
    return ((_a = props.options) == null ? void 0 : _a.filter((l) => l.label && l.value).map((l) => l.value)) || [];
  }
}
function getDefaultSlotOption(key) {
  return {
    type: "component",
    name: segmentedOptionComponentName,
    props: {
      value: `Option ${key}`,
      children: {
        type: "hbox",
        styles: {
          columnGap: "5px",
          justifyContent: "center"
        },
        children: [
          {
            type: "img",
            styles: {
              opacity: 0.5,
              objectFit: "contain"
            },
            src: "https://static1.plasmic.app/home-outlined.svg"
          },
          {
            type: "text",
            value: `Option ${key}`,
            styles: {
              width: "auto"
            }
          }
        ]
      }
    }
  };
}
const segmentedComponentName = "plasmic-antd5-segmented";
const segmentedOptionComponentName = "plasmic-antd5-segmented-option";
function registerSegmented(loader) {
  registerComponentHelper(loader, AntdSegmentedOption, {
    name: segmentedOptionComponentName,
    displayName: "Segmented Option",
    props: {
      value: {
        type: "string",
        displayName: "Name",
        description: "Name of the segment"
      },
      children: {
        type: "slot",
        hidePlaceholder: true
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSegmented",
    importName: "AntdSegmentedOption",
    parentComponentName: segmentedComponentName
  });
  registerComponentHelper(loader, AntdSegmented, {
    name: segmentedComponentName,
    displayName: "Segmented",
    props: {
      size: {
        type: "choice",
        defaultValueHint: "middle",
        description: `Set the size of segments`,
        options: ["large", "middle", "small"]
      },
      value: {
        editOnly: true,
        uncontrolledProp: "defaultValue",
        type: "choice",
        options: getValueOptions,
        displayName: "Selected option",
        description: `Default selected option`,
        hidden: (ps) => !ps.options
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false,
        description: `Disable all segments`
      },
      block: {
        type: "boolean",
        displayName: "Fill spacing",
        defaultValueHint: false,
        description: `Fill the container element, with all segments equally spaced`
      },
      useSlotOptions: {
        type: "boolean",
        defaultValue: false,
        advanced: true,
        description: "Add icons, avatars, images, and more in option labels"
      },
      options: {
        type: "array",
        hidden: (ps) => ps.useSlotOptions,
        validator: (value, ps) => {
          if (ps.useSlotOptions) {
            return true;
          }
          const badOptions = value.map((v, i) => !v.value || !v.label ? i + 1 : void 0).filter((i) => i);
          if (badOptions.length > 0) {
            return `Options at position ${badOptions.join(
              ", "
            )} are missing label or value`;
          }
          return true;
        },
        itemType: {
          type: "object",
          nameFunc: (item) => item.label,
          fields: {
            label: {
              type: "string",
              required: true
            },
            value: {
              type: "string",
              required: true
            }
          }
        },
        defaultValue: [
          {
            label: "Option 1",
            value: "Option 1"
          },
          {
            label: "Option 2",
            value: "Option 2"
          },
          {
            label: "Option 3",
            value: "Option 3"
          }
        ]
      },
      optionsSlot: {
        type: "slot",
        displayName: "Options",
        allowedComponents: [segmentedOptionComponentName],
        hidden: (ps) => !ps.useSlotOptions,
        defaultValue: [getDefaultSlotOption(1), getDefaultSlotOption(2)]
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "string" }]
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text"
      }
    },
    actions: [
      {
        type: "button-action",
        label: "Add new option",
        hidden: (ps) => !ps.useSlotOptions,
        onClick: ({ componentProps, studioOps }) => {
          const generateNewKey = () => {
            const existingValues = /* @__PURE__ */ new Set();
            traverseReactEltTree(componentProps.optionsSlot, (elt) => {
              var _a;
              if ((elt == null ? void 0 : elt.type) === AntdSegmentedOption && ((_a = elt == null ? void 0 : elt.props) == null ? void 0 : _a.value)) {
                existingValues.add(elt.props.value);
              }
            });
            for (let keyCandidate = 1; keyCandidate <= existingValues.size + 1; keyCandidate++) {
              const strKey = keyCandidate.toString();
              if (!existingValues.has(strKey) && !existingValues.has(`Option ${strKey}`)) {
                return strKey;
              }
            }
            return void 0;
          };
          const newKey = generateNewKey();
          if (!newKey)
            return;
          studioOps.appendToSlot(getDefaultSlotOption(newKey), "optionsSlot");
        }
      },
      {
        type: "button-action",
        hidden: (ps) => !ps.value || !ps.useSlotOptions,
        label: "Delete current option",
        onClick: ({ componentProps, studioOps }) => {
          const options = [];
          traverseReactEltTree(componentProps.optionsSlot, (elt) => {
            var _a;
            if ((elt == null ? void 0 : elt.type) === AntdSegmentedOption && ((_a = elt == null ? void 0 : elt.props) == null ? void 0 : _a.value)) {
              options.push(elt.props.value);
            }
          });
          const value = componentProps.value;
          const currPos = options.findIndex((opt) => {
            return opt === value;
          });
          if (currPos !== -1) {
            studioOps.removeFromSlotAt(currPos, "optionsSlot");
            if (options.length - 1 > 0) {
              const prevPos = (currPos - 1 + options.length) % options.length;
              studioOps.updateProps({ value: options[prevPos] });
            }
          }
        }
      },
      {
        type: "custom-action",
        hidden: (ps) => !ps.useSlotOptions,
        control: OutlineMessage
      }
    ],
    importPath: "@plasmicpkgs/antd5/skinny/registerSegmented",
    importName: "AntdSegmented"
  });
}

export { AntdSegmented, AntdSegmentedOption, registerSegmented, segmentedComponentName, segmentedOptionComponentName };
//# sourceMappingURL=registerSegmented.esm.js.map
