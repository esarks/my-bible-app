{"version":3,"file":"react-utils-79d444f6.esm.js","sources":["../src/react-utils.tsx"],"sourcesContent":["import classNames from \"classnames\";\nimport React, { isValidElement } from \"react\";\n\nexport const isBrowser = typeof window !== \"undefined\";\nexport const NONE = Symbol(\"NONE\");\n\nexport const useIsomorphicLayoutEffect = isBrowser\n  ? React.useLayoutEffect\n  : React.useEffect;\n\nexport function createElementWithChildren(\n  elementType: any,\n  props: any,\n  children: React.ReactNode\n) {\n  if (Array.isArray(children)) {\n    return React.createElement(\n      elementType,\n      props,\n      ...children\n    ) as React.ReactElement;\n  } else if (children || \"children\" in props) {\n    // Only call React.createElement with `children` if there are actual children,\n    // or if there was an explicit (albeit undefined) children passed via\n    // props.  Otherwise, if you pass `undefined` as the children argument\n    // to React.createElement, the created element will have prop {children: undefined}.\n    // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}\n    // are used, then it will be taken as a `children` override, and will thus blank out\n    // everything under the root node.\n    return React.createElement(elementType, props, children);\n  } else {\n    return React.createElement(elementType, props);\n  }\n}\n\nexport function ensureNotArray(children: React.ReactNode) {\n  if (Array.isArray(children)) {\n    if (children.length === 1) {\n      return children[0];\n    } else {\n      return React.createElement(React.Fragment, {}, ...children);\n    }\n  } else {\n    return children;\n  }\n}\n\n/**\n * Flattens ReactNode into an array of ReactChild, but does NOT replace\n * missing keys with array index, as React.Children.toArray() does.\n */\nexport function toChildArray(children: React.ReactNode): React.ReactChild[] {\n  if (isReactChild(children)) {\n    return [children];\n  } else if (Array.isArray(children)) {\n    return children.flatMap(toChildArray);\n  } else {\n    return [];\n  }\n}\n\nexport function isReactText(child: React.ReactNode): child is React.ReactText {\n  return typeof child === \"string\" || typeof child === \"number\";\n}\n\nexport function isReactChild(\n  child: React.ReactNode\n): child is React.ReactChild {\n  return React.isValidElement(child) || isReactText(child);\n}\n\nexport function isReactFragment(\n  child: React.ReactNode\n): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === React.Fragment;\n}\n\nexport function isReactNode(x: any) {\n  return (\n    typeof x === \"string\" || typeof x === \"number\" || React.isValidElement(x)\n  );\n}\n\n// From https://stackoverflow.com/questions/54775790/forcing-excess-property-checking-on-variable-passed-to-typescript-function\n// We also wrap the error message in a Partial<> because otherwise Jetbrains IDEs will autocomplete the component with all the string methods as props - see https://github.com/plasmicapp/plasmic/issues/16.\nexport type StrictProps<T, TExpected> = Exclude<\n  keyof T,\n  keyof TExpected\n> extends never\n  ? any\n  : Partial<\"Unexpected extraneous props\">;\n\nexport type HTMLElementRefOf<T extends keyof JSX.IntrinsicElements> = Exclude<\n  React.ComponentProps<T>[\"ref\"],\n  string\n>;\n\nexport function mergeProps(\n  props: Record<string, any>,\n  ...restProps: Record<string, any>[]\n): Record<string, any> {\n  if (restProps.every((rest) => Object.keys(rest).length === 0)) {\n    return props;\n  }\n\n  const result = { ...props };\n\n  for (const rest of restProps) {\n    for (const key of Object.keys(rest)) {\n      result[key] = mergePropVals(key, result[key], rest[key]);\n    }\n  }\n\n  return result;\n}\n\nfunction updateRef<T>(ref: React.Ref<T> | undefined, value: T | null) {\n  if (!ref) {\n    return;\n  }\n\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else {\n    if (!Object.isFrozen(ref)) {\n      (ref as React.MutableRefObject<T | null>).current = value;\n    }\n  }\n}\n\nexport function mergeRefs<T>(...refs: (React.Ref<T> | undefined)[]) {\n  return (value: T) => {\n    for (const ref of refs) {\n      updateRef(ref, value);\n    }\n  };\n}\n\nexport function mergePropVals(name: string, val1: any, val2: any): any {\n  if (val1 === NONE || val2 === NONE) {\n    // The NONE sentinel always skips all merging and returns null\n    return null;\n  } else if (val1 == null) {\n    // If either of them is nil, prefer the other\n    return val2;\n  } else if (val2 == null) {\n    return val1;\n  } else if (name === \"className\") {\n    // Special case for className -- always combine both class names\n    return classNames(val1, val2);\n  } else if (name === \"style\") {\n    // Special case for style -- always shallow-merge style dicts\n    return { ...val1, ...val2 };\n  } else if (name === \"ref\") {\n    // Special case for ref\n    return mergeRefs(val1, val2);\n  } else if (typeof val1 !== typeof val2) {\n    // If the type of the two values are different, then no way to merge them.\n    // Prefer val2.\n    return val2;\n  } else if (name.startsWith(\"on\") && typeof val1 === \"function\") {\n    // Special case for event handlers -- always call both handlers\n    return (...args: any[]) => {\n      let res: any;\n      if (typeof val1 === \"function\") {\n        res = val1(...args);\n      }\n      if (typeof val2 === \"function\") {\n        res = val2(...args);\n      }\n      return res;\n    };\n  } else {\n    // For all else, prefer val2\n    return val2;\n  }\n}\n\nexport function getElementTypeName(element: React.ReactElement) {\n  if (typeof element.type === \"string\") {\n    return element.type;\n  } else {\n    const comp = element.type as any;\n    return comp.displayName ?? comp.name ?? comp.render?.name ?? \"Component\";\n  }\n}\n\nexport function reactNodeToString(reactNode: React.ReactNode): string {\n  let string = \"\";\n  if (typeof reactNode === \"string\") {\n    string = reactNode;\n  } else if (typeof reactNode === \"number\") {\n    string = reactNode.toString();\n  } else if (reactNode instanceof Array) {\n    reactNode.forEach(function (child) {\n      string += reactNodeToString(child);\n    });\n  } else if (isValidElement(reactNode)) {\n    string += reactNodeToString(reactNode.props.children);\n  }\n  return string;\n}\n\nexport function useIsMounted(): () => boolean {\n  const ref = React.useRef<boolean>(false);\n  const isMounted = React.useCallback(() => ref.current, []);\n\n  React.useEffect(() => {\n    ref.current = true;\n    return () => {\n      ref.current = false;\n    };\n  }, []);\n\n  return isMounted;\n}\n"],"names":[],"mappings":"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"}