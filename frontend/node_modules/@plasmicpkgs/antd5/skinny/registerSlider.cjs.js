'use strict';

var antd = require('antd');
var kebabCase = require('lodash/kebabCase');
var React = require('react');
var utils = require('./utils-7711f93b.cjs.js');
require('@plasmicapp/host/registerComponent');
require('@plasmicapp/host/registerGlobalContext');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var kebabCase__default = /*#__PURE__*/_interopDefault(kebabCase);
var React__default = /*#__PURE__*/_interopDefault(React);

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useMarks({
  simpleMarks,
  stylableMarks
}) {
  const marks = React.useMemo(() => {
    var _a;
    const stylableMarksList = ((_a = stylableMarks == null ? void 0 : stylableMarks.type) == null ? void 0 : _a.name) == AntdSliderMark.name ? [stylableMarks] : stylableMarks == null ? void 0 : stylableMarks.props.children;
    const res = {};
    stylableMarksList == null ? void 0 : stylableMarksList.filter(
      (c) => {
        var _a2;
        return React__default.default.isValidElement(c) && ((_a2 = c.type) == null ? void 0 : _a2.name) === AntdSliderMark.name;
      }
    ).forEach((c) => {
      res[c.props.mark] = c.props.children;
    });
    simpleMarks == null ? void 0 : simpleMarks.forEach((mark) => {
      res[mark.value] = { label: mark.label };
    });
    return res;
  }, [simpleMarks, stylableMarks]);
  return marks;
}
function useTooltip({
  tooltipVisible,
  tooltipPlacement,
  tooltipPrefix,
  tooltipSuffix
}) {
  return {
    open: tooltipVisible === "unset" ? void 0 : Boolean(tooltipVisible),
    placement: tooltipPlacement,
    getPopupContainer: (node) => node,
    formatter: (value) => `${tooltipPrefix || ""}${value}${tooltipSuffix || ""}`
  };
}
function AntdRangeSlider(props) {
  const _a = props, {
    marks,
    stylableMarks,
    sliderScopeClassName,
    className,
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix,
    draggableTrack,
    valueMin,
    valueMax,
    defaultValueMin,
    defaultValueMax,
    onAfterChange
  } = _a, rest = __objRest(_a, [
    "marks",
    "stylableMarks",
    "sliderScopeClassName",
    "className",
    "tooltipVisible",
    "tooltipPlacement",
    "tooltipPrefix",
    "tooltipSuffix",
    "draggableTrack",
    "valueMin",
    "valueMax",
    "defaultValueMin",
    "defaultValueMax",
    "onAfterChange"
  ]);
  const marksProp = useMarks({ simpleMarks: marks, stylableMarks });
  const tooltipProp = useTooltip({
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix
  });
  return /* @__PURE__ */ React__default.default.createElement(
    antd.Slider,
    __spreadValues({
      value: [valueMin || 0, valueMax || 0],
      defaultValue: [defaultValueMin || 0, defaultValueMax || 0],
      range: { draggableTrack },
      className: `${sliderScopeClassName} ${className}`,
      tooltip: tooltipProp,
      marks: marksProp,
      onChangeComplete: onAfterChange
    }, rest)
  );
}
function AntdSingleSlider(props) {
  const _a = props, {
    marks,
    stylableMarks,
    sliderScopeClassName,
    className,
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix,
    onAfterChange
  } = _a, rest = __objRest(_a, [
    "marks",
    "stylableMarks",
    "sliderScopeClassName",
    "className",
    "tooltipVisible",
    "tooltipPlacement",
    "tooltipPrefix",
    "tooltipSuffix",
    "onAfterChange"
  ]);
  const marksProp = useMarks({ simpleMarks: marks, stylableMarks });
  const tooltipProp = useTooltip({
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix
  });
  return /* @__PURE__ */ React__default.default.createElement(
    antd.Slider,
    __spreadValues({
      className: `${sliderScopeClassName} ${className}`,
      tooltip: tooltipProp,
      marks: marksProp,
      range: false,
      onChangeComplete: onAfterChange
    }, rest)
  );
}
function AntdSliderMark(props) {
  return /* @__PURE__ */ React__default.default.createElement(React__default.default.Fragment, null, props.children);
}
const sliderComponentName = "plasmic-antd5-slider";
const rangeSliderComponentName = "plasmic-antd5-range-slider";
const sliderMarkComponentName = "plasmic-antd5-slider-mark";
const commonProps = {
  autoFocus: {
    type: "boolean",
    description: "Focus when component is rendered",
    defaultValueHint: false,
    advanced: true
  },
  disabled: {
    type: "boolean",
    description: "If true, the slider thumb will not be draggable",
    defaultValueHint: false
  },
  keyboard: {
    type: "boolean",
    description: "Support using keyboard to move handlers",
    defaultValueHint: true,
    advanced: true
  },
  dots: {
    type: "boolean",
    displayName: "Show dots",
    description: "Show dot at every step on the slider",
    defaultValueHint: false,
    advanced: true
  },
  marks: {
    type: "array",
    description: "Specific markers or snap points on the slider",
    itemType: {
      nameFunc: (value) => `${value.value} \u2192 ${value.label}`,
      type: "object",
      fields: {
        value: {
          type: "number",
          description: "value on the slider"
        },
        label: "string"
      }
    }
  },
  stylableMarks: {
    type: "slot",
    displayName: "Stylable Marks",
    allowedComponents: [sliderMarkComponentName],
    defaultValue: [
      {
        type: "component",
        name: sliderMarkComponentName,
        props: {
          mark: 50,
          children: {
            type: "text",
            value: "Stylable Mark"
          }
        }
      }
    ]
  },
  included: {
    type: "boolean",
    description: "Fill the slider till the selected value",
    defaultValueHint: true,
    advanced: true
  },
  min: {
    type: "number",
    description: "The minimum value the slider can slide to",
    defaultValueHint: 0,
    displayName: "Slider start"
  },
  max: {
    type: "number",
    description: "The maximum value the slider can slide to",
    defaultValueHint: 100,
    displayName: "Slider end"
  },
  reverse: {
    type: "boolean",
    description: "Reverse the slider, so that the starting point is at the right end",
    defaultValueHint: false,
    advanced: true
  },
  step: {
    type: "number",
    description: "Granularity of the slider's movement",
    defaultValueHint: 1,
    min: 0
  },
  vertical: {
    type: "boolean",
    description: "Slide vertically",
    defaultValueHint: false,
    advanced: true,
    helpText: "Please increase the slider height to make the vertical slider visible"
  },
  tooltipVisible: {
    type: "choice",
    displayName: "Show tooltip",
    options: [
      {
        value: true,
        label: "Always"
      },
      {
        value: false,
        label: "Never"
      },
      {
        value: "unset",
        label: "Only on drag/hover"
      }
    ],
    defaultValueHint: "unset",
    defaultValue: "unset",
    advanced: true
  },
  tooltipPlacement: {
    type: "choice",
    options: [
      "topLeft",
      "top",
      "topRight",
      "leftTop",
      "left",
      "leftBottom",
      "rightTop",
      "right",
      "rightBottom",
      "bottomLeft",
      "bottom",
      "bottomRight"
    ].map((item) => ({
      value: item,
      label: kebabCase__default.default(item)
    })),
    description: "Default placement of tooltip",
    defaultValueHint: "top",
    advanced: true
  },
  tooltipPrefix: {
    type: "string",
    description: "Add a prefix to the slider value inside tooltip",
    advanced: true
  },
  tooltipSuffix: {
    type: "string",
    description: "Add a suffix to the slider value inside tooltip",
    advanced: true
  },
  sliderScopeClassName: {
    type: "styleScopeClass",
    scopeName: "slider"
  },
  railClassName: {
    type: "class",
    displayName: "Rail",
    description: "The path on which the thumb moves",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-rail",
        label: "Base"
      }
    ]
  },
  trackClassName: {
    type: "class",
    displayName: "Track",
    description: "The inclusive part of the slider rail",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-track",
        label: "Base"
      }
    ]
  },
  handleClassName: {
    type: "class",
    displayName: "Handle",
    description: "Thumb of the slider that moves on drag",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-handle::after",
        label: "Base"
      }
    ]
  },
  dotClassName: {
    type: "class",
    displayName: "Step dots",
    description: "The dots that represent steps on the slider rail",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-dot",
        label: "Base"
      }
    ]
  },
  activeDotClassName: {
    type: "class",
    displayName: "Active dots",
    description: "The dots within the inclusive part of the slider rail",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-dot.ant-slider-dot-active",
        label: "Base"
      }
    ]
  },
  tooltipClassName: {
    type: "class",
    displayName: "Tooltip",
    description: "The tooltip that shows the value of the slider",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-tooltip",
        label: "Base"
      }
    ]
  }
};
const rangeSliderHelpers = {
  states: {
    min: {
      onChangeArgsToValue: (value) => value[0]
    },
    max: {
      onChangeArgsToValue: (value) => value[1]
    }
  }
};
function registerSlider(loader) {
  utils.registerComponentHelper(loader, AntdSingleSlider, {
    name: sliderComponentName,
    displayName: "Slider",
    defaultStyles: {
      width: "300px"
    },
    props: __spreadValues({
      value: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "The default value of the slider",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "number" }]
      },
      onAfterChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "number" }]
      }
    }, commonProps),
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSlider",
    importName: "AntdSingleSlider"
  });
  utils.registerComponentHelper(loader, AntdRangeSlider, {
    name: rangeSliderComponentName,
    displayName: "Range Slider",
    defaultStyles: {
      width: "300px"
    },
    props: __spreadValues({
      draggableTrack: {
        type: "boolean",
        defaultValueHint: false,
        description: "Whether range track can be dragged"
      },
      valueMin: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValueMin",
        description: "The default minimum value of the range slider"
      },
      valueMax: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValueMax",
        description: "The default maximum value of the range slider"
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "object" }]
      },
      onAfterChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "object" }]
      }
    }, commonProps),
    states: {
      min: __spreadValues({
        type: "writable",
        valueProp: "valueMin",
        onChangeProp: "onChange",
        variableType: "number"
      }, rangeSliderHelpers.states.min),
      max: __spreadValues({
        type: "writable",
        valueProp: "valueMax",
        onChangeProp: "onChange",
        variableType: "number"
      }, rangeSliderHelpers.states.max)
    },
    componentHelpers: {
      helpers: rangeSliderHelpers,
      importName: "rangeSliderHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerSlider"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSlider",
    importName: "AntdRangeSlider"
  });
  utils.registerComponentHelper(loader, AntdSliderMark, {
    name: sliderMarkComponentName,
    displayName: "Slider Mark",
    props: {
      mark: {
        type: "number",
        description: "value on the slider"
      },
      children: {
        type: "slot",
        hidePlaceholder: true
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSlider",
    importName: "AntdSliderMark",
    parentComponentName: sliderComponentName
  });
}

exports.AntdRangeSlider = AntdRangeSlider;
exports.AntdSingleSlider = AntdSingleSlider;
exports.AntdSliderMark = AntdSliderMark;
exports.rangeSliderComponentName = rangeSliderComponentName;
exports.rangeSliderHelpers = rangeSliderHelpers;
exports.registerSlider = registerSlider;
exports.sliderComponentName = sliderComponentName;
exports.sliderMarkComponentName = sliderMarkComponentName;
exports.useMarks = useMarks;
exports.useTooltip = useTooltip;
//# sourceMappingURL=registerSlider.cjs.js.map
