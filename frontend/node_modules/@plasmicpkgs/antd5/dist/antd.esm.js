import { Result, Form, Checkbox, DatePicker, Radio, Select, Input, InputNumber, Avatar, Breadcrumb, Button, Collapse, ColorPicker, ConfigProvider, theme, message, notification, Drawer, Menu, Dropdown, Modal, Pagination, Popover, Progress, Rate, Segmented, Slider, Steps, Switch, Table, Tabs, Tooltip, Tree, Upload, Image } from 'antd';
import equal from 'fast-deep-equal';
import React, { isValidElement, cloneElement, useMemo, useEffect, useState, useRef } from 'react';
import registerComponent from '@plasmicapp/host/registerComponent';
import registerGlobalContext from '@plasmicapp/host/registerGlobalContext';
import { deriveFieldConfigs, normalizeData, usePlasmicDataOp } from '@plasmicapp/data-sources';
import dayjs from 'dayjs';
import classNames from 'classnames';
import { usePlasmicCanvasContext, DataProvider, repeatedElement, usePlasmicLink, useSelector, GlobalActionsProvider } from '@plasmicapp/host';
import uniqueId from 'lodash/uniqueId';
import registerToken from '@plasmicapp/host/registerToken';
import { addLoadingStateListener } from '@plasmicapp/query';
import enUS from 'antd/lib/locale/en_US.js';
import kebabCase from 'lodash/kebabCase';
import localeData from 'dayjs/plugin/localeData';
import weekday from 'dayjs/plugin/weekday';

function makeRegisterGlobalContext(component, meta) {
  return function(loader) {
    if (loader) {
      loader.registerGlobalContext(component, meta);
    } else {
      registerGlobalContext(component, meta);
    }
  };
}
function registerComponentHelper(loader, component, meta) {
  if (loader) {
    loader.registerComponent(component, meta);
  } else {
    registerComponent(component, meta);
  }
}
function traverseReactEltTree(children, callback) {
  const rec = (elts) => {
    (Array.isArray(elts) ? elts : [elts]).forEach((elt) => {
      var _a;
      if (elt) {
        callback(elt);
        if (elt.children) {
          rec(elt.children);
        }
        if (((_a = elt.props) == null ? void 0 : _a.children) && elt.props.children !== elt.children) {
          rec(elt.props.children);
        }
      }
    });
  };
  rec(children);
}
function asArray(x) {
  if (Array.isArray(x)) {
    return x;
  } else if (x == null) {
    return [];
  } else {
    return [x];
  }
}
function omit(obj, ...keys) {
  if (Object.keys(obj).length === 0) {
    return obj;
  }
  const res = {};
  for (const key of Object.keys(obj)) {
    if (!keys.includes(key)) {
      res[key] = obj[key];
    }
  }
  return res;
}
function usePrevious(value) {
  const prevValue = React.useRef(void 0);
  React.useEffect(() => {
    prevValue.current = value;
    return () => {
      prevValue.current = void 0;
    };
  });
  return prevValue.current;
}
function capitalize(value) {
  return value[0].toUpperCase() + value.slice(1);
}
function ensureArray(x) {
  return Array.isArray(x) ? x : [x];
}
function setFieldsToUndefined(obj) {
  if (typeof obj === "object" && obj !== null) {
    for (const key in obj) {
      if (typeof obj[key] === "object") {
        setFieldsToUndefined(obj[key]);
      }
      obj[key] = void 0;
    }
  }
}
function arrayEq(xs, ys) {
  return xs.length === ys.length && xs.every((x, i) => x === ys[i]);
}
class ErrorBoundary extends React.Component {
  constructor() {
    super(...arguments);
    this.state = { hasError: false, errorInfo: "" };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, errorInfo: error.message };
  }
  componentDidCatch(error, errorInfo) {
    console.log(error, errorInfo);
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.canvasEnvId !== this.props.canvasEnvId && prevState.hasError) {
      this.setState({ hasError: false });
    }
  }
  render() {
    var _a;
    if (this.state.hasError) {
      return /* @__PURE__ */ React.createElement(
        Result,
        {
          status: "error",
          title: (_a = this.props.message) != null ? _a : "Something went wrong.",
          extra: this.state.errorInfo
        }
      );
    }
    return this.props.children;
  }
}
function isUnsafeKey(key) {
  return Array.isArray(key) && key[0] === "__proto__" || key === "__proto__" || key === "constructor" || key === "prototype";
}
function get(obj, path) {
  const keys = Array.isArray(path) ? path : path.split(".");
  let i;
  for (i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!obj || !Object.hasOwn(obj, key) || isUnsafeKey(key)) {
      obj = void 0;
      break;
    }
    obj = obj[key];
  }
  return obj;
}
function set(obj, path, value) {
  const keys = Array.isArray(path) ? path : path.split(".");
  let i;
  for (i = 0; i < keys.length - 1; i++) {
    const key = keys[i];
    if (isUnsafeKey(key))
      return;
    if (!Object.hasOwn(obj, key)) {
      if (!isNaN(Number(keys[i + 1]))) {
        obj[key] = [];
      } else {
        obj[key] = {};
      }
    }
    obj = obj[key];
  }
  obj[keys[i]] = value;
  return value;
}
function pick(obj, ...paths) {
  if (Object.keys(obj).length === 0) {
    return obj;
  }
  const res = {};
  for (const path of paths) {
    set(res, path, get(obj, path));
  }
  return res;
}

const PathContext = React.createContext({ relativePath: [], fullPath: [] });
const useFormItemRelativeName = (name) => {
  const pathCtx = React.useContext(PathContext);
  return typeof name === "object" ? [...pathCtx.relativePath, ...name] : typeof name === "string" ? [...pathCtx.relativePath, name] : void 0;
};
const useFormItemFullName = (name) => {
  const pathCtx = React.useContext(PathContext);
  return typeof name === "object" ? [...pathCtx.fullPath, ...name] : typeof name === "string" ? [...pathCtx.fullPath, name] : void 0;
};
function useFormInstanceMaybe() {
  return Form.useFormInstance();
}
const InternalFormInstanceContext = React.createContext(void 0);
const FormLayoutContext = React.createContext(void 0);

var __defProp$A = Object.defineProperty;
var __defProps$o = Object.defineProperties;
var __getOwnPropDescs$o = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$A = Object.getOwnPropertySymbols;
var __hasOwnProp$A = Object.prototype.hasOwnProperty;
var __propIsEnum$A = Object.prototype.propertyIsEnumerable;
var __defNormalProp$A = (obj, key, value) => key in obj ? __defProp$A(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$A = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$A.call(b, prop))
      __defNormalProp$A(a, prop, b[prop]);
  if (__getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(b)) {
      if (__propIsEnum$A.call(b, prop))
        __defNormalProp$A(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$o = (a, b) => __defProps$o(a, __getOwnPropDescs$o(b));
var __objRest$p = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$A.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$A.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var InputType = /* @__PURE__ */ ((InputType2) => {
  InputType2["Text"] = "Text";
  InputType2["TextArea"] = "Text Area";
  InputType2["Password"] = "Password";
  InputType2["Number"] = "Number";
  InputType2["Select"] = "Select";
  InputType2["Option"] = "Option";
  InputType2["OptionGroup"] = "Option Group";
  InputType2["Radio"] = "Radio";
  InputType2["RadioGroup"] = "Radio Group";
  InputType2["Checkbox"] = "Checkbox";
  InputType2["DatePicker"] = "DatePicker";
  InputType2["Unknown"] = "Unkown";
  return InputType2;
})(InputType || {});
const SchemaFormContext = React.createContext(void 0);
var FormType = /* @__PURE__ */ ((FormType2) => {
  FormType2[FormType2["NewEntry"] = 0] = "NewEntry";
  FormType2[FormType2["UpdateEntry"] = 1] = "UpdateEntry";
  return FormType2;
})(FormType || {});
const Internal = React.forwardRef(
  (props, ref) => {
    var _b, _c, _d, _e;
    const [isSubmitting, setIsSubmitting] = React.useState(false);
    const [form] = Form.useForm();
    const values = form.getFieldsValue(true);
    const lastValue = React.useRef(values);
    const _a = props, {
      extendedOnValuesChange,
      forceRemount,
      formLayout,
      internalFieldCtx,
      setInternalFieldCtx,
      autoDisableWhileSubmitting = true
    } = _a, rest = __objRest$p(_a, [
      "extendedOnValuesChange",
      "forceRemount",
      "formLayout",
      "internalFieldCtx",
      "setInternalFieldCtx",
      "autoDisableWhileSubmitting"
    ]);
    const childrenNode = typeof props.children === "function" ? props.children(values, form) : props.children;
    const fireOnValuesChange = React.useCallback(() => {
      const values2 = form.getFieldsValue(true);
      if (!equal(values2, lastValue.current)) {
        extendedOnValuesChange == null ? void 0 : extendedOnValuesChange(values2);
        lastValue.current = values2;
      }
    }, [form, lastValue]);
    React.useEffect(() => {
      fireOnValuesChange();
    }, []);
    React.useImperativeHandle(ref, () => ({
      formInstance: form,
      setFieldsValue: (newValues) => {
        form.setFieldsValue(newValues);
        extendedOnValuesChange == null ? void 0 : extendedOnValuesChange(form.getFieldsValue(true));
      },
      setFieldValue: (namePath, value) => {
        form.setFieldValue(namePath, value);
        extendedOnValuesChange == null ? void 0 : extendedOnValuesChange(form.getFieldsValue(true));
      },
      resetFields: () => {
        form.resetFields();
        extendedOnValuesChange == null ? void 0 : extendedOnValuesChange(form.getFieldsValue(true));
      },
      validateFields: async (...args) => {
        try {
          return await form.validateFields(...args);
        } catch (err) {
          return err;
        }
      },
      clearFields: () => {
        const values2 = form.getFieldsValue(true);
        setFieldsToUndefined(values2);
        form.setFieldsValue(values2);
        extendedOnValuesChange == null ? void 0 : extendedOnValuesChange(form.getFieldsValue(true));
      }
    }));
    const registerField = React.useCallback(
      (fieldEntity) => {
        setInternalFieldCtx((ctx) => ({
          registeredFields: [...ctx.registeredFields, fieldEntity],
          preservedRegisteredFields: [
            ...ctx.preservedRegisteredFields,
            fieldEntity
          ]
        }));
        return () => {
          setInternalFieldCtx((ctx) => ({
            registeredFields: ctx.registeredFields.filter(
              (ent) => ent !== fieldEntity
            ),
            preservedRegisteredFields: ctx.preservedRegisteredFields.filter(
              (ent) => ent !== fieldEntity || fieldEntity.preserve
            )
          }));
        };
      },
      [setInternalFieldCtx]
    );
    const schemaFormCtx = React.useContext(SchemaFormContext);
    (_b = props.setControlContextData) == null ? void 0 : _b.call(props, __spreadValues$A({
      formInstance: form,
      layout: formLayout,
      internalFieldCtx
    }, schemaFormCtx ? schemaFormCtx : {}));
    const updateIsSubmitting = React.useCallback(
      (newValue) => {
        var _a2;
        setIsSubmitting(newValue);
        (_a2 = props.onIsSubmittingChange) == null ? void 0 : _a2.call(props, newValue);
      },
      [props.onIsSubmittingChange, setIsSubmitting]
    );
    return /* @__PURE__ */ React.createElement(
      InternalFormInstanceContext.Provider,
      {
        value: {
          layout: formLayout,
          fireOnValuesChange,
          forceRemount,
          registerField,
          internalFieldCtx,
          initialValues: (_c = props.initialValues) != null ? _c : {}
        }
      },
      /* @__PURE__ */ React.createElement(FormLayoutContext.Provider, { value: formLayout }, /* @__PURE__ */ React.createElement(
        Form,
        __spreadProps$o(__spreadValues$A({}, rest), {
          key: props.initialValues ? JSON.stringify(props.initialValues) : void 0,
          onValuesChange: (...args) => {
            var _a2;
            (_a2 = props.onValuesChange) == null ? void 0 : _a2.call(props, ...args);
            extendedOnValuesChange == null ? void 0 : extendedOnValuesChange(form.getFieldsValue(true));
          },
          onFinish: async () => {
            var _a2;
            if (isSubmitting && autoDisableWhileSubmitting) {
              return;
            }
            updateIsSubmitting(true);
            const submission = (_a2 = props.onFinish) == null ? void 0 : _a2.call(
              props,
              pick(
                form.getFieldsValue(true),
                ...internalFieldCtx.preservedRegisteredFields.map(
                  (field) => field.fullPath
                )
              )
            );
            if (typeof submission === "object" && typeof submission.then === "function") {
              await submission;
            }
            updateIsSubmitting(false);
          },
          form,
          labelCol: ((_d = props.labelCol) == null ? void 0 : _d.horizontalOnly) && props.layout !== "horizontal" ? void 0 : props.labelCol,
          wrapperCol: ((_e = props.wrapperCol) == null ? void 0 : _e.horizontalOnly) && props.layout !== "horizontal" ? void 0 : props.wrapperCol,
          disabled: isSubmitting && autoDisableWhileSubmitting
        }),
        /* @__PURE__ */ React.createElement("style", null, `
          .ant-form-item-explain + div, .ant-form-item-margin-offset {
            display: none;
          }
          `),
        childrenNode
      ))
    );
  }
);
const FormWrapper = React.forwardRef(
  (props, ref) => {
    var _a;
    const [remountKey, setRemountKey] = React.useState(0);
    const forceRemount = React.useCallback(
      () => setRemountKey((k) => k + 1),
      [setRemountKey]
    );
    const previousInitialValues = usePrevious(props.initialValues);
    const wrapperRef = React.useRef(null);
    React.useEffect(() => {
      if (previousInitialValues !== props.initialValues && JSON.stringify(previousInitialValues) !== JSON.stringify(props.initialValues)) {
        forceRemount();
      }
    }, [previousInitialValues, props.initialValues]);
    const [internalFieldCtx, setInternalFieldCtx] = React.useState({
      registeredFields: [],
      preservedRegisteredFields: []
    });
    React.useImperativeHandle(
      ref,
      () => wrapperRef.current ? __spreadValues$A({}, wrapperRef.current) : {}
    );
    const formLayout = React.useMemo(
      () => {
        var _a2;
        return {
          layout: props.layout,
          labelSpan: (_a2 = props.labelCol) == null ? void 0 : _a2.span
        };
      },
      [props.layout, (_a = props.labelCol) == null ? void 0 : _a.span]
    );
    return /* @__PURE__ */ React.createElement(
      Internal,
      __spreadValues$A({
        key: remountKey,
        forceRemount,
        formLayout,
        internalFieldCtx,
        setInternalFieldCtx,
        ref: wrapperRef
      }, props)
    );
  }
);
const formHelpers = {
  states: {
    value: {
      onMutate: (value, $ref) => {
        var _a;
        (_a = $ref == null ? void 0 : $ref.formInstance) == null ? void 0 : _a.setFieldsValue(value);
      }
    }
  }
};
const OPTIMIZED_FORM_IMPORT = {
  name: "FormWrapper",
  path: "@plasmicpkgs/antd5/skinny/Form"
};

const inputComponentName = "plasmic-antd5-input";
const passwordComponentName = "plasmic-antd5-input-password";
const inputNumberComponentName = "plasmic-antd5-input-number";
const textAreaComponentName = "plasmic-antd5-textarea";
const switchComponentName = "plasmic-antd5-switch";
const selectComponentName = "plasmic-antd5-select";
const optionComponentName = "plasmic-antd5-option";
const optionGroupComponentName = "plasmic-antd5-option-group";
const checkboxComponentName = "plasmic-antd5-checkbox";
const checkboxGroupComponentName = "plasmic-antd5-checkbox-group";
const radioComponentName = "plasmic-antd5-radio";
const radioButtonComponentName = "plasmic-antd5-radio-button";
const radioGroupComponentName = "plasmic-antd5-radio-group";
const formListComponentName = "plasmic-antd5-form-list";
const formComponentName = "plasmic-antd5-form";
const formGroupComponentName = "plasmic-antd5-form-group";
const formItemComponentName = "plasmic-antd5-form-item";
const buttonComponentName = "plasmic-antd5-button";

var __defProp$z = Object.defineProperty;
var __defProps$n = Object.defineProperties;
var __getOwnPropDescs$n = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$z = Object.getOwnPropertySymbols;
var __hasOwnProp$z = Object.prototype.hasOwnProperty;
var __propIsEnum$z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$z = (obj, key, value) => key in obj ? __defProp$z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$z = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$z.call(b, prop))
      __defNormalProp$z(a, prop, b[prop]);
  if (__getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(b)) {
      if (__propIsEnum$z.call(b, prop))
        __defNormalProp$z(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$n = (a, b) => __defProps$n(a, __getOwnPropDescs$n(b));
var __objRest$o = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$z.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$z.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdCheckbox(props) {
  const _a = props, { onChange } = _a, rest = __objRest$o(_a, ["onChange"]);
  const wrappedOnChange = React.useMemo(() => {
    if (onChange) {
      return (event) => onChange(event.target.checked);
    } else {
      return void 0;
    }
  }, [onChange]);
  return /* @__PURE__ */ React.createElement(Checkbox, __spreadProps$n(__spreadValues$z({}, rest), { onChange: wrappedOnChange }));
}
AntdCheckbox.__plasmicFormFieldMeta = { valueProp: "checked" };
const AntdCheckboxGroup = Checkbox.Group;
function registerCheckbox(loader) {
  registerComponentHelper(loader, AntdCheckbox, {
    name: checkboxComponentName,
    displayName: "Checkbox",
    props: {
      checked: {
        type: "boolean",
        editOnly: true,
        uncontrolledProp: "defaultChecked",
        description: "Specifies the initial state: whether or not the checkbox is selected",
        defaultValueHint: false,
        hidden: (ps) => !!ps.__plasmicFormField
      },
      disabled: {
        type: "boolean",
        description: "If checkbox is disabled",
        defaultValueHint: false
      },
      indeterminate: {
        type: "boolean",
        description: "The indeterminate checked state of checkbox",
        defaultValueHint: false
      },
      autoFocus: {
        type: "boolean",
        description: "If get focus when component mounted",
        defaultValueHint: false,
        advanced: true
      },
      children: __spreadValues$z({
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Checkbox"
          }
        ]
      }, { mergeWithParent: true }),
      onChange: {
        type: "eventHandler",
        argTypes: [{ name: "checked", type: "boolean" }]
      }
    },
    states: {
      checked: {
        type: "writable",
        valueProp: "checked",
        onChangeProp: "onChange",
        variableType: "boolean",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerCheckbox",
    importName: "AntdCheckbox"
  });
  registerComponentHelper(loader, AntdCheckboxGroup, {
    name: checkboxGroupComponentName,
    displayName: "Checkbox Group",
    props: {
      value: {
        type: "choice",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "Default selected value",
        multiSelect: true,
        options: (ps) => {
          const options = /* @__PURE__ */ new Set();
          traverseReactEltTree(ps.children, (elt) => {
            var _a;
            if ((elt == null ? void 0 : elt.type) === AntdCheckbox && typeof ((_a = elt == null ? void 0 : elt.props) == null ? void 0 : _a.value) === "string") {
              options.add(elt.props.value);
            }
          });
          return Array.from(options.keys());
        }
      },
      disabled: {
        type: "boolean",
        description: "Disables all checkboxes",
        defaultValueHint: false
      },
      children: {
        type: "slot",
        allowedComponents: [checkboxComponentName]
        // Error right now when using default slot content with stateful instances
        // defaultValue: [
        //   {
        //     type: "component",
        //     name: "plasmic-antd5-checkbox",
        //   },
        // ],
      },
      onChange: {
        type: "eventHandler",
        argTypes: [{ name: "value", type: "object" }]
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "boolean",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerCheckbox",
    importName: "AntdCheckboxGroup",
    parentComponentName: checkboxComponentName
  });
}

var __defProp$y = Object.defineProperty;
var __defProps$m = Object.defineProperties;
var __getOwnPropDescs$m = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$y = Object.getOwnPropertySymbols;
var __hasOwnProp$y = Object.prototype.hasOwnProperty;
var __propIsEnum$y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$y = (obj, key, value) => key in obj ? __defProp$y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$y = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$y.call(b, prop))
      __defNormalProp$y(a, prop, b[prop]);
  if (__getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(b)) {
      if (__propIsEnum$y.call(b, prop))
        __defNormalProp$y(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$m = (a, b) => __defProps$m(a, __getOwnPropDescs$m(b));
var __objRest$n = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$y.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$y.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdDatePicker(props) {
  const _a = props, { picker, popupScopeClassName } = _a, rest = __objRest$n(_a, ["picker", "popupScopeClassName"]);
  const css = `

  @media(max-width: 500px) {
    .ant-picker-dropdown {
      top: 20px !important;
      left: 10px !important;
      right: 10px !important;
      max-height: 95vh;
      position: fixed;
      overflow-y: scroll;
    }

    .ant-picker-panel-layout {
      flex-direction: column;
    }

    .ant-picker-presets {
      min-height: 50px;
      min-width: 100%;
    }

    .ant-picker-presets > ul {
      overflow-y: hidden;
      overflow-x: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      flex-direction: column;
    }

    .ant-picker-presets > ul > li {
      margin: 0 !important;
    }

    .ant-picker-panel-container {
      width: 300px;
    }

    .ant-picker-datetime-panel {
      flex-direction: column;
    }

    .ant-picker-header-view {
      line-height: unset !important;
    }

    .ant-picker-content {
      height: unset !important;
    }

    .ant-picker-time-panel-column {
      height: 100px;
    }

    .ant-picker-time-panel-column::after {
      height: 0px !important;
    }

    .ant-picker-time-panel-column::after {
      display: none;
    }
  }`;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    DatePicker,
    __spreadProps$m(__spreadValues$y({}, rest), {
      picker,
      value: props.value === void 0 ? void 0 : !props.value ? null : dayjs(props.value),
      defaultValue: props.defaultValue === void 0 ? void 0 : dayjs(props.defaultValue),
      popupClassName: popupScopeClassName,
      onChange: (value, _dateString) => {
        var _a2;
        (_a2 = props.onChange) == null ? void 0 : _a2.call(props, value !== null ? value.toISOString() : null);
      }
    })
  ), /* @__PURE__ */ React.createElement("style", { dangerouslySetInnerHTML: { __html: css } }));
}
const datePickerComponentName = "plasmic-antd5-date-picker";
const datePickerHelpers = {
  states: {
    value: {
      onChangeArgsToValue: (value) => value ? value : void 0,
      hidden: (ps) => !!ps.__plasmicFormField
    }
  }
};
function registerDatePicker(loader) {
  registerComponentHelper(loader, AntdDatePicker, {
    name: datePickerComponentName,
    displayName: "Date/Time Picker",
    props: {
      value: {
        type: "dateString",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "The current date/time as an ISO string, Date object, or dayjs object",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false
      },
      autoFocus: {
        type: "boolean",
        description: "Focus when component is rendered",
        defaultValueHint: false,
        advanced: true
      },
      onChange: {
        type: "eventHandler",
        argTypes: [{ name: "value", type: "string" }]
      },
      picker: {
        type: "choice",
        options: ["date", "week", "month", "quarter", "year"].map((value) => ({
          value,
          label: capitalize(value)
        })),
        defaultValueHint: "date"
      },
      popupScopeClassName: {
        type: "styleScopeClass",
        scopeName: "datePickerPopup"
      },
      popupClassName: {
        type: "class",
        displayName: "Popup container",
        selectors: [
          {
            selector: ":datePickerPopup .ant-picker-panel-container",
            label: "Base"
          }
        ]
      },
      popupHeaderClassName: {
        type: "class",
        displayName: "Popup header",
        selectors: [
          {
            selector: ":datePickerPopup .ant-picker-header",
            label: "Base"
          }
        ]
      },
      popupBodyClassName: {
        type: "class",
        displayName: "Popup body",
        selectors: [
          {
            selector: ":datePickerPopup .ant-picker-body",
            label: "Base"
          }
        ]
      },
      popupFooterClassName: {
        type: "class",
        displayName: "Popup footer",
        selectors: [
          {
            selector: ":datePickerPopup .ant-picker-footer",
            label: "Base"
          }
        ]
      },
      showTime: {
        type: "boolean",
        description: "Enable time selection"
      },
      bordered: {
        type: "boolean",
        advanced: true
      },
      // TODO - see how it works with plasmic-rich-components
      // format: {
      //   advanced: true
      // },
      showNow: {
        type: "boolean",
        advanced: true,
        description: 'Whether to show the "Now" button',
        defaultValueHint: true,
        hidden: (ps) => !ps.showTime
      },
      showToday: {
        type: "boolean",
        advanced: true,
        description: 'Whether to show the "Today" button',
        defaultValueHint: true,
        hidden: (ps) => ps.showTime
      },
      // disabledDate: {
      //   type: "function",
      //   advanced: true,
      //   description: "Dates to disable",
      // },
      // disabledTime: {
      //   type: "function",
      //   advanced: true,
      //   description: "Times to disable",
      // },
      allowClear: {
        type: "boolean",
        advanced: true,
        description: "Whether to show the clear button"
      }
    },
    states: {
      value: __spreadValues$y({
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text"
      }, datePickerHelpers.states.value)
    },
    componentHelpers: {
      helpers: datePickerHelpers,
      importName: "datePickerHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerDatePicker"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerDatePicker",
    importName: "AntdDatePicker"
  });
}

var __defProp$x = Object.defineProperty;
var __defProps$l = Object.defineProperties;
var __getOwnPropDescs$l = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$x = Object.getOwnPropertySymbols;
var __hasOwnProp$x = Object.prototype.hasOwnProperty;
var __propIsEnum$x = Object.prototype.propertyIsEnumerable;
var __defNormalProp$x = (obj, key, value) => key in obj ? __defProp$x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$x = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$x.call(b, prop))
      __defNormalProp$x(a, prop, b[prop]);
  if (__getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(b)) {
      if (__propIsEnum$x.call(b, prop))
        __defNormalProp$x(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$l = (a, b) => __defProps$l(a, __getOwnPropDescs$l(b));
var __objRest$m = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$x.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$x.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const RadioGroup = Radio.Group;
const AntdRadio = Radio;
const AntdRadioButton = Radio.Button;
function AntdRadioGroup(props) {
  const _a = props, { onChange, useChildren } = _a, rest = __objRest$m(_a, ["onChange", "useChildren"]);
  const wrappedOnChange = React.useMemo(() => {
    if (onChange) {
      return (event) => onChange(event.target.value);
    } else {
      return void 0;
    }
  }, [onChange]);
  return /* @__PURE__ */ React.createElement(
    RadioGroup,
    __spreadProps$l(__spreadValues$x({}, rest), {
      onChange: wrappedOnChange,
      options: useChildren ? void 0 : rest.options
    })
  );
}
function registerRadio(loader) {
  registerComponentHelper(loader, AntdRadio, {
    name: radioComponentName,
    displayName: "Radio",
    props: {
      value: {
        type: "string",
        description: "The radio option value"
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false
      },
      autoFocus: {
        type: "boolean",
        description: "If focused when first shown",
        defaultValueHint: false,
        advanced: true
      },
      children: __spreadValues$x({
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Radio"
          }
        ]
      }, { mergeWithParent: true })
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerRadio",
    importName: "AntdRadio",
    parentComponentName: radioGroupComponentName
  });
  registerComponentHelper(loader, AntdRadioButton, {
    name: radioButtonComponentName,
    displayName: "Radio Button",
    props: {
      value: {
        type: "string",
        description: "The radio option value"
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false
      },
      autoFocus: {
        type: "boolean",
        description: "If focused when first shown",
        defaultValueHint: false,
        advanced: true
      },
      children: __spreadValues$x({
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Radio"
          }
        ]
      }, { mergeWithParent: true })
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerRadio",
    importName: "AntdRadioButton",
    parentComponentName: radioGroupComponentName
  });
  registerComponentHelper(loader, AntdRadioGroup, __spreadValues$x({
    name: radioGroupComponentName,
    displayName: "Radio Group",
    props: {
      options: {
        type: "array",
        hidden: (ps) => !!ps.useChildren,
        itemType: {
          type: "object",
          nameFunc: (item) => item.label || item.value,
          fields: {
            value: "string",
            label: "string"
          }
        },
        defaultValue: [
          {
            value: "option1",
            label: "Option 1"
          },
          {
            value: "option2",
            label: "Option 2"
          }
        ]
      },
      optionType: {
        type: "choice",
        options: [
          { value: "default", label: "Radio" },
          { value: "button", label: "Button" }
        ],
        hidden: (ps) => !!ps.useChildren,
        defaultValueHint: "default"
      },
      value: {
        type: "choice",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "Default selected value",
        options: (ps) => {
          var _a;
          if (ps.useChildren) {
            const options = /* @__PURE__ */ new Set();
            traverseReactEltTree(ps.children, (elt) => {
              var _a2;
              if (typeof ((_a2 = elt == null ? void 0 : elt.props) == null ? void 0 : _a2.value) === "string") {
                options.add(elt.props.value);
              }
            });
            return Array.from(options.keys());
          } else {
            return (_a = ps.options) != null ? _a : [];
          }
        },
        hidden: (ps) => !!ps.__plasmicFormField
      },
      disabled: {
        type: "boolean",
        description: "Disables all radios",
        defaultValueHint: false
      },
      useChildren: {
        displayName: "Use slot",
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: "Instead of configuring a list of options, customize the contents of the RadioGroup by dragging and dropping Radio in the outline/canvas, inside the 'children' slot. Lets you use any content or formatting within the Radio and RadioButton."
      },
      children: {
        type: "slot",
        allowedComponents: [
          "plasmic-antd5-radio",
          "plasmic-antd5-radio-button"
        ],
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-radio",
            props: {
              value: "op1",
              children: {
                type: "text",
                value: "Option 1"
              }
            }
          },
          {
            type: "component",
            name: "plasmic-antd5-radio",
            props: {
              value: "op2",
              children: {
                type: "text",
                value: "Option 2"
              }
            }
          }
        ]
      },
      onChange: {
        type: "eventHandler",
        argTypes: [{ name: "value", type: "string" }]
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerRadio",
    importName: "AntdRadioGroup",
    defaultStyles: {
      layout: "hbox"
    }
  }, {
    trapsSelection: true
  }));
}

var __defProp$w = Object.defineProperty;
var __getOwnPropSymbols$w = Object.getOwnPropertySymbols;
var __hasOwnProp$w = Object.prototype.hasOwnProperty;
var __propIsEnum$w = Object.prototype.propertyIsEnumerable;
var __defNormalProp$w = (obj, key, value) => key in obj ? __defProp$w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$w = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$w.call(b, prop))
      __defNormalProp$w(a, prop, b[prop]);
  if (__getOwnPropSymbols$w)
    for (var prop of __getOwnPropSymbols$w(b)) {
      if (__propIsEnum$w.call(b, prop))
        __defNormalProp$w(a, prop, b[prop]);
    }
  return a;
};
const isBrowser = typeof window !== "undefined";
const NONE = Symbol("NONE");
isBrowser ? React.useLayoutEffect : React.useEffect;
function mergeProps(props, ...restProps) {
  if (restProps.every((rest) => Object.keys(rest).length === 0)) {
    return props;
  }
  const result = __spreadValues$w({}, props);
  for (const rest of restProps) {
    for (const key of Object.keys(rest)) {
      result[key] = mergePropVals(key, result[key], rest[key]);
    }
  }
  return result;
}
function updateRef(ref, value) {
  if (!ref) {
    return;
  }
  if (typeof ref === "function") {
    ref(value);
  } else {
    if (!Object.isFrozen(ref)) {
      ref.current = value;
    }
  }
}
function mergeRefs(...refs) {
  return (value) => {
    for (const ref of refs) {
      updateRef(ref, value);
    }
  };
}
function mergePropVals(name, val1, val2) {
  if (val1 === NONE || val2 === NONE) {
    return null;
  } else if (val1 == null) {
    return val2;
  } else if (val2 == null) {
    return val1;
  } else if (name === "className") {
    return classNames(val1, val2);
  } else if (name === "style") {
    return __spreadValues$w(__spreadValues$w({}, val1), val2);
  } else if (name === "ref") {
    return mergeRefs(val1, val2);
  } else if (typeof val1 !== typeof val2) {
    return val2;
  } else if (name.startsWith("on") && typeof val1 === "function") {
    return (...args) => {
      let res;
      if (typeof val1 === "function") {
        res = val1(...args);
      }
      if (typeof val2 === "function") {
        res = val2(...args);
      }
      return res;
    };
  } else {
    return val2;
  }
}
function reactNodeToString(reactNode) {
  let string = "";
  if (typeof reactNode === "string") {
    string = reactNode;
  } else if (typeof reactNode === "number") {
    string = reactNode.toString();
  } else if (reactNode instanceof Array) {
    reactNode.forEach(function(child) {
      string += reactNodeToString(child);
    });
  } else if (isValidElement(reactNode)) {
    string += reactNodeToString(reactNode.props.children);
  }
  return string;
}
function useIsMounted() {
  const ref = React.useRef(false);
  const isMounted = React.useCallback(() => ref.current, []);
  React.useEffect(() => {
    ref.current = true;
    return () => {
      ref.current = false;
    };
  }, []);
  return isMounted;
}

var __defProp$v = Object.defineProperty;
var __defProps$k = Object.defineProperties;
var __getOwnPropDescs$k = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$v = Object.getOwnPropertySymbols;
var __hasOwnProp$v = Object.prototype.hasOwnProperty;
var __propIsEnum$v = Object.prototype.propertyIsEnumerable;
var __defNormalProp$v = (obj, key, value) => key in obj ? __defProp$v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$v = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$v.call(b, prop))
      __defNormalProp$v(a, prop, b[prop]);
  if (__getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(b)) {
      if (__propIsEnum$v.call(b, prop))
        __defNormalProp$v(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$k = (a, b) => __defProps$k(a, __getOwnPropDescs$k(b));
var __objRest$l = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$v.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$v.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const AntdOption = Select.Option;
const AntdOptionGroup = Select.OptGroup;
function AntdSelect(props) {
  const _a = props, {
    popupClassName,
    popupScopeClassName,
    defaultStylesClassName,
    suffixIcon,
    mode,
    useChildren
  } = _a, rest = __objRest$l(_a, [
    "popupClassName",
    "popupScopeClassName",
    "defaultStylesClassName",
    "suffixIcon",
    "mode",
    "useChildren"
  ]);
  const curated = __spreadValues$v({}, rest);
  if (useChildren) {
    curated.options = void 0;
  }
  return /* @__PURE__ */ React.createElement(
    Select,
    __spreadValues$v(__spreadProps$k(__spreadValues$v({}, curated), {
      mode: !mode || mode === "single" ? void 0 : mode,
      popupClassName: `${defaultStylesClassName} ${popupScopeClassName} ${popupClassName}`,
      optionFilterProp: curated.options ? "label" : void 0,
      filterOption: (input, option) => {
        var _a2;
        return (useChildren ? reactNodeToString(option == null ? void 0 : option.children) : (_a2 = option == null ? void 0 : option.label) != null ? _a2 : "").toLowerCase().includes(input.toLowerCase());
      }
    }), suffixIcon && { suffixIcon })
  );
}
function registerSelect(loader) {
  registerComponentHelper(loader, AntdSelect, __spreadProps$k(__spreadValues$v({
    name: selectComponentName,
    displayName: "Select",
    props: {
      options: {
        type: "array",
        hidden: (ps) => !!ps.useChildren,
        itemType: {
          type: "object",
          nameFunc: (item) => item.label || item.value,
          fields: {
            type: {
              type: "choice",
              options: [
                { value: "option", label: "Option" },
                { value: "option-group", label: "Option Group" }
              ],
              defaultValue: "option"
            },
            value: {
              type: "string",
              hidden: (_ps, _ctx, { item }) => item.type !== "option"
            },
            label: "string",
            options: {
              type: "array",
              hidden: (_ps, _ctx, { item }) => {
                return item.type !== "option-group";
              },
              itemType: {
                type: "object",
                nameFunc: (item) => item.label || item.value,
                fields: {
                  value: "string",
                  label: "string"
                }
              }
            }
          }
        },
        defaultValue: [
          {
            value: "option1",
            label: "Option 1",
            type: "option"
          },
          {
            value: "option2",
            label: "Option 2",
            type: "option"
          }
        ]
      },
      useChildren: {
        displayName: "Use slot",
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: "Instead of configuring a list of options, customize the contents of the Select by dragging and dropping options in the outline/canvas, inside the 'children' slot. Lets you use any content or formatting within the Options, and also use Option Groups."
      },
      children: {
        type: "slot",
        allowedComponents: [optionComponentName, optionGroupComponentName],
        hidden: (ps) => !ps.useChildren
      },
      placeholder: {
        type: "slot",
        defaultValue: "Select..."
      },
      suffixIcon: {
        type: "slot",
        hidePlaceholder: true
      },
      open: {
        type: "boolean",
        editOnly: true,
        uncontrolledProp: "defaultOpen"
      },
      value: {
        type: "choice",
        displayName: "Selected value",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "Initial selected option",
        multiSelect: (ps) => ps.mode === "multiple",
        options: (ps) => {
          var _a;
          const options = /* @__PURE__ */ new Set();
          if (!ps.useChildren) {
            const rec = (op) => {
              var _a2;
              if (typeof op === "string") {
                return [{ value: op, label: op }];
              } else if ("options" in op) {
                return ((_a2 = op.options) != null ? _a2 : []).flatMap((sub) => rec(sub));
              } else {
                return [{ value: op.value, label: op.label || op.value }];
              }
            };
            return ((_a = ps.options) != null ? _a : []).flatMap((o) => rec(o));
          } else {
            traverseReactEltTree(ps.children, (elt) => {
              var _a2;
              if ((elt == null ? void 0 : elt.type) === Select.Option && typeof ((_a2 = elt == null ? void 0 : elt.props) == null ? void 0 : _a2.value) === "string") {
                options.add(elt.props.value);
              }
            });
          }
          return Array.from(options.keys());
        },
        hidden: (ps) => !!ps.__plasmicFormField
      },
      mode: {
        type: "choice",
        options: ["single", "multiple", "tags"],
        defaultValueHint: "single",
        description: "Whether to allow single or multiple selection. Tags mode additionally allows selecting options outside the specified set of options."
      },
      size: {
        type: "choice",
        options: ["small", "middle", "large"]
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false
      },
      showSearch: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true
      },
      status: {
        type: "choice",
        options: ["error", "warning"],
        advanced: true
      },
      bordered: {
        type: "boolean",
        defaultValueHint: true
      },
      autoFocus: {
        type: "boolean",
        displayName: "Focus automatically",
        defaultValueHint: false,
        advanced: true
      },
      onChange: {
        type: "eventHandler",
        argTypes: [
          { name: "value", type: "string" },
          { name: "option", type: "object" }
        ]
      },
      dropdownMatchSelectWidth: {
        type: "boolean",
        displayName: "Should dropdown match trigger button width?",
        defaultValueHint: true,
        advanced: true
      },
      allowClear: {
        type: "boolean",
        displayName: "Allow clearing the Select",
        defaultValueHint: false,
        advanced: true
      },
      triggerClassName: {
        type: "class",
        displayName: "Trigger styles",
        noSelf: true,
        selectors: [
          {
            selector: ":component .ant-select-selector.ant-select-selector",
            label: "Base"
          },
          {
            selector: ":component .ant-select-selector:hover",
            label: "Hovered"
          }
        ],
        advanced: true
      },
      popupScopeClassName: {
        type: "styleScopeClass",
        scopeName: "popup"
      },
      popupClassName: {
        type: "class",
        displayName: "Popup styles",
        selectors: [],
        advanced: true
      },
      optionClassName: {
        type: "class",
        displayName: "Option styles",
        noSelf: true,
        selectors: [
          {
            selector: ":popup.ant-select-dropdown .ant-select-item-option",
            label: "Base"
          },
          {
            selector: ":popup.ant-select-dropdown .ant-select-item-option-active",
            label: "Focused"
          },
          {
            selector: ":popup.ant-select-dropdown .ant-select-item-option-selected",
            label: "Selected"
          }
        ],
        advanced: true
      },
      placeholderClassName: {
        type: "class",
        displayName: "Placeholder styles",
        selectors: [
          {
            selector: ":component .ant-select-selector .ant-select-selection-placeholder",
            label: "Base"
          }
        ],
        advanced: true
      },
      defaultStylesClassName: {
        type: "themeResetClass"
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    }
  }, { trapsSelection: true }), {
    importPath: "@plasmicpkgs/antd5/skinny/registerSelect",
    importName: "AntdSelect"
  }));
  registerComponentHelper(loader, AntdOption, {
    name: optionComponentName,
    displayName: "Option",
    parentComponentName: selectComponentName,
    props: {
      children: __spreadValues$v({
        type: "slot",
        defaultValue: "Option"
      }, { mergeWithParent: true }),
      value: {
        type: "string"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSelect",
    importName: "AntdOption"
  });
  registerComponentHelper(loader, AntdOptionGroup, {
    name: optionGroupComponentName,
    displayName: "Option Group",
    parentComponentName: selectComponentName,
    props: {
      children: {
        type: "slot",
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-option",
            props: {
              value: "option1",
              children: {
                type: "text",
                value: "Option 1"
              }
            }
          },
          {
            type: "component",
            name: "plasmic-antd5-option",
            props: {
              value: "option2",
              children: {
                type: "text",
                value: "Option 1"
              }
            }
          }
        ]
      },
      label: {
        type: "slot",
        defaultValue: "Group label"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSelect",
    importName: "AntdOptionGroup"
  });
}

var __defProp$u = Object.defineProperty;
var __defProps$j = Object.defineProperties;
var __getOwnPropDescs$j = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$u = Object.getOwnPropertySymbols;
var __hasOwnProp$u = Object.prototype.hasOwnProperty;
var __propIsEnum$u = Object.prototype.propertyIsEnumerable;
var __defNormalProp$u = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$u = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$u.call(b, prop))
      __defNormalProp$u(a, prop, b[prop]);
  if (__getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(b)) {
      if (__propIsEnum$u.call(b, prop))
        __defNormalProp$u(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$j = (a, b) => __defProps$j(a, __getOwnPropDescs$j(b));
var __objRest$k = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$u.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$u.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const FormItem = Form.Item;
function plasmicRulesToAntdRules(plasmicRules, label) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const effectiveLabel = label || "This field";
  const rules = [];
  for (const plasmicRule of plasmicRules) {
    switch (plasmicRule.ruleType) {
      case "enum":
        rules.push({
          type: "enum",
          enum: (_b = (_a = plasmicRule.options) == null ? void 0 : _a.map((opt) => opt.value)) != null ? _b : [],
          message: (_c = plasmicRule.message) != null ? _c : `${effectiveLabel} must be a valid value`
        });
        break;
      case "required":
        rules.push({
          required: true,
          message: (_d = plasmicRule.message) != null ? _d : `${effectiveLabel} is required`
        });
        break;
      case "regex":
        rules.push({
          pattern: new RegExp((_e = plasmicRule.pattern) != null ? _e : ""),
          message: (_f = plasmicRule.message) != null ? _f : `${effectiveLabel} must be a valid value`
        });
        break;
      case "whitespace":
        rules.push({
          whitespace: true,
          message: (_g = plasmicRule.message) != null ? _g : `${effectiveLabel} is required`
        });
        break;
      case "min":
        rules.push({
          [plasmicRule.ruleType]: plasmicRule.length,
          message: (_h = plasmicRule.message) != null ? _h : `${effectiveLabel} must be at least ${plasmicRule.length} characters`
        });
        break;
      case "max":
        rules.push({
          [plasmicRule.ruleType]: plasmicRule.length,
          message: (_i = plasmicRule.message) != null ? _i : `${effectiveLabel} must be at most ${plasmicRule.length} characters`
        });
        break;
      case "advanced":
        rules.push({
          validator: (...args) => {
            var _a2;
            return ((_a2 = plasmicRule.custom) == null ? void 0 : _a2.apply(null, args)) ? Promise.resolve() : Promise.reject();
          },
          message: plasmicRule.message
        });
    }
  }
  return rules;
}
function FormItemWrapper(props) {
  var _b, _c, _d;
  const _a = props, {
    rules: plasmicRules,
    description,
    noLabel,
    name,
    hideValidationMessage,
    customizeProps,
    setControlContextData,
    alignLabellessWithControls = true
  } = _a, rest = __objRest$k(_a, [
    "rules",
    "description",
    "noLabel",
    "name",
    "hideValidationMessage",
    "customizeProps",
    "setControlContextData",
    "alignLabellessWithControls"
  ]);
  const relativeFormItemName = useFormItemRelativeName(name);
  const fullFormItemName = useFormItemFullName(name);
  const pathCtx = React.useContext(PathContext);
  const fieldEntity = React.useRef({
    preserve: (_b = props.preserve) != null ? _b : true,
    fullPath: pathCtx.fullPath,
    name
  }).current;
  const bestEffortLabel = !noLabel && reactNodeToString(props.label) || ensureArray(props.name).slice(-1)[0];
  const rules = plasmicRules ? plasmicRulesToAntdRules(
    plasmicRules,
    typeof bestEffortLabel === "number" ? "" + bestEffortLabel : bestEffortLabel
  ) : void 0;
  const layoutContext = React.useContext(FormLayoutContext);
  const inCanvas = !!usePlasmicCanvasContext();
  const {
    fireOnValuesChange,
    forceRemount,
    registerField,
    initialValues,
    internalFieldCtx
  } = (_c = React.useContext(InternalFormInstanceContext)) != null ? _c : {};
  if (inCanvas) {
    const form = useFormInstanceMaybe();
    const prevPropValues = React.useRef({
      initialValue: props.initialValue,
      name: props.name
    });
    (_d = props.setControlContextData) == null ? void 0 : _d.call(props, {
      internalFieldCtx,
      formInstance: form,
      parentFormItemPath: pathCtx.fullPath,
      layout: layoutContext
    });
    React.useEffect(() => {
      if (prevPropValues.current.name !== props.name) {
        forceRemount == null ? void 0 : forceRemount();
      }
      if (!fullFormItemName || get(initialValues, fullFormItemName) != null || props.initialValue == null) {
        return;
      }
      form == null ? void 0 : form.setFieldValue(fullFormItemName, props.initialValue);
      prevPropValues.current.initialValue = props.initialValue;
      fireOnValuesChange == null ? void 0 : fireOnValuesChange();
    }, [
      form,
      props.initialValue,
      JSON.stringify(pathCtx.fullPath),
      props.name,
      props.preserve
    ]);
  }
  React.useEffect(() => {
    var _a2;
    fieldEntity.fullPath = [
      ...pathCtx.fullPath,
      ...props.name != null ? [props.name] : []
    ];
    fieldEntity.name = props.name;
    fieldEntity.preserve = (_a2 = props.preserve) != null ? _a2 : true;
  }, [pathCtx.fullPath, props.name, props.preserve]);
  React.useEffect(() => {
    const unregister = registerField == null ? void 0 : registerField(fieldEntity);
    return () => unregister == null ? void 0 : unregister();
  }, []);
  return /* @__PURE__ */ React.createElement(
    FormItem,
    __spreadProps$j(__spreadValues$u({}, rest), {
      label: noLabel ? void 0 : props.label,
      name: relativeFormItemName,
      rules,
      extra: description,
      help: hideValidationMessage ? "" : props.help,
      colon: noLabel ? false : void 0,
      valuePropName: deriveValuePropName(props),
      trigger: deriveOnChangePropName(props),
      wrapperCol: (layoutContext == null ? void 0 : layoutContext.layout) === "horizontal" && noLabel && alignLabellessWithControls && layoutContext.labelSpan ? { offset: layoutContext.labelSpan } : void 0
    }),
    /* @__PURE__ */ React.createElement(FormItemForwarder, { formItemProps: props })
  );
}
function deriveValuePropName(props) {
  var _a;
  if (props.valuePropName) {
    return props.valuePropName;
  }
  const valueProps = ((_a = React.Children.map(props.children, (child) => {
    var _a2;
    if (React.isValidElement(child)) {
      const childType = child.type;
      if (childType) {
        const x = (_a2 = childType.__plasmicFormFieldMeta) == null ? void 0 : _a2.valueProp;
        if (x) {
          return x;
        }
        const plumeType = childType.__plumeType;
        if (plumeType && (plumeType === "checkbox" || plumeType === "switch")) {
          return "isChecked";
        }
      }
    }
    return void 0;
  })) != null ? _a : []).filter((x) => !!x);
  if (valueProps.length > 0) {
    return valueProps[0];
  }
  return void 0;
}
function deriveOnChangePropName(props) {
  var _a;
  if (props.trigger) {
    return props.trigger;
  }
  const triggerProps = ((_a = React.Children.map(props.children, (child) => {
    var _a2;
    if (React.isValidElement(child)) {
      const childType = child.type;
      if (childType) {
        const x = (_a2 = childType.__plasmicFormFieldMeta) == null ? void 0 : _a2.onChangeProp;
        if (x) {
          return x;
        }
      }
    }
    return void 0;
  })) != null ? _a : []).filter((x) => !!x);
  if (triggerProps.length > 0) {
    return triggerProps[0];
  }
  return void 0;
}
function FormItemForwarder(_a) {
  var _b = _a, { formItemProps } = _b, props = __objRest$k(_b, ["formItemProps"]);
  var _a2;
  const status = Form.Item.useStatus();
  const internalFormCtx = React.useContext(InternalFormInstanceContext);
  const data = {
    status: status.status
  };
  (_a2 = props.setControlContextData) == null ? void 0 : _a2.call(props, {
    internalFormCtx,
    status
  });
  return React.Children.map(formItemProps.children, (child, i) => {
    var _a3;
    if (i === 0 && isValidElement(child)) {
      let newProps = __spreadProps$j(__spreadValues$u(__spreadValues$u({
        name: formItemProps.name
      }, (_a3 = child.props) != null ? _a3 : {}), props), {
        __plasmicFormField: true
      });
      if (formItemProps.customizeProps) {
        newProps = mergeProps(
          newProps,
          formItemProps.customizeProps(data, newProps)
        );
      }
      return cloneElement(child, newProps);
    } else {
      return child;
    }
  });
}

var __defProp$t = Object.defineProperty;
var __defProps$i = Object.defineProperties;
var __getOwnPropDescs$i = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$t = Object.getOwnPropertySymbols;
var __hasOwnProp$t = Object.prototype.hasOwnProperty;
var __propIsEnum$t = Object.prototype.propertyIsEnumerable;
var __defNormalProp$t = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$t = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$t.call(b, prop))
      __defNormalProp$t(a, prop, b[prop]);
  if (__getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(b)) {
      if (__propIsEnum$t.call(b, prop))
        __defNormalProp$t(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$i = (a, b) => __defProps$i(a, __getOwnPropDescs$i(b));
var __objRest$j = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$t.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$t.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function deriveFormFieldConfigs(dataFormItems, schema, data) {
  return deriveFieldConfigs(
    dataFormItems,
    schema,
    (field) => {
      var _a;
      return __spreadValues$t({
        inputType: InputType.Text
      }, field && {
        key: field.id,
        fieldId: field.id,
        label: (_a = field.label) != null ? _a : field.id,
        name: field.id,
        inputType: field.type === "string" ? InputType.Text : field.type === "number" ? InputType.Number : field.type === "boolean" ? InputType.Checkbox : InputType.Text,
        //missing date and date-time
        initialValue: data ? data[field.id] : void 0
      });
    }
  );
}
function useFormItemDefinitions(rawData, props) {
  const { mode, dataFormItems, setControlContextData } = props;
  return React.useMemo(() => {
    const data = rawData && normalizeData(rawData);
    const schema = data && (data == null ? void 0 : data.schema);
    if (mode !== "simplified" || !rawData || rawData.isLoading || rawData.error || !data || !schema || !data.data) {
      return void 0;
    }
    const row = data.data.length > 0 ? data.data[0] : void 0;
    return deriveFormFieldConfigs(dataFormItems != null ? dataFormItems : [], schema, row);
  }, [mode, setControlContextData, dataFormItems, rawData]);
}
const useRawData = (props) => {
  const rawData = usePlasmicDataOp(props.data);
  return props.data ? rawData : void 0;
};
const SchemaForm = React.forwardRef(
  (props, ref) => {
    const [remountKey, setRemountKey] = React.useState(0);
    const forceRemount = React.useCallback(
      () => setRemountKey((k) => k + 1),
      [setRemountKey]
    );
    const wrapperRef = React.useRef(null);
    React.useImperativeHandle(
      ref,
      () => wrapperRef.current ? __spreadValues$t({}, wrapperRef.current) : {}
    );
    const rawData = useRawData(props);
    const formItemDefinitions = useFormItemDefinitions(rawData, props);
    React.useEffect(() => {
      if (rawData && !rawData.isLoading) {
        forceRemount();
      }
    }, [rawData]);
    const previousDataOp = usePrevious(props.data);
    React.useEffect(() => {
      if (previousDataOp == null && props.data != null || previousDataOp != null && props.data == null) {
        forceRemount();
      }
    }, [props.data]);
    const _a = props, { dataFormItems, formItems, data } = _a, rest = __objRest$j(_a, ["dataFormItems", "formItems", "data"]);
    const actualFormItems = props.mode === "simplified" && formItemDefinitions ? formItemDefinitions.mergedFields : data ? dataFormItems : formItems;
    const previousFormItems = React.useRef([]);
    React.useEffect(() => {
      if (!(rawData && rawData.isLoading)) {
        previousFormItems.current = actualFormItems != null ? actualFormItems : [];
      }
    }, [rawData, actualFormItems]);
    if (props.mode === "simplified" && rawData && "error" in rawData) {
      return /* @__PURE__ */ React.createElement("div", null, "Error when fetching data: ", rawData.error.message);
    }
    const childrenNode = props.mode === "simplified" ? /* @__PURE__ */ React.createElement(React.Fragment, null, (actualFormItems != null ? actualFormItems : []).map((formItem) => {
      var _a2, _b, _c;
      return /* @__PURE__ */ React.createElement(
        ErrorBoundary,
        {
          canvasEnvId: props["data-plasmic-canvas-envs"],
          message: `Error rendering input for ${(_b = (_a2 = formItem.label) != null ? _a2 : formItem.name) != null ? _b : "undefined"}`
        },
        /* @__PURE__ */ React.createElement(
          FormItemWrapper,
          __spreadProps$i(__spreadValues$t({}, omit(formItem, "key")), {
            noLabel: formItem.inputType === InputType.Checkbox || formItem.noLabel,
            valuePropName: (_c = formItem.valuePropName) != null ? _c : formItem.inputType === InputType.Checkbox ? "checked" : void 0,
            style: { width: "100%" }
          }),
          formItem.inputType === InputType.Text ? /* @__PURE__ */ React.createElement(Input, null) : formItem.inputType === InputType.Password ? /* @__PURE__ */ React.createElement(Input.Password, null) : formItem.inputType === InputType.TextArea ? /* @__PURE__ */ React.createElement(Input.TextArea, null) : formItem.inputType === InputType.Number ? /* @__PURE__ */ React.createElement(InputNumber, null) : formItem.inputType === InputType.Checkbox ? /* @__PURE__ */ React.createElement(AntdCheckbox, null, formItem.label) : formItem.inputType === InputType.Select ? /* @__PURE__ */ React.createElement(AntdSelect, { options: formItem.options }) : formItem.inputType === InputType.DatePicker ? /* @__PURE__ */ React.createElement(AntdDatePicker, { showTime: formItem.showTime }) : formItem.inputType === InputType.RadioGroup ? /* @__PURE__ */ React.createElement(
            AntdRadioGroup,
            {
              options: formItem.options,
              optionType: formItem.optionType,
              style: { padding: "8px" }
            }
          ) : null
        )
      );
    }), props.submitSlot) : props.children;
    const isSchemaForm = props.mode === "simplified" && !!props.data;
    const isLoadingData = rawData == null ? void 0 : rawData.isLoading;
    return /* @__PURE__ */ React.createElement(
      SchemaFormContext.Provider,
      {
        value: {
          mergedFields: formItemDefinitions == null ? void 0 : formItemDefinitions.mergedFields,
          minimalFullLengthFields: formItemDefinitions == null ? void 0 : formItemDefinitions.mergedFields,
          schema: rawData == null ? void 0 : rawData.schema
        }
      },
      /* @__PURE__ */ React.createElement(
        FormWrapper,
        __spreadProps$i(__spreadValues$t({
          key: remountKey
        }, rest), {
          children: childrenNode,
          formItems: rawData && rawData.isLoading ? previousFormItems.current : actualFormItems,
          ref: wrapperRef,
          style: isSchemaForm && isLoadingData ? {
            opacity: 0.5,
            transitionDelay: "250ms",
            transition: "1s"
          } : {}
        })
      ),
      isSchemaForm && isLoadingData && /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            position: "absolute",
            width: "100%",
            height: "100%"
          }
        }
      )
    );
  }
);

var __defProp$s = Object.defineProperty;
var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
var __hasOwnProp$s = Object.prototype.hasOwnProperty;
var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$s = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$s.call(b, prop))
      __defNormalProp$s(a, prop, b[prop]);
  if (__getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(b)) {
      if (__propIsEnum$s.call(b, prop))
        __defNormalProp$s(a, prop, b[prop]);
    }
  return a;
};
const mapAntdComponentToInputType = /* @__PURE__ */ new Map([
  [Input, InputType.Text],
  [Input.TextArea, InputType.TextArea],
  [Input.Password, InputType.Password],
  [InputNumber, InputType.Number],
  [AntdSelect, InputType.Select],
  [AntdRadioGroup, InputType.RadioGroup],
  [Radio, InputType.Radio],
  [AntdDatePicker, InputType.DatePicker],
  [AntdCheckbox, InputType.Checkbox]
]);
const mapPlumeTypeToInputType = /* @__PURE__ */ new Map([
  ["text-input", InputType.Text],
  ["select", InputType.Select],
  ["checkbox", InputType.Checkbox],
  ["switch", InputType.Checkbox]
]);
const COMMON_ACTIONS = [
  {
    type: "button-action",
    label: "Append new Form Field",
    onClick: ({ studioOps }) => {
      studioOps.appendToSlot(
        {
          type: "component",
          name: "plasmic-antd5-form-item"
        },
        "children"
      );
    },
    hidden: (props) => props.mode !== "advanced"
  }
  // {
  //   type: "button-action" as const,
  //   label: "Append new Form Field Group",
  //   onClick: ({ studioOps }: ActionProps<any>) => {
  //     studioOps.appendToSlot(
  //       {
  //         type: "component",
  //         name: "plasmic-antd5-form-group",
  //       },
  //       "children"
  //     );
  //   },
  // },
  // {
  //   type: "button-action" as const,
  //   label: "Append new Form List",
  //   onClick: ({ studioOps }: ActionProps<any>) => {
  //     studioOps.appendToSlot(
  //       {
  //         type: "component",
  //         name: "plasmic-antd5-form-list",
  //       },
  //       "children"
  //     );
  //   },
  // },
];
function getDefaultValueHint(field) {
  return (_props, contextData, { item }) => {
    var _a;
    if (!contextData || !("mergedFields" in contextData)) {
      return void 0;
    }
    if (item == null ? void 0 : item.fieldId) {
      const fieldSetting = (_a = contextData.mergedFields) == null ? void 0 : _a.find(
        (f) => f.fieldId === item.fieldId
      );
      return fieldSetting == null ? void 0 : fieldSetting[field];
    }
    return void 0;
  };
}
function commonFormItemProps(usage) {
  const getFormItemProps = (ps, _ctx, { item }) => {
    if (usage === "simplified-form-item") {
      return item;
    } else {
      return ps;
    }
  };
  return {
    name: {
      type: "string",
      required: true,
      displayName: "Field key",
      description: "Key name for this field value in the submitted form data.",
      validator: (value, _ps, ctx) => {
        var _a, _b, _c;
        let currFullPath = [];
        if (usage === "simplified-form-item") {
          currFullPath = [value];
        } else {
          const formItemCtx = ctx;
          currFullPath = [...(_a = formItemCtx == null ? void 0 : formItemCtx.parentFormItemPath) != null ? _a : [], value];
        }
        const nameCounter = ((_c = (_b = ctx == null ? void 0 : ctx.internalFieldCtx) == null ? void 0 : _b.registeredFields) != null ? _c : []).filter((formItem) => arrayEq(formItem.fullPath, currFullPath)).length;
        return nameCounter === 1 ? true : `Repeated form field key: ${currFullPath.join(" \u2192 ")}`;
      },
      defaultValueHint: getDefaultValueHint("name")
    },
    initialValue: {
      type: "dynamic",
      control: (ps, ctx, {
        item,
        path
      }) => {
        var _a, _b, _c, _d;
        let inputType = InputType.Unknown;
        if (usage === "simplified-form-item") {
          inputType = item.inputType;
          if (!ps.data) {
            inputType = item.inputType;
          } else if (path != null && typeof path[1] === "number") {
            inputType = (_b = (_a = ctx == null ? void 0 : ctx.mergedFields) == null ? void 0 : _a[path[1]].inputType) != null ? _b : InputType.Unknown;
          }
        } else {
          if (!React.isValidElement(ps.children) || typeof ps.children.type === "string") {
            inputType = InputType.Unknown;
          } else {
            if (mapAntdComponentToInputType.has(ps.children.type)) {
              inputType = (_c = mapAntdComponentToInputType.get(ps.children.type)) != null ? _c : InputType.Unknown;
            } else if ("__plumeType" in ps.children.type) {
              inputType = (_d = mapPlumeTypeToInputType.get(
                ps.children.type.__plumeType
              )) != null ? _d : InputType.Unknown;
            }
          }
        }
        if ([
          InputType.Text,
          InputType.TextArea,
          InputType.Password,
          InputType.Select,
          InputType.RadioGroup
        ].includes(inputType)) {
          return {
            type: "string",
            defaultValueHint: getDefaultValueHint("initialValue")
          };
        } else if (InputType.Number === inputType) {
          return {
            type: "number",
            defaultValueHint: getDefaultValueHint("initialValue")
          };
        } else if (InputType.Checkbox === inputType) {
          return {
            type: "boolean",
            defaultValueHint: getDefaultValueHint("initialValue")
          };
        } else if (InputType.DatePicker === inputType) {
          return {
            type: "dateString",
            defaultValueHint: getDefaultValueHint("initialValue")
          };
        } else {
          return {
            type: "exprEditor",
            defaultValueHint: getDefaultValueHint("initialValue")
          };
        }
      }
    },
    rules: {
      displayName: "Validation rules",
      type: "formValidationRules"
    },
    valuePropName: {
      type: "string",
      advanced: true,
      defaultValueHint: "value",
      description: "The prop name for specifying the value of the form control component"
    },
    trigger: {
      type: "string",
      displayName: "Trigger prop name",
      advanced: true,
      defaultValueHint: "onChange",
      description: "The prop name of event handler that is called when value is changed"
    },
    noLabel: {
      type: "boolean",
      advanced: true
    },
    alignLabellessWithControls: {
      type: "boolean",
      displayName: "Align with controls?",
      description: "Aligns the content with form controls in the grid",
      hidden: (ps, ctx, extras) => {
        var _a;
        const formItem = getFormItemProps(ps, ctx, extras);
        return !(formItem == null ? void 0 : formItem.noLabel) || ((_a = ctx == null ? void 0 : ctx.layout) == null ? void 0 : _a.layout) !== "horizontal";
      },
      defaultValueHint: true
    },
    colon: {
      type: "boolean",
      defaultValueHint: true,
      advanced: true,
      hidden: () => true
    },
    labelAlign: {
      type: "choice",
      options: ["left", "right"],
      advanced: true,
      hidden: (ps, ctx, extras) => {
        var _a;
        const formItem = getFormItemProps(ps, ctx, extras);
        return !!(formItem == null ? void 0 : formItem.noLabel) || ((_a = ctx == null ? void 0 : ctx.layout) == null ? void 0 : _a.layout) !== "horizontal";
      }
    },
    hidden: {
      type: "boolean",
      defaultValueHint: getDefaultValueHint("hidden")
    },
    validateTrigger: {
      displayName: "Validate when",
      type: "choice",
      options: [
        { value: "onBlur", label: "a field loses focus" },
        { value: "onChange", label: "a field changes" },
        { value: "onSubmit", label: "the form is submitted" }
      ],
      multiSelect: true,
      defaultValueHint: ["onChange"],
      advanced: true
    },
    shouldUpdate: {
      type: "boolean",
      advanced: true,
      displayName: "Always re-render",
      description: "Form fields normally only re-render when the corresponding form value changes, for performance. This forces it to always re-render."
    },
    dependencies: {
      type: "array",
      advanced: true,
      displayName: "Dependencies",
      description: "Form fields can depend on other form fields. This forces it to re-evaluate the validation rules when the other form fields changes."
    },
    hideValidationMessage: {
      type: "boolean",
      displayName: "Hide validation message?",
      description: "If true, will hide the validation error message",
      defaultValueHint: false,
      advanced: true
    },
    customizeProps: {
      type: "function",
      description: "Customize the props passed into the wrapped field component. Takes the current status ('success', 'warning', 'error', or 'validating').)",
      argNames: ["fieldData"],
      argValues: (_ps, ctx) => {
        var _a;
        return [
          {
            status: (_a = ctx == null ? void 0 : ctx.status) == null ? void 0 : _a.status
          }
        ];
      },
      advanced: true
    },
    noStyle: {
      type: "boolean",
      displayName: "Field control only",
      description: "Don't render anything but the field control - so no label, help text, validation error, etc.",
      advanced: true
    },
    preserve: {
      type: "boolean",
      advanced: true,
      defaultValueHint: true,
      description: "Keep field value even when field removed."
    }
  };
}
const commonSimplifiedFormArrayItemType = (propName) => ({
  type: "object",
  fields: __spreadValues$s({
    label: {
      type: "string",
      defaultValueHint: getDefaultValueHint("label")
    },
    inputType: {
      type: "choice",
      options: Object.values(InputType).filter(
        (inputType) => ![
          InputType.Option,
          InputType.OptionGroup,
          InputType.Radio,
          InputType.Unknown
        ].includes(inputType)
      ),
      defaultValue: InputType.Text,
      defaultValueHint: getDefaultValueHint("inputType")
    },
    options: {
      type: "array",
      itemType: {
        type: "object",
        fields: {
          type: {
            type: "choice",
            options: [
              { value: "option", label: "Option" },
              { value: "option-group", label: "Option Group" }
            ],
            defaultValue: "option",
            hidden: (ps, _ctx, { path }) => {
              var _a, _b;
              if (((_b = (_a = ps[propName]) == null ? void 0 : _a[path[1]]) == null ? void 0 : _b.inputType) !== InputType.Select) {
                return true;
              }
              return false;
            }
          },
          label: "string",
          value: {
            type: "string",
            hidden: (ps, _ctx, { path, item }) => {
              var _a, _b;
              if (((_b = (_a = ps[propName]) == null ? void 0 : _a[path[1]]) == null ? void 0 : _b.inputType) !== InputType.Select) {
                return false;
              }
              return item.type !== "option";
            }
          },
          options: {
            type: "array",
            itemType: {
              type: "object",
              nameFunc: (item) => item.label || item.value,
              fields: {
                value: "string",
                label: "string"
              }
            },
            hidden: (ps, _ctx, { path, item }) => {
              var _a, _b;
              if (((_b = (_a = ps[propName]) == null ? void 0 : _a[path[1]]) == null ? void 0 : _b.inputType) !== InputType.Select) {
                return true;
              }
              return item.type !== "option-group";
            }
          }
        },
        nameFunc: (item) => item == null ? void 0 : item.label
      },
      hidden: (_ps, _ctx, { item }) => ![InputType.Select, InputType.RadioGroup].includes(item.inputType)
    },
    optionType: {
      type: "choice",
      options: [
        { value: "default", label: "Radio" },
        { value: "button", label: "Button" }
      ],
      hidden: (_ps, _ctx, { item }) => InputType.RadioGroup !== item.inputType,
      defaultValueHint: "Radio",
      displayName: "Option Type"
    },
    showTime: {
      type: "boolean",
      displayName: "Show Time",
      description: "To provide an additional time selection",
      hidden: (_ps, _ctx, { item }) => ![InputType.DatePicker].includes(item.inputType)
    }
  }, commonFormItemProps("simplified-form-item")),
  nameFunc: (item) => {
    var _a, _b;
    return (_b = (_a = item.fieldId) != null ? _a : item.label) != null ? _b : item.name;
  }
});

function FormGroup(props) {
  const pathCtx = React.useContext(PathContext);
  return /* @__PURE__ */ React.createElement(
    PathContext.Provider,
    {
      value: {
        relativePath: [...pathCtx.relativePath, props.name],
        fullPath: [...pathCtx.fullPath, props.name]
      }
    },
    props.children
  );
}

var __defProp$r = Object.defineProperty;
var __defProps$h = Object.defineProperties;
var __getOwnPropDescs$h = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$r = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$r.call(b, prop))
      __defNormalProp$r(a, prop, b[prop]);
  if (__getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(b)) {
      if (__propIsEnum$r.call(b, prop))
        __defNormalProp$r(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$h = (a, b) => __defProps$h(a, __getOwnPropDescs$h(b));
const FormList = Form.List;
const FormListWrapper = React.forwardRef(function FormListWrapper2(props, ref) {
  var _a;
  const relativeFormItemName = useFormItemRelativeName(props.name);
  const fullFormItemName = useFormItemFullName(props.name);
  const operationsRef = React.useRef(
    void 0
  );
  React.useImperativeHandle(
    ref,
    () => ({
      add(defaultValue, insertIndex) {
        if (operationsRef.current) {
          const { add } = operationsRef.current[1];
          add(defaultValue, insertIndex);
        }
      },
      remove(index) {
        if (operationsRef.current) {
          const { remove } = operationsRef.current[1];
          remove(index);
        }
      },
      move(from, to) {
        if (operationsRef.current) {
          const { move } = operationsRef.current[1];
          move(from, to);
        }
      }
    }),
    [operationsRef]
  );
  const inCanvas = !!usePlasmicCanvasContext();
  if (inCanvas) {
    const form = useFormInstanceMaybe();
    const prevPropValues = React.useRef({
      initialValue: props.initialValue,
      name: props.name
    });
    const { fireOnValuesChange, forceRemount } = (_a = React.useContext(InternalFormInstanceContext)) != null ? _a : {};
    React.useEffect(() => {
      if (prevPropValues.current.name !== props.name) {
        forceRemount == null ? void 0 : forceRemount();
      }
      if (fullFormItemName) {
        form == null ? void 0 : form.setFieldValue(fullFormItemName, props.initialValue);
        prevPropValues.current.initialValue = props.initialValue;
        fireOnValuesChange == null ? void 0 : fireOnValuesChange();
      }
    }, [JSON.stringify(props.initialValue), JSON.stringify(fullFormItemName)]);
  }
  return /* @__PURE__ */ React.createElement(FormList, __spreadProps$h(__spreadValues$r({}, props), { name: relativeFormItemName != null ? relativeFormItemName : [] }), (...args) => {
    operationsRef.current = args;
    return args[0].map((field, index) => /* @__PURE__ */ React.createElement(
      PathContext.Provider,
      {
        value: {
          relativePath: [field.name],
          fullPath: [...fullFormItemName != null ? fullFormItemName : [], field.name]
        }
      },
      /* @__PURE__ */ React.createElement(DataProvider, { name: "currentField", data: field }, /* @__PURE__ */ React.createElement(DataProvider, { name: "currentFieldIndex", data: index }, repeatedElement(index, props.children)))
    ));
  });
});

var __defProp$q = Object.defineProperty;
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$q = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$q.call(b, prop))
      __defNormalProp$q(a, prop, b[prop]);
  if (__getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(b)) {
      if (__propIsEnum$q.call(b, prop))
        __defNormalProp$q(a, prop, b[prop]);
    }
  return a;
};
const colProp = (displayName, defaultValue, description) => ({
  type: "object",
  displayName,
  advanced: true,
  fields: {
    span: {
      type: "number",
      displayName: "Width",
      description: "The number of grid columns to span in width (out of 24 columns total)",
      min: 1,
      max: 24
    },
    offset: {
      type: "number",
      displayName: "Offset",
      description: "Number of grid columns to skip from the left (out of 24 columns total)",
      min: 0,
      max: 23
    },
    horizontalOnly: {
      type: "boolean",
      displayName: "Horizontal only",
      description: "Only apply when form layout is horizontal"
    }
  },
  nameFunc: () => `Edit ${displayName}`,
  description,
  defaultValue
});
const formTypeDescription = `
  You can create form with two different behaviors:
  


  1. Create a new entry: The form will be created empty and it will create a new row when submitted.
  2. Update an entry: The form will be pre-filled with the row values and it will update the table entry when submitted.
  


  For both options, you can customize later.
`;
function registerForm(loader) {
  registerComponentHelper(loader, SchemaForm, {
    name: formComponentName,
    displayName: "Form",
    description: "[Learn how to use forms](https://docs.plasmic.app/learn/forms/)",
    defaultStyles: {
      layout: "vbox",
      alignItems: "flex-start"
    },
    props: {
      mode: {
        type: "controlMode",
        defaultValue: "simplified"
      },
      data: {
        type: "formDataConnection",
        disableDynamicValue: true,
        disableLinkToProp: true,
        hidden: (ps) => ps.mode !== "simplified" || !ps.data,
        invariantable: true
      },
      formItems: {
        displayName: "Fields",
        type: "array",
        itemType: commonSimplifiedFormArrayItemType("formItems"),
        defaultValue: [
          {
            label: "Name",
            name: "name",
            inputType: InputType.Text
          },
          {
            label: "Message",
            name: "message",
            inputType: InputType.TextArea
          }
        ],
        hidden: (ps) => {
          if (ps.mode === "advanced") {
            return true;
          }
          return !!ps.data;
        },
        invariantable: true
      },
      /**
       * dataFormItems are used to expand the form items from schema forms.
       * We can't use the formItems prop because it has a default value. Therefore, if we unset the formItems prop,
       * we would end up with the default value of formItems + schema form items.
       * Ideally, we would need to support dynamic default value.
       */
      dataFormItems: {
        displayName: "Data Fields",
        type: "array",
        itemType: commonSimplifiedFormArrayItemType("dataFormItems"),
        hidden: (ps) => {
          if (ps.mode === "advanced") {
            return true;
          }
          return !ps.data;
        },
        unstable__keyFunc: (x) => x.key,
        unstable__minimalValue: (ps, contextData) => {
          return ps.data ? contextData == null ? void 0 : contextData.minimalFullLengthFields : void 0;
        },
        unstable__canDelete: (item, ps, ctx) => {
          if (ps.mode !== "simplified") {
            return true;
          }
          if (!(ctx == null ? void 0 : ctx.schema)) {
            return false;
          }
          if (item.fieldId && ctx.schema.fields.some((f) => f.id === item.fieldId)) {
            return false;
          }
          return true;
        },
        invariantable: true
      },
      submitSlot: __spreadValues$q({
        type: "slot",
        hidden: () => true,
        defaultValue: {
          type: "component",
          name: buttonComponentName,
          props: {
            type: "primary",
            submitsForm: true,
            children: {
              type: "text",
              value: "Submit"
            }
          }
        }
      }, {
        mergeWithParent: () => true,
        hiddenMergedProps: (ps) => !ps.mode
      }),
      children: {
        type: "slot",
        hidden: (props) => props.mode !== "advanced"
      },
      initialValues: {
        displayName: "Initial field values",
        type: "object"
      },
      layout: {
        displayName: "Form layout",
        type: "choice",
        options: ["horizontal", "vertical", "inline"],
        defaultValue: "vertical"
      },
      labelAlign: {
        type: "choice",
        options: ["left", "right"],
        defaultValueHint: "right",
        advanced: true,
        hidden: (ps) => ps.layout !== "horizontal"
      },
      labelCol: colProp(
        "Label layout",
        {
          span: 8,
          horizontalOnly: true
        },
        "Set the width and offset of the labels"
      ),
      wrapperCol: colProp(
        "Control layout",
        {
          span: 16,
          horizontalOnly: true
        },
        "Set the width and offset of the form controls"
      ),
      colon: {
        type: "boolean",
        description: `Show a colon after labels by default (only for horizontal layout)`,
        defaultValueHint: true,
        advanced: true,
        hidden: (props) => {
          var _a;
          return ((_a = props.layout) != null ? _a : "horizontal") !== "horizontal";
        }
      },
      requiredMark: {
        displayName: "Required/optional indicators",
        type: "choice",
        options: [
          {
            value: "optional",
            label: "Indicate optional fields"
          },
          {
            value: true,
            label: "Indicate required fields with asterisk"
          },
          {
            value: false,
            label: "Show no indicators"
          }
        ],
        advanced: true,
        defaultValueHint: true
      },
      extendedOnValuesChange: {
        type: "eventHandler",
        displayName: "On values change",
        argTypes: [
          {
            name: "changedValues",
            type: "object"
          },
          {
            name: "allValues",
            type: "object"
          }
        ]
      },
      onFinish: {
        type: "eventHandler",
        displayName: "On submit",
        argTypes: [
          {
            name: "values",
            type: "object"
          }
        ]
      },
      onFinishFailed: {
        // function({ values, errorFields, outOfDate })
        type: "eventHandler",
        displayName: "On invalid submit",
        argTypes: [
          {
            name: "data",
            type: "object"
          }
        ]
      },
      validateTrigger: {
        displayName: "Validate when",
        type: "choice",
        options: [
          { value: "onBlur", label: "a field loses focus" },
          { value: "onChange", label: "a field changes" },
          { value: "onSubmit", label: "the form is submitted" }
        ],
        multiSelect: true,
        defaultValueHint: ["onChange"],
        advanced: true
      },
      autoDisableWhileSubmitting: {
        displayName: "Auto disable while submitting",
        type: "boolean",
        defaultValueHint: true,
        advanced: true,
        description: "When disabled, it allows the creation of new submissions even while existing submissions are in progress."
      },
      onIsSubmittingChange: {
        type: "eventHandler",
        displayName: "On Is Submitting Change",
        argTypes: [
          {
            name: "isSubmitting",
            type: "boolean"
          }
        ],
        advanced: true
      }
    },
    actions: [
      ...COMMON_ACTIONS,
      {
        type: "form-schema",
        hidden: (ps) => ps.mode !== "simplified" || !!ps.data
      }
    ],
    states: {
      value: {
        type: "readonly",
        variableType: "object",
        onChangeProp: "extendedOnValuesChange"
      },
      isSubmitting: {
        type: "readonly",
        variableType: "boolean",
        onChangeProp: "onIsSubmittingChange",
        initVal: false
      }
    },
    componentHelpers: {
      helpers: formHelpers,
      importName: "formHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/Form"
    },
    refActions: {
      setFieldsValue: {
        displayName: "Set multiple fields",
        argTypes: [
          {
            name: "newValues",
            displayName: "New Values",
            type: "exprEditor"
          }
        ]
      },
      setFieldValue: {
        displayName: "Set field",
        argTypes: [
          {
            name: "namePath",
            displayName: "Name Path",
            type: {
              type: "dataSelector",
              data: (_, ctx) => {
                if (!(ctx == null ? void 0 : ctx.formInstance)) {
                  return {};
                }
                return ctx.formInstance.getFieldsValue(true);
              }
            }
          },
          {
            name: "value",
            displayName: "New Value",
            type: "exprEditor"
          }
        ]
      },
      resetFields: {
        displayName: "Reset fields to initial value",
        argTypes: []
      },
      clearFields: {
        displayName: "Clear fields",
        argTypes: []
      },
      validateFields: {
        displayName: "Validate fields",
        argTypes: [
          {
            name: "nameList",
            displayName: "Name List",
            type: "object"
          },
          {
            name: "options",
            displayName: "Options",
            type: "object"
          }
        ]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/SchemaForm",
    importName: "FormWrapper"
  });
}

function registerFormGroup(loader) {
  registerComponentHelper(loader, FormGroup, {
    name: formGroupComponentName,
    displayName: "Form Field Group",
    parentComponentName: formComponentName,
    actions: COMMON_ACTIONS,
    props: {
      name: {
        type: "string",
        displayName: "Form group key",
        description: "Name of the field key for this group of form fields in the submitted form data."
      },
      children: {
        type: "slot"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/FormGroup",
    importName: "FormGroup"
  });
}

var __defProp$p = Object.defineProperty;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$p = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$p(a, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$p(a, prop, b[prop]);
    }
  return a;
};
function registerFormItem(loader) {
  registerComponentHelper(loader, FormItemWrapper, __spreadValues$p({
    name: formItemComponentName,
    displayName: "Form Field",
    parentComponentName: formComponentName,
    defaultStyles: {
      marginBottom: "24px",
      width: "stretch"
    },
    props: __spreadValues$p({
      label: __spreadValues$p({
        type: "slot",
        defaultValue: {
          type: "text",
          value: "Label"
        },
        hidden: (ps) => !!ps.noLabel
      }, { mergeWithParent: true }),
      children: __spreadValues$p({
        type: "slot",
        defaultValue: {
          type: "component",
          name: inputComponentName
        }
      }, { mergeWithParent: true })
    }, commonFormItemProps("advanced-form-item")),
    importPath: "@plasmicpkgs/antd5/skinny/FormItem",
    importName: "FormItemWrapper",
    treeLabel: (ps) => ps.name,
    templates: {
      Text: {
        props: {
          children: {
            type: "component",
            name: inputComponentName
          }
        }
      },
      "Long Text": {
        props: {
          children: {
            type: "component",
            name: textAreaComponentName
          }
        }
      },
      "Select dropdown": {
        props: {
          children: {
            type: "component",
            name: selectComponentName
          }
        }
      },
      Number: {
        props: {
          children: {
            type: "component",
            name: inputNumberComponentName
          }
        }
      },
      Checkbox: {
        props: {
          children: {
            type: "component",
            name: checkboxComponentName
          },
          noLabel: true
        }
      },
      Switch: {
        props: {
          children: {
            type: "component",
            name: switchComponentName
          },
          noLabel: true
        }
      },
      Radios: {
        props: {
          children: {
            type: "component",
            name: radioGroupComponentName
          }
        }
      },
      Password: {
        props: {
          children: {
            type: "component",
            name: passwordComponentName
          }
        }
      },
      "Submit button": {
        props: {
          children: {
            type: "component",
            name: buttonComponentName,
            props: {
              type: "primary"
            }
          },
          noLabel: true
        }
      }
    }
  }, { trapsSelection: true }));
}

function registerFormList(loader) {
  registerComponentHelper(loader, FormListWrapper, {
    name: formListComponentName,
    parentComponentName: formComponentName,
    displayName: "Form List",
    actions: COMMON_ACTIONS,
    providesData: true,
    props: {
      children: {
        type: "slot",
        defaultValue: [
          {
            type: "hbox",
            children: [
              {
                type: "component",
                name: formItemComponentName,
                props: {
                  name: "firstName",
                  label: {
                    type: "text",
                    value: "First name"
                  },
                  children: {
                    type: "component",
                    name: "plasmic-antd5-input"
                  }
                }
              },
              {
                type: "component",
                name: formItemComponentName,
                props: {
                  name: "lastName",
                  label: {
                    type: "text",
                    value: "Last name"
                  },
                  children: {
                    type: "component",
                    name: "plasmic-antd5-input"
                  }
                }
              }
            ]
          }
        ]
      },
      name: {
        type: "string",
        defaultValue: "guests"
      },
      initialValue: {
        type: "array",
        defaultValue: [
          {
            firstName: "Jane",
            lastName: "Doe"
          },
          {
            firstName: "John",
            lastName: "Smith"
          }
        ]
      }
    },
    refActions: {
      add: {
        displayName: "Add an item",
        argTypes: [
          {
            name: "defaultValue",
            displayName: "Default value",
            type: "object"
          },
          {
            name: "insertIndex",
            displayName: "Insert index",
            type: "number"
          }
        ]
      },
      remove: {
        displayName: "Remove an item",
        argTypes: [
          {
            name: "index",
            displayName: "Index",
            type: "number"
          }
        ]
      },
      move: {
        displayName: "Move field",
        argTypes: [
          {
            name: "from",
            displayName: "From",
            type: "number"
          },
          {
            name: "to",
            displayName: "To",
            type: "number"
          }
        ]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/FormList",
    importName: "FormListWrapper"
  });
}

var __defProp$o = Object.defineProperty;
var __defProps$g = Object.defineProperties;
var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$o = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$o(a, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$o(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$g = (a, b) => __defProps$g(a, __getOwnPropDescs$g(b));
var __objRest$i = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$o.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$o.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdAvatar(_a) {
  var _b = _a, {
    letters,
    href,
    target
  } = _b, props = __objRest$i(_b, [
    "letters",
    "href",
    "target"
  ]);
  const avatar = /* @__PURE__ */ React.createElement(Avatar, __spreadProps$g(__spreadValues$o({}, props), { children: props.children || letters }));
  const PlasmicLink = usePlasmicLink();
  return href ? /* @__PURE__ */ React.createElement(PlasmicLink, { href, target: target ? "_blank" : void 0 }, avatar) : avatar;
}
function AntdAvatarGroup(props) {
  return /* @__PURE__ */ React.createElement(Avatar.Group, __spreadValues$o({}, props));
}
function registerAvatar(loader) {
  registerComponentHelper(loader, AntdAvatar, {
    name: "plasmic-antd5-avatar",
    displayName: "Avatar",
    props: {
      href: {
        type: "href",
        displayName: "Link to",
        description: "Destination to link to"
      },
      target: {
        type: "boolean",
        displayName: "Open in new tab",
        hidden: (ps) => !ps.href
      },
      letters: {
        type: "string",
        description: "Letters to show",
        defaultValue: "AB"
      },
      src: {
        type: "imageUrl",
        description: "Image to display"
      },
      size: {
        type: "choice",
        options: ["small", "default", "large"],
        description: "Set the size of avatar",
        defaultValueHint: "default"
      },
      shape: {
        type: "choice",
        options: ["circle", "round"],
        description: "Set the avatar shape",
        defaultValueHint: "circle"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerAvatar",
    importName: "AntdAvatar"
  });
}
function registerAvatarGroup(loader) {
  registerComponentHelper(loader, AntdAvatarGroup, {
    name: "plasmic-antd5-avatar-group",
    displayName: "AvatarGroup",
    props: {
      children: {
        type: "slot",
        defaultValue: [1, 2, 3, 4].map((user) => ({
          type: "component",
          name: "plasmic-antd5-tooltip",
          props: {
            titleText: "User " + user,
            children: {
              type: "component",
              name: "plasmic-antd5-avatar",
              props: {
                letters: `U${user}`
              }
            }
          }
        }))
      },
      maxCount: {
        type: "number",
        description: "Max avatars to show",
        defaultValue: 2
      },
      size: {
        type: "choice",
        options: ["small", "default", "large"],
        description: "Default size of avatars",
        defaultValueHint: "default"
      },
      maxPopoverPlacement: {
        type: "choice",
        advanced: true,
        options: ["top", "bottom"],
        defaultValueHint: "top"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerAvatar",
    importName: "AntdAvatarGroup"
  });
}

var __defProp$n = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$n = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$n(a, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$n(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$f = (a, b) => __defProps$f(a, __getOwnPropDescs$f(b));
var __objRest$h = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$n.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$n.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdBreadcrumbItem(props) {
  return props.children;
}
function AntdBreadcrumb(props) {
  const _a = props, { itemsRaw } = _a, rest = __objRest$h(_a, ["itemsRaw"]);
  const items = React.useMemo(() => {
    if (!React.isValidElement(itemsRaw) && !Array.isArray(itemsRaw))
      return [];
    return (Array.isArray(itemsRaw) ? itemsRaw : Array.isArray(itemsRaw.props.children) ? itemsRaw.props.children : [itemsRaw.props.children]).map((currentItem) => {
      return __spreadProps$f(__spreadValues$n({}, currentItem.props), {
        title: React.cloneElement(/* @__PURE__ */ React.createElement(React.Fragment, null, currentItem))
      });
    }).filter((i) => i != null);
  }, [itemsRaw]);
  return /* @__PURE__ */ React.createElement(Breadcrumb, __spreadProps$f(__spreadValues$n({}, rest), { items }));
}
const breadcrumbItemComponentName = "plasmic-antd5-breadcrumb-item";
const breadcrumbComponentName = "plasmic-antd5-breadcrumb";
function registerBreadcrumb(loader) {
  registerComponentHelper(loader, AntdBreadcrumb, {
    name: breadcrumbComponentName,
    displayName: "Breadcrumb",
    props: {
      itemsRaw: {
        type: "slot",
        displayName: "items",
        defaultValue: [
          {
            type: "component",
            name: breadcrumbItemComponentName,
            props: {
              children: {
                type: "text",
                value: "First"
              }
            }
          },
          {
            type: "component",
            name: breadcrumbItemComponentName,
            props: {
              children: {
                type: "text",
                value: "Second"
              }
            }
          },
          {
            type: "component",
            name: breadcrumbItemComponentName,
            props: {
              children: {
                type: "text",
                value: "Third"
              }
            }
          }
        ],
        allowedComponents: [breadcrumbItemComponentName]
      },
      separator: {
        type: "slot",
        defaultValue: {
          type: "text",
          value: "/"
        }
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerBreadcrumb",
    importName: "AntdBreadcrumb"
  });
}
function registerBreadcrumbItem(loader) {
  registerComponentHelper(loader, AntdBreadcrumbItem, {
    name: breadcrumbItemComponentName,
    displayName: "Breadcrumb Item",
    props: {
      children: {
        type: "slot",
        defaultValue: {
          type: "text",
          value: "Breadcrumb Item"
        }
      },
      onClick: {
        type: "eventHandler",
        argTypes: [{ type: "object", name: "event" }]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerBreadcrumb",
    importName: "AntdBreadcrumbItem"
  });
}

var __defProp$m = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$m = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$m(a, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$m(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$e = (a, b) => __defProps$e(a, __getOwnPropDescs$e(b));
var __objRest$g = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$m.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$m.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdButton(props) {
  const _a = props, { submitsForm = false, children } = _a, rest = __objRest$g(_a, ["submitsForm", "children"]);
  const target = props.target === true ? "_blank" : props.target === false ? void 0 : props.target;
  return /* @__PURE__ */ React.createElement(
    Button,
    __spreadProps$e(__spreadValues$m({}, rest), {
      children: /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            display: "inline-block"
          }
        },
        children
      ),
      htmlType: submitsForm ? "submit" : "button",
      target
    })
  );
}
function registerButton(loader) {
  registerComponentHelper(loader, AntdButton, {
    name: buttonComponentName,
    displayName: "Button",
    props: {
      type: {
        type: "choice",
        options: ["default", "primary", "ghost", "dashed", "link", "text"],
        description: "Can be set to primary, ghost, dashed, link, text, default",
        defaultValueHint: "default"
      },
      size: {
        type: "choice",
        options: ["small", "medium", "large"],
        description: "Set the size of button",
        defaultValueHint: "medium"
      },
      shape: {
        type: "choice",
        options: ["default", "circle", "round"],
        description: "Set the button shape",
        defaultValueHint: "default"
      },
      disabled: {
        type: "boolean",
        description: "Whether the button is disabled",
        defaultValueHint: false
      },
      submitsForm: {
        type: "boolean",
        displayName: "Submits form?",
        defaultValueHint: false,
        description: "whether clicking this button should submit the enclosing form.",
        advanced: true
      },
      ghost: {
        type: "boolean",
        description: "Make background transparent and invert text and border colors",
        defaultValueHint: false,
        advanced: true
      },
      danger: {
        type: "boolean",
        description: "Set the danger status of button",
        defaultValueHint: false,
        advanced: true
      },
      loading: {
        type: "boolean",
        description: "Set the loading status of button",
        defaultValueHint: false,
        advanced: true
      },
      href: {
        displayName: "Link to",
        type: "href",
        description: "Use this button as a link to this url"
      },
      target: {
        type: "boolean",
        displayName: "Open in new tab?",
        description: "Whether to open the link in a new window",
        hidden: (props) => !props.href,
        defaultValueHint: false
      },
      children: __spreadValues$m({
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Button"
          }
        ]
      }, { mergeWithParent: true }),
      icon: {
        type: "slot",
        hidePlaceholder: true,
        hidden: () => true
      },
      onClick: {
        type: "eventHandler",
        argTypes: []
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerButton",
    importName: "AntdButton"
  });
}

var __defProp$l = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$l(a, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$l(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$d = (a, b) => __defProps$d(a, __getOwnPropDescs$d(b));
var __objRest$f = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$l.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$l.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const singleCollapseComponentName = "plasmic-antd5-single-collapse";
const accordionComponentName = "plasmic-antd5-collapse";
const accordionItemComponentName = "plasmic-antd5-collapse-item";
function AntdAccordionItem({ children }) {
  return /* @__PURE__ */ React.createElement("div", null, children);
}
function AntdAccordion(props) {
  const _a = props, {
    items: itemsRaw,
    activeKey,
    defaultActiveKey,
    expandIcon,
    collapsible,
    disabled,
    rotateCustomExpandIcon
  } = _a, rest = __objRest$f(_a, [
    "items",
    "activeKey",
    "defaultActiveKey",
    "expandIcon",
    "collapsible",
    "disabled",
    "rotateCustomExpandIcon"
  ]);
  const items = useMemo(() => {
    if (!React.isValidElement(itemsRaw) && !Array.isArray(itemsRaw))
      return [];
    return (Array.isArray(itemsRaw) ? itemsRaw : Array.isArray(itemsRaw.props.children) ? itemsRaw.props.children : [itemsRaw.props.children]).map((currentItem) => {
      const props2 = __spreadProps$d(__spreadValues$l({}, currentItem.props), {
        id: currentItem.props.id,
        key: currentItem.props.id,
        children: React.cloneElement(/* @__PURE__ */ React.createElement(React.Fragment, null, currentItem.props.children))
      });
      if (currentItem.props.label) {
        delete props2.label2;
      } else {
        props2.label = props2.label2;
      }
      return props2;
    }).filter((i) => i != null);
  }, [itemsRaw]);
  return /* @__PURE__ */ React.createElement(
    Collapse,
    __spreadValues$l({
      accordion: true,
      items,
      defaultActiveKey,
      activeKey,
      collapsible: disabled ? "disabled" : collapsible,
      expandIcon: expandIcon ? ({ isActive }) => /* @__PURE__ */ React.createElement(
        "div",
        {
          style: isActive && rotateCustomExpandIcon ? { transform: "rotate(90deg)" } : void 0
        },
        expandIcon
      ) : void 0
    }, rest)
  );
}
function AntdSingleCollapse(props) {
  const _a = props, {
    open,
    defaultOpen,
    expandIcon,
    collapsible,
    disabled,
    rotateCustomExpandIcon,
    label: oldLabelProp,
    label2: newLabelProp,
    showArrow,
    extra,
    forceRender,
    children,
    headerClass
  } = _a, rest = __objRest$f(_a, [
    "open",
    "defaultOpen",
    "expandIcon",
    "collapsible",
    "disabled",
    "rotateCustomExpandIcon",
    "label",
    "label2",
    "showArrow",
    "extra",
    "forceRender",
    "children",
    "headerClass"
  ]);
  const label = oldLabelProp != null ? oldLabelProp : newLabelProp;
  const defaultItemKey = useMemo(() => uniqueId(), []);
  const item = useMemo(
    () => ({
      key: defaultItemKey,
      label,
      showArrow,
      extra: /* @__PURE__ */ React.createElement(React.Fragment, null, extra),
      headerClass,
      children
    }),
    [label, showArrow, extra, children, defaultItemKey, headerClass]
  );
  return /* @__PURE__ */ React.createElement(
    Collapse,
    __spreadValues$l({
      accordion: false,
      items: [item],
      defaultActiveKey: defaultOpen ? item.key : void 0,
      activeKey: open ? item.key : void 0,
      collapsible: disabled ? "disabled" : collapsible,
      expandIcon: expandIcon ? ({ isActive }) => /* @__PURE__ */ React.createElement(
        "div",
        {
          style: isActive && rotateCustomExpandIcon ? { transform: "rotate(90deg)" } : void 0
        },
        expandIcon
      ) : void 0
    }, rest)
  );
}
const accordionHelpers = {
  states: {
    activePanelId: {
      onChangeArgsToValue: (activeKeys) => activeKeys[0]
    }
  }
};
const singleCollapseHelpers = {
  states: {
    open: {
      onChangeArgsToValue: (activeKeys) => activeKeys.length > 0
    }
  }
};
const commonAccordionProps = {
  bordered: {
    type: "boolean",
    defaultValue: true,
    description: `Display border around accordion `
  },
  disabled: {
    type: "boolean",
    description: "Disable the toggle behaviour of panels"
  },
  expandIcon: {
    type: "slot",
    hidePlaceholder: true
  },
  rotateCustomExpandIcon: {
    type: "boolean",
    description: "Enable rotation of custom expand icon when panel is expanded",
    advanced: true,
    hidden: (ps) => !ps.expandIcon
  },
  expandIconPosition: {
    type: "choice",
    defaultValueHint: "start",
    description: `Set expand icon position`,
    options: ["start", "end"]
  },
  ghost: {
    type: "boolean",
    description: `Make the accordion borderless and its background transparent`
  },
  size: {
    type: "choice",
    defaultValueHint: "middle",
    description: `Set the size of accordion`,
    options: ["large", "middle", "small"]
  },
  onChange: {
    type: "eventHandler",
    argTypes: [{ name: "activeIds", type: "object" }]
  }
};
const commonAccordionItemProps = {
  label: {
    type: "string",
    displayName: "Header Content",
    description: "Text inside the header",
    hidden: (props) => props.label != null ? false : (props == null ? void 0 : props.label2) !== void 0 || (props == null ? void 0 : props.header) === void 0
  },
  label2: {
    type: "slot",
    displayName: "Header Content",
    defaultValue: "Collapse Header",
    hidePlaceholder: true,
    hidden: (props) => props.label != null ? true : (props == null ? void 0 : props.label2) === void 0 && (props == null ? void 0 : props.header) !== void 0
  },
  extra: {
    type: "slot",
    hidePlaceholder: true
  },
  showArrow: {
    type: "boolean",
    defaultValue: true,
    description: `Whether to show animating arrow alongside header text`,
    advanced: true
  },
  headerClass: {
    type: "class",
    displayName: "Header"
  },
  children: __spreadProps$d(__spreadValues$l({
    type: "slot",
    hidePlaceholder: true
  }, { mergeWithParent: true }), {
    defaultValue: "Collapsible text..."
  })
};
const commonProps$1 = {
  collapsible: {
    displayName: "Toggle Area",
    type: "choice",
    defaultValueHint: "header",
    description: `Specify the element that can be clicked to toggle a panel`,
    options: ["header", "icon"],
    advanced: true,
    hidden: (ps) => Boolean(ps.disabled)
  },
  destroyInactivePanel: {
    type: "boolean",
    description: `Destroy/Unmount panel if inactive`,
    advanced: true
  },
  forceRender: {
    type: "boolean",
    description: `Force rendering of content in the panel, instead of lazy rendering it.`,
    advanced: true
  }
};
function registerCollapse(loader) {
  registerComponentHelper(loader, AntdSingleCollapse, {
    name: singleCollapseComponentName,
    displayName: "Collapse",
    description: "Accordion, but with a single collapsible block.",
    defaultStyles: {
      width: "stretch"
    },
    props: __spreadValues$l(__spreadValues$l(__spreadValues$l({
      open: {
        editOnly: true,
        displayName: "Open",
        uncontrolledProp: "defaultOpen",
        type: "boolean",
        description: `Default open state of the collapse block`
      }
    }, commonProps$1), commonAccordionItemProps), commonAccordionProps),
    states: {
      open: __spreadValues$l({
        type: "writable",
        valueProp: "open",
        onChangeProp: "onChange",
        variableType: "boolean"
      }, singleCollapseHelpers.states.open)
    },
    componentHelpers: {
      helpers: singleCollapseHelpers,
      importName: "singleCollapseHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerCollapse"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerCollapse",
    importName: "AntdSingleCollapse"
  });
  registerComponentHelper(loader, AntdAccordion, {
    name: accordionComponentName,
    displayName: "Accordion",
    defaultStyles: {
      width: "stretch"
    },
    props: __spreadValues$l(__spreadValues$l({
      activeKey: {
        editOnly: true,
        displayName: "Active panel ID",
        uncontrolledProp: "defaultActiveKey",
        type: "string",
        description: `ID of Accordion item that is expanded by default.`,
        advanced: true
      },
      items: __spreadProps$d(__spreadValues$l({
        type: "slot",
        hidePlaceholder: true,
        allowedComponents: [accordionItemComponentName]
      }, { mergeWithParent: true }), {
        defaultValue: [
          {
            type: "component",
            name: accordionItemComponentName,
            props: {
              id: 1,
              label2: {
                type: "text",
                value: "First Item"
              },
              children: {
                type: "text",
                value: "First Children"
              }
            }
          },
          {
            type: "component",
            name: accordionItemComponentName,
            props: {
              id: 2,
              label2: {
                type: "text",
                value: "Second Item"
              },
              children: {
                type: "text",
                value: "Second Children"
              }
            }
          }
        ]
      })
    }, commonProps$1), commonAccordionProps),
    states: {
      activePanelId: __spreadValues$l({
        type: "writable",
        valueProp: "activeKey",
        onChangeProp: "onChange",
        variableType: "text"
      }, accordionHelpers.states.activePanelId)
    },
    componentHelpers: {
      helpers: accordionHelpers,
      importName: "accordionHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerCollapse"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerCollapse",
    importName: "AntdAccordion"
  });
  registerComponentHelper(loader, AntdAccordionItem, {
    name: accordionItemComponentName,
    displayName: "Accordion Item",
    props: __spreadValues$l(__spreadValues$l({
      id: {
        type: "string",
        description: `Unique identifier for this item`,
        required: true
      }
    }, commonProps$1), commonAccordionItemProps),
    importPath: "@plasmicpkgs/antd5/skinny/registerCollapse",
    importName: "AntdAccordionItem",
    parentComponentName: accordionComponentName
  });
}

var __defProp$k = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$k = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$k(a, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$k(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$c = (a, b) => __defProps$c(a, __getOwnPropDescs$c(b));
var __objRest$e = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$k.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$k.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdColorPicker(_a) {
  var _b = _a, {
    showTextSwitch,
    onChange
  } = _b, props = __objRest$e(_b, [
    "showTextSwitch",
    "onChange"
  ]);
  return /* @__PURE__ */ React.createElement(
    ColorPicker,
    __spreadProps$c(__spreadValues$k({}, props), {
      showText: props.showText || showTextSwitch,
      onChangeComplete: (value) => {
        onChange == null ? void 0 : onChange(typeof value === "string" ? value : value.toHexString());
      }
    })
  );
}
function registerColorPicker(loader) {
  registerComponentHelper(loader, AntdColorPicker, {
    name: "plasmic-antd5-color-picker",
    displayName: "Color Picker",
    props: {
      children: {
        type: "slot",
        hidePlaceholder: true,
        mergeWithParent: true
      },
      value: {
        displayName: "Color value",
        type: "color",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      showTextSwitch: {
        type: "boolean",
        displayName: "Show text"
      },
      showText: {
        type: "slot",
        hidePlaceholder: true
      },
      allowClear: "boolean",
      disabled: {
        type: "boolean",
        advanced: true
      },
      trigger: {
        advanced: true,
        type: "choice",
        options: ["click", "hover"],
        defaultValueHint: "click"
      },
      format: {
        advanced: true,
        type: "choice",
        options: ["hex", "hsb", "rgb"],
        defaultValueHint: "hex"
      },
      onChange: {
        type: "eventHandler",
        argTypes: [
          {
            name: "color",
            type: "string"
          }
        ]
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerColorPicker",
    importName: "AntdColorPicker"
  });
}

var __defProp$j = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$j(a, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$j(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$b = (a, b) => __defProps$b(a, __getOwnPropDescs$b(b));
var __objRest$d = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$j.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$j.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
let defaultLocale = enUS;
if ("default" in enUS) {
  defaultLocale = enUS.default;
}
function themeToAntdConfig(opts) {
  const {
    colorTextBase,
    colorPrimary,
    colorSuccess,
    colorWarning,
    colorError,
    colorInfo,
    colorBgBase,
    fontFamily,
    fontSize,
    lineWidth,
    borderRadius,
    controlHeight,
    sizeUnit,
    sizeStep,
    wireframe,
    defaultDark = false
  } = opts;
  return {
    theme: {
      algorithm: defaultDark ? theme.darkAlgorithm : void 0,
      token: Object.fromEntries(
        Object.entries({
          colorTextBase,
          colorPrimary,
          colorSuccess,
          colorWarning,
          colorError,
          colorInfo,
          colorBgBase,
          fontFamily,
          fontSize,
          lineWidth,
          borderRadius,
          controlHeight,
          sizeUnit,
          sizeStep,
          wireframe
        }).filter(([_key, val]) => !!val)
      )
    }
  };
}
function AntdConfigProvider(props) {
  const _a = props, { children, locale, themeStyles, loadingText, removeLoading } = _a, rest = __objRest$d(_a, ["children", "locale", "themeStyles", "loadingText", "removeLoading"]);
  return /* @__PURE__ */ React.createElement(
    ConfigProvider,
    __spreadValues$j({
      locale: locale != null ? locale : defaultLocale
    }, themeToAntdConfig(__spreadProps$b(__spreadValues$j({}, rest), {
      fontFamily: themeStyles.fontFamily,
      fontSize: themeStyles.fontSize ? parseInt(themeStyles.fontSize) : void 0,
      lineHeight: themeStyles.lineHeight ? parseInt(themeStyles.lineHeight) : void 0,
      colorTextBase: themeStyles.color
    }))),
    /* @__PURE__ */ React.createElement(ForkedApp, null, /* @__PURE__ */ React.createElement(
      InnerConfigProvider,
      {
        loadingText,
        removeLoading
      },
      children
    ))
  );
}
function normTokenValue(val) {
  if (typeof val === "string") {
    return val.trim();
  } else if (typeof val === "number") {
    return `${val}px`;
  } else {
    return val;
  }
}
function InnerConfigProvider(props) {
  const { children, loadingText, removeLoading } = props;
  const { token } = theme.useToken();
  const makeVarName = (name) => `--antd-${name}`;
  const cssStyles = React.useMemo(
    () => `
:root {
  ${Object.entries(token).map(([key, val]) => `${makeVarName(key)}:${normTokenValue(val)};`).join("\n")}
}
  `,
    [token]
  );
  const app = useAppContext();
  const actions = React.useMemo(
    () => ({
      showNotification: (type, message2, description, duration, placement) => {
        app.notification[type != null ? type : "info"]({
          message: message2 == null ? void 0 : message2.toString(),
          description: description == null ? void 0 : description.toString(),
          duration,
          placement
        });
      },
      hideNotifications: () => {
        app.notification.destroy();
      }
    }),
    [app]
  );
  const enableLoadingBoundary = !!useSelector(
    "plasmicInternalEnableLoadingBoundary"
  );
  if (!GlobalActionsProvider) {
    warnOutdatedDeps();
  }
  let content = GlobalActionsProvider ? /* @__PURE__ */ React.createElement(
    GlobalActionsProvider,
    {
      contextName: "plasmic-antd5-config-provider",
      actions
    },
    children
  ) : children;
  if (!removeLoading && enableLoadingBoundary) {
    content = /* @__PURE__ */ React.createElement(React.Suspense, null, content);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("style", { dangerouslySetInnerHTML: { __html: cssStyles } }), content, !removeLoading && /* @__PURE__ */ React.createElement(GlobalLoadingIndicator, { loadingText }));
}
let warned = false;
function warnOutdatedDeps() {
  if (!warned) {
    console.log(
      `You are using a version of @plasmicapp/* that is too old. Please upgrade to the latest version.`
    );
    warned = true;
  }
}
function GlobalLoadingIndicator(props) {
  const { loadingText } = props;
  const app = useAppContext();
  const isLoadingRef = React.useRef(false);
  const isMounted = useIsMounted();
  const showLoading = React.useCallback(() => {
    if (isMounted() && isLoadingRef.current) {
      app.message.open({
        content: loadingText != null ? loadingText : "Loading...",
        duration: 0,
        key: `plasmic-antd5-global-loading-indicator`
      });
    }
  }, [app, loadingText, isMounted, isLoadingRef]);
  const hideLoading = React.useCallback(() => {
    setTimeout(() => {
      if (isMounted() && !isLoadingRef.current) {
        app.message.destroy(`plasmic-antd5-global-loading-indicator`);
      }
    }, 500);
  }, [app, isMounted, isLoadingRef]);
  React.useEffect(() => {
    if (addLoadingStateListener) {
      if (isLoadingRef.current) {
        showLoading();
      } else {
        hideLoading();
      }
      return addLoadingStateListener(
        (isLoading) => {
          isLoadingRef.current = isLoading;
          if (isMounted()) {
            if (isLoading) {
              showLoading();
            } else {
              hideLoading();
            }
          }
        },
        // Disabled immediat because it's creating an infinite rendering
        // https://app.shortcut.com/plasmic/story/36991
        { immediate: false }
      );
    } else {
      warnOutdatedDeps();
      return () => {
      };
    }
  }, [app, isMounted, isLoadingRef, showLoading, hideLoading]);
  return null;
}
const ForkedAppContext = React.createContext(void 0);
function useAppContext() {
  const context = React.useContext(ForkedAppContext);
  if (!context) {
    throw new Error("Must call useAppContext from under ForkedApp");
  }
  return context;
}
function ForkedApp(props) {
  const [messageApi, messageContextHolder] = message.useMessage();
  const [notificationApi, notificationContextHolder] = notification.useNotification();
  const appContext = React.useMemo(
    () => ({
      message: messageApi,
      notification: notificationApi
    }),
    [messageApi, notificationApi]
  );
  return /* @__PURE__ */ React.createElement(ForkedAppContext.Provider, { value: appContext }, messageContextHolder, notificationContextHolder, props.children);
}
function registerTokens(loader) {
  const regs = [];
  const withoutPrefix = (name, prefix) => {
    if (!prefix) {
      return name;
    }
    const index = name.indexOf(prefix);
    return index === 0 ? name.substring(prefix.length) : name;
  };
  function makeNiceName(name) {
    name = name[0].toUpperCase() + name.substring(1);
    return name.replace(/([a-z])([A-Z])/g, "$1 $2");
  }
  const makeGenericToken = (name, type, removePrefix) => {
    const tokenName = Array.isArray(name) ? name[0] : name;
    const displayName = Array.isArray(name) ? name[1] : makeNiceName(withoutPrefix(name, removePrefix));
    return {
      name: tokenName,
      displayName: `System: ${displayName}`,
      value: `var(--antd-${tokenName})`,
      type
    };
  };
  const colorTokens = [
    // Seed tokens
    "colorPrimary",
    "colorSuccess",
    "colorWarning",
    "colorError",
    "colorInfo",
    // Map tokens
    //   - neutral
    "colorText",
    "colorTextSecondary",
    "colorTextTertiary",
    "colorTextQuaternary",
    "colorBorder",
    "colorBorderSecondary",
    "colorFill",
    "colorFillSecondary",
    "colorFillTertiary",
    "colorFillQuaternary",
    "colorBgLayout",
    "colorBgContainer",
    "colorBgElevated",
    "colorBgSpotlight",
    //    - primary
    "colorPrimaryBg",
    "colorPrimaryBgHover",
    "colorPrimaryBorder",
    "colorPrimaryBorderHover",
    "colorPrimaryHover",
    "colorPrimaryActive",
    "colorPrimaryTextHover",
    "colorPrimaryText",
    "colorPrimaryTextActive",
    //    - success
    "colorSuccessBg",
    "colorSuccessBgHover",
    "colorSuccessBorder",
    "colorSuccessBorderHover",
    "colorSuccessHover",
    "colorSuccessActive",
    "colorSuccessTextHover",
    "colorSuccessText",
    "colorSuccessTextActive",
    //    - warning
    "colorWarningBg",
    "colorWarningBgHover",
    "colorWarningBorder",
    "colorWarningBorderHover",
    "colorWarningHover",
    "colorWarningActive",
    "colorWarningTextHover",
    "colorWarningText",
    "colorWarningTextActive",
    //    - info
    "colorInfoBg",
    "colorInfoBgHover",
    "colorInfoBorder",
    "colorInfoBorderHover",
    "colorInfoHover",
    "colorInfoActive",
    "colorInfoTextHover",
    "colorInfoText",
    "colorInfoTextActive",
    //    - error
    "colorErrorBg",
    "colorErrorBgHover",
    "colorErrorBorder",
    "colorErrorBorderHover",
    "colorErrorHover",
    "colorErrorActive",
    "colorErrorTextHover",
    "colorErrorText",
    "colorErrorTextActive",
    //    - other
    "colorWhite",
    "colorBgMask",
    // Alias tokens
    // "colorFillContentHover",
    // "colorFillAlter",
    // "colorFillContent",
    // "colorBgContainerDisabled",
    // "colorBgTextHover",
    // "colorBgTextActive",
    // "colorBorderBg",
    // "colorSplit",
    // "colorTextPlaceholder",
    // "colorTextDisabled",
    // "colorTextHeading",
    // "colorTextLabel",
    // "colorTextDescription",
    // "colorTextLightSolid",
    "colorIcon",
    "colorIconHover",
    "colorLink",
    "colorLinkHover"
    // "colorLinkActive",
    // "colorLinkHighlight",
    // "controlOutline",
    // "controlWarningOutline",
    // "controlErrorOutline",
    // "controlItemBgHover",
    // "controlItemBgActive",
    // "controlItemBgActiveHover",
    // "controlItemBgActiveDisabled",
  ];
  colorTokens.forEach(
    (name) => regs.push(makeGenericToken(name, "color", "color"))
  );
  const spacingTokens = [
    // Seed
    // "lineWidth",
    // "borderRadius",
    // "controlHeight",
    // Map tokens
    // "sizeXXL",
    // "sizeXL",
    // "sizeLG",
    // "sizeMD",
    // "sizeMS",
    // "size",
    // "sizeSM",
    // "sizeXS",
    // "sizeXXS",
    // "controlHeightXS",
    // "controlHeightSM",
    // "controlHeightLG",
    // "lineWidthBold",
    // "borderRadiusXS",
    // "borderRadiusSM",
    // "borderRadiusLG",
    // "borderRadiusOuter",
    // Alias tokens
    // "controlOutlineWidth",
    // "controlInteractiveSize",
    "paddingXXS",
    "paddingXS",
    "paddingSM",
    ["padding", "Padding M"],
    "paddingMD",
    "paddingLG",
    "paddingXL",
    // "paddingContentHorizontalLG",
    // "paddingContentHorizontal",
    // "paddingContentHorizontalSM",
    // "paddingContentVerticalLG",
    // "paddingContentVertical",
    // "paddingContentVerticalSM",
    "marginXXS",
    "marginXS",
    "marginSM",
    ["margin", "Margin M"],
    "marginMD",
    "marginLG",
    "marginXL",
    "marginXXL"
    // "controlPaddingHorizontal",
    // "controlPaddingHorizontalSM",
  ];
  spacingTokens.forEach(
    (token) => regs.push(makeGenericToken(token, "spacing"))
  );
  const fontSizeTokens = [
    // Seed token
    ["fontSize", "M"],
    // Map tokens
    "fontSizeSM",
    "fontSizeLG",
    "fontSizeXL",
    "fontSizeHeading1",
    "fontSizeHeading2",
    "fontSizeHeading3",
    "fontSizeHeading4",
    "fontSizeHeading5"
  ];
  fontSizeTokens.forEach(
    (token) => regs.push(makeGenericToken(token, "font-size", "fontSize"))
  );
  const lineHeightTokens = [
    // Map tokens
    ["lineHeight", "M"],
    "lineHeightLG",
    "lineHeightSM",
    "lineHeightHeading1",
    "lineHeightHeading2",
    "lineHeightHeading3",
    "lineHeightHeading4",
    "lineHeightHeading5"
  ];
  lineHeightTokens.forEach(
    (token) => regs.push(makeGenericToken(token, "line-height", "lineHeight"))
  );
  if (loader) {
    regs.forEach((t) => loader.registerToken(t));
  } else {
    regs.forEach((t) => registerToken(t));
  }
}
const registerConfigProvider = makeRegisterGlobalContext(
  AntdConfigProvider,
  __spreadProps$b(__spreadValues$j({
    name: "plasmic-antd5-config-provider",
    displayName: "Ant Design System Settings",
    props: {
      colorPrimary: {
        type: "color",
        defaultValue: "#1677ff",
        disableTokens: true
      },
      colorSuccess: {
        type: "color",
        defaultValue: "#52c41a",
        disableTokens: true
      },
      colorWarning: {
        type: "color",
        defaultValue: "#faad14",
        disableTokens: true
      },
      colorError: {
        type: "color",
        defaultValue: "#ff4d4f",
        disableTokens: true
      },
      colorInfo: {
        type: "color",
        defaultValue: "#1677ff",
        disableTokens: true
      },
      colorBgBase: {
        type: "color",
        defaultValue: "#ffffff",
        disableTokens: true
      },
      lineWidth: {
        type: "number",
        defaultValue: 1
      },
      borderRadius: {
        type: "number",
        defaultValue: 6
      },
      controlHeight: {
        type: "number",
        defaultValue: 32
      },
      sizeUnit: {
        type: "number",
        defaultValue: 4
      },
      sizeStep: {
        type: "number",
        defaultValue: 4
      },
      loadingText: {
        type: "string",
        defaultValueHint: "Loading..."
      },
      removeLoading: {
        type: "boolean",
        defaultValueHint: false
      },
      wireframe: {
        type: "boolean",
        defaultValue: false
      },
      defaultDark: {
        type: "boolean",
        defaultValue: false
      },
      themeStyles: {
        type: "themeStyles"
      }
    }
  }, {
    globalActions: {
      showNotification: {
        displayName: "Show notification",
        parameters: [
          {
            name: "type",
            type: {
              type: "choice",
              options: ["success", "error", "info", "warning"],
              defaultValue: "info"
            }
          },
          {
            name: "message",
            type: {
              type: "string",
              defaultValue: "A message for you!"
            }
          },
          {
            name: "description",
            type: {
              type: "string",
              defaultValue: "Would you like to learn more?"
            }
          },
          {
            name: "duration",
            type: {
              type: "number",
              defaultValueHint: 5
            }
          },
          {
            name: "placement",
            type: {
              type: "choice",
              options: [
                "top",
                "topLeft",
                "topRight",
                "bottom",
                "bottomLeft",
                "bottomRight"
              ],
              defaultValueHint: "topRight"
            }
          }
        ]
      },
      hideNotifications: {
        displayName: "Hide notifications",
        parameters: []
      }
    }
  }), {
    importPath: "@plasmicpkgs/antd5/skinny/registerConfigProvider",
    importName: "AntdConfigProvider"
  })
);

var __defProp$i = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$i = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$i(a, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$i(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$a = (a, b) => __defProps$a(a, __getOwnPropDescs$a(b));
var __objRest$c = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$i.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$i.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
dayjs.extend(weekday);
dayjs.extend(localeData);
const { RangePicker } = DatePicker;
function getDayjsRange(dateRange) {
  return Array.isArray(dateRange) ? [
    dateRange[0] ? dayjs(dateRange[0]) : null,
    dateRange[1] ? dayjs(dateRange[1]) : null
  ] : [null, null];
}
function getStrRange(dateRange) {
  return Array.isArray(dateRange) ? dateRange.map(
    (date) => date && !(typeof date === "string") && "toISOString" in date ? date.toISOString() : date === null ? void 0 : date
  ) : void 0;
}
function AntdDateRangePicker(props) {
  const _a = props, {
    defaultStartDate,
    defaultEndDate,
    startDate,
    endDate,
    allowEmpty,
    allowEmptyEndDate,
    allowEmptyStartDate,
    disabled,
    renderExtraFooter,
    disableStartDate,
    disableEndDate,
    presets,
    picker,
    placeholder,
    onChange,
    popupScopeClassName,
    className
  } = _a, rest = __objRest$c(_a, [
    "defaultStartDate",
    "defaultEndDate",
    "startDate",
    "endDate",
    "allowEmpty",
    "allowEmptyEndDate",
    "allowEmptyStartDate",
    "disabled",
    "renderExtraFooter",
    "disableStartDate",
    "disableEndDate",
    "presets",
    "picker",
    "placeholder",
    "onChange",
    "popupScopeClassName",
    "className"
  ]);
  const css = `
    @media(max-width: 500px) {
      .ant-picker-dropdown {
        top: 20px !important;
        left: 10px !important;
        right: 10px !important;
        max-height: 95vh;
        position: fixed;
        overflow-y: scroll;
      }

      .ant-picker-panel-layout {
        flex-direction: column;
      }

      .ant-picker-presets {
        min-height: 50px;
        min-width: 100% !important;
      }

      .ant-picker-presets > ul {
        overflow-y: hidden;
        overflow-x: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
        flex-direction: column;
      }

      .ant-picker-presets > ul > li {
        margin: 0 !important;
      }

      .ant-picker-panel-container {
        width: 300px;
      }

      .ant-picker-datetime-panel {
        flex-direction: column;
      }

      .${className} .ant-picker-input > input {
        font-size: 16px !important;
      }

      .ant-picker-header-view {
        line-height: unset !important;
      }

      .ant-picker-content {
        height: unset !important;
      }

      .ant-picker-time-panel-column {
        height: 100px;
      }

      .ant-picker-time-panel-column::after {
        height: 0px !important;
      }

      .ant-picker-range-arrow {
        display: none;
      }
    }
  `;
  const presetsDayjs = useMemo(
    () => presets == null ? void 0 : presets.map((p) => __spreadProps$a(__spreadValues$i({}, p), { value: getDayjsRange([p.startDate, p.endDate]) })).filter((p) => {
      var _a2, _b;
      return ((_a2 = p.value[0]) == null ? void 0 : _a2.isValid()) && ((_b = p.value[1]) == null ? void 0 : _b.isValid());
    }),
    [presets]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    RangePicker,
    __spreadProps$a(__spreadValues$i({}, rest), {
      picker,
      presets: presetsDayjs,
      allowEmpty: allowEmpty ? [allowEmpty, allowEmpty] : [allowEmptyStartDate, allowEmptyEndDate],
      value: getDayjsRange([startDate, endDate]),
      defaultValue: getDayjsRange([defaultStartDate, defaultEndDate]),
      renderExtraFooter: renderExtraFooter ? () => renderExtraFooter : void 0,
      className,
      inputReadOnly: true,
      disabled: disabled ? disabled : [disableStartDate, disableEndDate],
      placeholder: placeholder == null ? void 0 : placeholder.split(/,\s*/).slice(0, 2),
      popupClassName: popupScopeClassName,
      onChange: (values, _dateStrings) => {
        onChange == null ? void 0 : onChange(getStrRange(values) || [null, null]);
      }
    })
  ), /* @__PURE__ */ React.createElement("style", { dangerouslySetInnerHTML: { __html: css } }));
}
const dateRangePickerComponentName = "plasmic-antd5-date-range-picker";
const dateRangePickerHelpers = {
  states: {
    startDate: {
      onChangeArgsToValue: (value) => value[0],
      hidden: (ps) => !!ps.__plasmicFormField
    },
    endDate: {
      onChangeArgsToValue: (value) => value[1],
      hidden: (ps) => !!ps.__plasmicFormField
    }
  }
};
function registerDateRangePicker(loader) {
  registerComponentHelper(loader, AntdDateRangePicker, {
    name: dateRangePickerComponentName,
    displayName: "Date Range Picker",
    props: {
      startDate: {
        type: "dateString",
        editOnly: true,
        uncontrolledProp: "defaultStartDate",
        description: "The default start date as ISO strings",
        // TODO: Can there be a default validator attached to each prop type, so dynamic values can be checked?
        hidden: (ps) => !!ps.__plasmicFormField
      },
      endDate: {
        type: "dateString",
        editOnly: true,
        uncontrolledProp: "defaultEndDate",
        description: "The default end date as ISO strings",
        // TODO: Can there be a default validator attached to each prop type, so dynamic values can be checked?
        hidden: (ps) => !!ps.__plasmicFormField
      },
      allowClear: {
        type: "boolean",
        advanced: true,
        defaultValueHint: true,
        description: "Whether to show the clear button"
      },
      autoFocus: {
        type: "boolean",
        description: "Focus when component is rendered",
        defaultValueHint: false,
        advanced: true
      },
      bordered: {
        type: "boolean",
        advanced: true,
        defaultValueHint: true
      },
      changeOnBlur: {
        type: "boolean",
        advanced: true,
        description: "Trigger change when blur. e.g. datetime picker no need click confirm button",
        defaultValueHint: false,
        hidden: (ps) => !ps.showTime
      },
      disabled: {
        type: "boolean",
        description: "Disable date range inputs",
        defaultValueHint: false
      },
      disableStartDate: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: "Disable start date input only",
        hidden: (ps) => ps.disabled
      },
      disableEndDate: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: "Disable end date input only",
        hidden: (ps) => ps.disabled
      },
      picker: {
        type: "choice",
        options: ["date", "week", "month", "quarter", "year"].map((value) => ({
          value,
          label: capitalize(value)
        })),
        defaultValueHint: "date"
      },
      placeholder: {
        type: "string",
        advanced: true,
        defaultValueHint: "Start date, End date",
        description: "The placeholders of the start and end date inputs, separated by a comma"
      },
      placement: {
        type: "choice",
        options: ["bottomLeft", "bottomRight", "topLeft", "topRight"].map(
          (value) => ({
            value,
            label: kebabCase(value)
          })
        ),
        advanced: true,
        defaultValueHint: "bottom-left",
        description: "The position where the selection box pops up"
      },
      presets: {
        type: "array",
        advanced: true,
        description: "The preset ranges for quick selection",
        itemType: {
          type: "object",
          nameFunc: (item) => item.label,
          fields: {
            label: "string",
            startDate: {
              type: "dateString"
            },
            endDate: {
              type: "dateString"
            }
          }
        }
      },
      size: {
        type: "choice",
        advanced: true,
        options: ["small", "middle", "large"].map((value) => ({
          value,
          label: capitalize(value)
        })),
        defaultValueHint: "middle"
      },
      status: {
        type: "choice",
        advanced: true,
        options: ["error", "warning"].map((value) => ({
          value,
          label: capitalize(value)
        })),
        description: "Set validation status"
      },
      allowEmpty: {
        type: "boolean",
        advanced: true,
        description: "Allow leaving start or end input empty",
        defaultValueHint: false
      },
      allowEmptyStartDate: {
        type: "boolean",
        advanced: true,
        description: "Allow leaving start input empty",
        defaultValueHint: false,
        hidden: (ps) => ps.allowEmpty
      },
      allowEmptyEndDate: {
        type: "boolean",
        advanced: true,
        description: "Allow leaving end input empty",
        defaultValueHint: false,
        hidden: (ps) => ps.allowEmpty
      },
      renderExtraFooter: {
        type: "slot",
        displayName: "Extra footer",
        hidePlaceholder: true
      },
      showTime: {
        type: "boolean",
        description: "Enable time selection",
        defaultValueHint: false,
        hidden: (ps) => ps.picker !== void 0 && ps.picker !== "date"
      },
      popupScopeClassName: {
        type: "styleScopeClass",
        scopeName: "dateRangePickerPopup"
      },
      popupClassName: {
        type: "class",
        displayName: "Popup container",
        selectors: [
          {
            selector: ":dateRangePickerPopup .ant-picker-panel-container",
            label: "Base"
          }
        ]
      },
      popupHeaderClassName: {
        type: "class",
        displayName: "Popup header",
        selectors: [
          {
            selector: ":dateRangePickerPopup .ant-picker-header",
            label: "Base"
          }
        ]
      },
      popupBodyClassName: {
        type: "class",
        displayName: "Popup body",
        selectors: [
          {
            selector: ":dateRangePickerPopup .ant-picker-body",
            label: "Base"
          }
        ]
      },
      popupFooterClassName: {
        type: "class",
        displayName: "Popup footer",
        selectors: [
          {
            selector: ":dateRangePickerPopup .ant-picker-footer",
            label: "Base"
          }
        ]
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "object" }]
      }
    },
    states: {
      startDate: __spreadValues$i({
        type: "writable",
        valueProp: "startDate",
        onChangeProp: "onChange",
        variableType: "text"
      }, dateRangePickerHelpers.states.startDate),
      endDate: __spreadValues$i({
        type: "writable",
        valueProp: "endDate",
        onChangeProp: "onChange",
        variableType: "text"
      }, dateRangePickerHelpers.states.endDate)
    },
    componentHelpers: {
      helpers: dateRangePickerHelpers,
      importName: "dateRangePickerHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerDateRangePicker"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerDateRangePicker",
    importName: "AntdDateRangePicker"
  });
}

var __defProp$h = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$h = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$h(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$h(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));
var __objRest$b = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$h.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$h.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdDrawer(props) {
  const _a = props, { onOpenChange, onClose, open, footer, drawerScopeClassName } = _a, rest = __objRest$b(_a, ["onOpenChange", "onClose", "open", "footer", "drawerScopeClassName"]);
  const memoOnClose = React.useMemo(() => {
    if (onOpenChange || onClose) {
      return (e) => {
        onOpenChange == null ? void 0 : onOpenChange(false);
        onClose == null ? void 0 : onClose(e);
      };
    } else {
      return void 0;
    }
  }, [onOpenChange, onClose]);
  return /* @__PURE__ */ React.createElement(
    Drawer,
    __spreadProps$9(__spreadValues$h({}, rest), {
      onClose: memoOnClose,
      rootClassName: drawerScopeClassName,
      open,
      footer: footer != null ? footer : void 0,
      className: `${props.className} ${props.defaultStylesClassName}`
    })
  );
}
function registerDrawer(loader) {
  registerComponentHelper(loader, AntdDrawer, {
    name: "plasmic-antd5-drawer",
    displayName: "Drawer",
    props: {
      open: {
        type: "boolean"
      },
      placement: {
        type: "choice",
        options: ["top", "right", "bottom", "left"],
        defaultValueHint: "right"
      },
      children: {
        type: "slot",
        defaultValue: {
          type: "vbox",
          children: ["Drawer content"]
        }
      },
      title: {
        type: "slot",
        defaultValue: "Drawer title"
      },
      footer: {
        type: "slot",
        hidePlaceholder: true
      },
      closeIcon: {
        type: "slot",
        hidePlaceholder: true
      },
      onOpenChange: {
        type: "eventHandler",
        argTypes: [{ name: "open", type: "boolean" }]
      },
      drawerScopeClassName: {
        type: "styleScopeClass",
        scopeName: "drawer"
      },
      drawerHeaderClassName: {
        type: "class",
        displayName: "Drawer header",
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-header",
            label: "Base"
          }
        ]
      },
      drawerBodyClassName: {
        type: "class",
        displayName: "Drawer body",
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-body",
            label: "Base"
          }
        ]
      },
      drawerFooterClassName: {
        type: "class",
        displayName: "Drawer footer",
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-footer",
            label: "Base"
          }
        ]
      },
      drawerTitleClassName: {
        type: "class",
        displayName: "Drawer title",
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-title",
            label: "Base"
          }
        ]
      },
      drawerMaskClassName: {
        type: "class",
        displayName: "Drawer mask",
        styleSections: ["background"],
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-mask",
            label: "Base"
          }
        ]
      },
      drawerContentWrapperClassName: {
        type: "class",
        displayName: "Drawer content wrapper",
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-content-wrapper",
            label: "Base"
          }
        ],
        advanced: true
      },
      closeButtonClassName: {
        type: "class",
        displayName: "Close button",
        noSelf: true,
        selectors: [
          {
            selector: ":drawer .ant-drawer-close",
            label: "Base"
          }
        ],
        advanced: true
      },
      forceRender: {
        advanced: true,
        type: "boolean"
      },
      defaultStylesClassName: {
        type: "themeResetClass"
      }
    },
    states: {
      open: {
        type: "writable",
        valueProp: "open",
        onChangeProp: "onOpenChange",
        variableType: "boolean"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerDrawer",
    importName: "AntdDrawer"
  });
}

var __defProp$g = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$g = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$g(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$g(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));
const AntdMenuDivider = Menu.Divider;
const AntdMenuItem = Menu.Item;
const AntdMenuItemGroup = Menu.ItemGroup;
const AntdSubMenu = Menu.SubMenu;
const allowedMenuComponents = [
  "plasmic-antd5-menu-item",
  "plasmic-antd5-menu-divider",
  "plasmic-antd5-submenu",
  "plasmic-antd5-menu-item-group"
];
const MENU_ITEM_TYPE = {
  type: "object",
  nameFunc: (item) => {
    if (item.type === "divider") {
      return "Divider";
    }
    return item.label || item.value;
  },
  fields: {
    type: {
      type: "choice",
      options: [
        { value: "item", label: "Menu item" },
        { value: "group", label: "Menu item group" },
        { value: "submenu", label: "Sub-menu" },
        { value: "divider", label: "Menu divider" }
      ],
      defaultValue: "item"
    },
    key: {
      type: "string",
      displayName: "Menu item key",
      description: "Key of the menu item; the onClick will receive this as the value to indicate which item was clicked.",
      hidden: (ps, ctx, { item }) => item.type !== "item"
    },
    label: {
      type: "string",
      description: "Label of the menu item; will use the key if not specified.",
      hidden: (ps, ctx, { item }) => item.type === "divider"
    },
    children: {
      type: "array",
      displayName: "Menu items",
      hidden: (ps, ctx, { item }) => item.type !== "submenu" && item.type !== "group"
    },
    onClick: {
      type: "eventHandler",
      displayName: "Action",
      description: "Action to perform when this item is selected",
      argTypes: [{ name: "info", type: "object" }],
      hidden: (ps, ctx, { item }) => item.type !== "item"
    }
  }
};
const UNKEYED_MENU_ITEM_TYPE = __spreadProps$8(__spreadValues$g({}, MENU_ITEM_TYPE), {
  fields: Object.fromEntries(
    Object.entries(MENU_ITEM_TYPE.fields).filter(([k]) => k !== "key")
  )
});
MENU_ITEM_TYPE.fields.children.itemType = MENU_ITEM_TYPE;
UNKEYED_MENU_ITEM_TYPE.fields.children.itemType = UNKEYED_MENU_ITEM_TYPE;
function registerMenu(loader) {
  registerComponentHelper(loader, Menu, {
    name: "plasmic-antd5-menu",
    displayName: "Menu",
    props: {
      expandIcon: {
        type: "slot",
        hidePlaceholder: true
      },
      mode: {
        type: "choice",
        options: ["horizontal", "vertical", "inline"],
        description: "Type of menu",
        defaultValueHint: "vertical"
      },
      multiple: {
        type: "boolean",
        description: "Allows selection of multiple items",
        defaultValueHint: false
      },
      triggerSubMenuAction: {
        type: "choice",
        options: ["hover", "click"],
        description: "Which action can trigger submenu open/close",
        defaultValueHint: "hover",
        advanced: true
      },
      defaultSelectedKeys: {
        type: "array",
        description: 'An array of Menu Item/s that will be selected when this component first loads, eg ["home", "about"]. Each item in the array should be one of the unique keys set in nested Menu Item component props. Useful when using the Menu component to build a website navigation bar.',
        advanced: true
      },
      //   menuScopeClassName: {
      //     type: "styleScopeClass",
      //     scopeName: "menu",
      //   } as any,
      //   menuItemClassName: {
      //     type: "class",
      //     displayName: "Menu items",
      //     noSelf: true,
      //     selectors: [
      //         {
      //             selector: ":menu .ant-menu-item",
      //             label: "Base",
      //         },
      //         {
      //             selector: ":menu .ant-menu-item-selected",
      //             label: "Selected",
      //         },
      //     ],
      //   } as any,
      children: {
        type: "slot",
        allowedComponents: allowedMenuComponents,
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-menu-item",
            props: {
              key: "menuItemKey1"
            }
          },
          {
            type: "component",
            name: "plasmic-antd5-menu-item",
            props: {
              key: "menuItemKey2"
            }
          }
        ]
      },
      onSelect: {
        type: "eventHandler",
        argTypes: [{ name: "key", type: "string" }]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerMenu",
    importName: "AntdMenu"
  });
  registerComponentHelper(loader, AntdMenuItem, {
    name: "plasmic-antd5-menu-item",
    displayName: "Menu Item",
    props: {
      danger: {
        type: "boolean",
        description: "Display the danger style",
        defaultValueHint: false
      },
      disabled: {
        type: "boolean",
        description: "Whether disabled select",
        defaultValueHint: false
      },
      key: {
        type: "string",
        displayName: "Unique key",
        description: "Unique ID of the menu item. Used to determine which item is selected.",
        defaultValue: "menuItemKey"
      },
      title: {
        type: "string",
        description: "Set display title for collapsed item"
      },
      children: __spreadValues$g({
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Menu item"
          }
        ]
      }, { mergeWithParent: true }),
      onClick: {
        type: "eventHandler",
        argTypes: []
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerMenu",
    importName: "AntdMenuItem",
    parentComponentName: "plasmic-antd5-menu"
  });
  registerComponentHelper(loader, AntdMenuItemGroup, {
    name: "plasmic-antd5-menu-item-group",
    displayName: "Item Group",
    props: {
      title: {
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Group"
          }
        ]
      },
      children: {
        type: "slot",
        allowedComponents: allowedMenuComponents,
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-menu-item"
          }
        ]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerMenu",
    importName: "AntdMenuItemGroup",
    parentComponentName: "plasmic-antd5-menu"
  });
  registerComponentHelper(loader, AntdMenuDivider, {
    name: "plasmic-antd5-menu-divider",
    displayName: "Menu Divider",
    props: {
      dashed: {
        type: "boolean",
        description: "Whether line is dashed",
        defaultValueHint: false
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerMenu",
    importName: "AntdMenuDivider",
    parentComponentName: "plasmic-antd5-menu"
  });
  registerComponentHelper(loader, AntdSubMenu, {
    name: "plasmic-antd5-submenu",
    displayName: "Sub Menu",
    props: {
      disabled: {
        type: "boolean",
        description: "Whether sub-menu is disabled",
        defaultValueHint: false
      },
      key: {
        type: "string",
        displayName: "Unique key",
        description: "Unique ID of the sub-menu. Used to determine which item is selected.",
        advanced: true
      },
      title: {
        type: "slot",
        defaultValue: [
          {
            type: "text",
            value: "Sub-menu"
          }
        ]
      },
      popupClassName: {
        type: "class",
        displayName: "Sidemenu Popup"
      },
      children: {
        type: "slot",
        allowedComponents: allowedMenuComponents,
        defaultValue: [1, 2].map((i) => ({
          type: "component",
          name: "plasmic-antd5-menu-item",
          props: {
            key: `subMenuItemKey${i}`,
            children: [
              {
                type: "text",
                value: `Sub-menu item ${i}`
              }
            ]
          }
        }))
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerMenu",
    importName: "AntdSubMenu",
    parentComponentName: "plasmic-antd5-menu"
  });
}

var __defProp$f = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
var __objRest$a = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function addKeysToUnkeyedMenuItems(unkeyedMenuItems, maybeGenKey) {
  const genKey = maybeGenKey != null ? maybeGenKey : (() => {
    let key = 0;
    return () => {
      return `${key++}`;
    };
  })();
  return unkeyedMenuItems == null ? void 0 : unkeyedMenuItems.map((item) => {
    if (!item) {
      return null;
    }
    const newItem = __spreadValues$f({}, item);
    if (!newItem.key) {
      newItem.key = genKey();
    }
    if ("children" in newItem && newItem.children) {
      newItem.children = addKeysToUnkeyedMenuItems(newItem.children, genKey);
    }
    return newItem;
  });
}
function AntdDropdown(props) {
  const _a = props, {
    children,
    onAction,
    menuItems,
    useMenuItemsSlot = false,
    menuItemsJson: unkeyedMenuItems,
    trigger = "click",
    dropdownMenuScopeClassName
  } = _a, rest = __objRest$a(_a, [
    "children",
    "onAction",
    "menuItems",
    "useMenuItemsSlot",
    "menuItemsJson",
    "trigger",
    "dropdownMenuScopeClassName"
  ]);
  const keyedMenuItems = addKeysToUnkeyedMenuItems(unkeyedMenuItems);
  return /* @__PURE__ */ React.createElement(
    Dropdown,
    __spreadProps$7(__spreadValues$f({}, rest), {
      trigger: [trigger],
      overlay: () => {
        var _a2;
        const itemsChildren = useMenuItemsSlot ? (_a2 = menuItems == null ? void 0 : menuItems()) != null ? _a2 : [] : void 0;
        const items = useMenuItemsSlot ? void 0 : keyedMenuItems;
        return /* @__PURE__ */ React.createElement(
          Menu,
          {
            className: `${dropdownMenuScopeClassName}`,
            onClick: (event) => onAction == null ? void 0 : onAction(event.key),
            items
          },
          itemsChildren
        );
      }
    }),
    typeof children === "string" ? /* @__PURE__ */ React.createElement("div", null, children) : children
  );
}
function registerDropdown(loader) {
  registerComponentHelper(loader, AntdDropdown, {
    name: "plasmic-antd5-dropdown",
    displayName: "Dropdown",
    props: {
      menuItems: {
        type: "slot",
        displayName: "Menu items",
        hidden: (ps) => !ps.useMenuItemsSlot,
        allowedComponents: [
          "plasmic-antd5-menu-item",
          "plasmic-antd5-menu-item-group",
          "plasmic-antd5-menu-divider",
          "plasmic-antd5-submenu"
        ],
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-menu-item",
            props: {
              key: "menu-item-1"
            }
          },
          {
            type: "component",
            name: "plasmic-antd5-menu-item",
            props: {
              key: "menu-item-2"
            }
          }
        ],
        renderPropParams: []
      },
      menuItemsJson: {
        type: "array",
        displayName: "Menu Items",
        hidden: (ps) => !!ps.useMenuItemsSlot,
        itemType: UNKEYED_MENU_ITEM_TYPE,
        defaultValue: [
          {
            type: "item",
            value: "action1",
            label: "Action 1"
          },
          {
            type: "item",
            value: "action2",
            label: "Action 2"
          }
        ]
      },
      dropdownMenuScopeClassName: {
        type: "styleScopeClass",
        scopeName: "dropdownMenu"
      },
      menuClassName: {
        type: "class",
        displayName: "Menu",
        selectors: [
          {
            selector: ":dropdownMenu.ant-dropdown-menu",
            label: "Base"
          }
        ]
      },
      menuItemClassName: {
        type: "class",
        displayName: "Menu item",
        selectors: [
          {
            selector: ":dropdownMenu.ant-dropdown-menu .ant-dropdown-menu-item",
            label: "Base"
          },
          {
            selector: ":dropdownMenu.ant-dropdown-menu .ant-dropdown-menu-item-active",
            label: "Focused"
          }
        ]
      },
      open: {
        type: "boolean",
        description: "Toggle visibility of dropdown menu in Plasmic Editor",
        editOnly: true,
        uncontrolledProp: "fakeOpen",
        defaultValueHint: false
      },
      disabled: {
        type: "boolean",
        description: "Whether the dropdown menu is disabled",
        defaultValueHint: false
      },
      placement: {
        type: "choice",
        options: [
          "bottomLeft",
          "bottomCenter",
          "bottomRight",
          "topLeft",
          "topCenter",
          "topRight"
        ],
        description: "Placement of popup menu",
        defaultValueHint: "bottomLeft",
        advanced: true
      },
      trigger: {
        type: "choice",
        options: [
          { value: "click", label: "Click" },
          { value: "hover", label: "Hover" },
          { value: "contextMenu", label: "Right-click" }
        ],
        description: "The trigger mode which executes the dropdown action",
        defaultValueHint: "click"
      },
      useMenuItemsSlot: {
        type: "boolean",
        displayName: "Use menu items slot",
        advanced: true,
        description: "Instead of configuring a list of menu items, build the menu items using MenuItem elements. This gives you greater control over item styling."
      },
      children: __spreadValues$f({
        type: "slot",
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-button",
            props: {
              children: {
                type: "text",
                value: "Dropdown"
              }
            }
          }
        ]
      }, { mergeWithParent: true }),
      onAction: {
        type: "eventHandler",
        argTypes: [{ name: "key", type: "string" }]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerDropdown",
    importName: "AntdDropdown"
  });
}

var __defProp$e = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
const AntdInput = Input;
const AntdTextArea = Input.TextArea;
const AntdPassword = Input.Password;
const AntdInputNumber = InputNumber;
const inputHelpers = {
  states: {
    value: {
      onChangeArgsToValue: (e) => {
        return e.target.value;
      }
    }
  }
};
const COMMON_HELPERS_CONFIG = {
  helpers: inputHelpers,
  importName: "inputHelpers",
  importPath: "@plasmicpkgs/antd5/skinny/registerInput"
};
const COMMON_STATES = {
  value: {
    type: "writable",
    valueProp: "value",
    variableType: "text",
    onChangeProp: "onChange",
    hidden: (ps) => !!ps.__plasmicFormField
  }
};
const COMMON_DECORATOR_PROPS = {
  prefix: {
    type: "slot",
    hidePlaceholder: true
  },
  suffix: {
    type: "slot",
    hidePlaceholder: true
  },
  addonAfter: {
    type: "slot",
    hidePlaceholder: true
  },
  addonBefore: {
    type: "slot",
    hidePlaceholder: true
  }
};
const COMMON_ADVANCED_PROPS = {
  maxLength: {
    type: "number",
    advanced: true
  },
  bordered: {
    type: "boolean",
    advanced: true,
    defaultValueHint: true
  },
  allowClear: {
    type: "boolean",
    advanced: true
  },
  autoFocus: {
    type: "boolean",
    advanced: true
  },
  readOnly: {
    type: "boolean",
    advanced: true
  }
};
const COMMON_EVENT_HANDLERS = {
  onChange: {
    type: "eventHandler",
    argTypes: [
      {
        name: "event",
        type: "object"
      }
    ]
  },
  onPressEnter: {
    type: "eventHandler",
    argTypes: [
      {
        name: "event",
        type: "object"
      }
    ]
  }
};
const inputTypeOptions = [
  "text",
  "password",
  "number",
  "date",
  "datetime-local",
  "time",
  "email",
  "tel",
  "hidden"
];
function registerInput(loader) {
  registerComponentHelper(loader, AntdInput, __spreadProps$6(__spreadValues$e({
    name: inputComponentName,
    displayName: "Input",
    styleSections: ["visibility"],
    props: __spreadValues$e(__spreadValues$e(__spreadValues$e({
      value: {
        type: "string",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      placeholder: {
        type: "string"
      },
      size: {
        type: "choice",
        options: ["large", "middle", "small"]
      },
      disabled: {
        type: "boolean"
      },
      type: {
        type: "choice",
        options: inputTypeOptions,
        defaultValueHint: "text"
      }
    }, COMMON_ADVANCED_PROPS), COMMON_DECORATOR_PROPS), COMMON_EVENT_HANDLERS),
    states: __spreadValues$e({}, COMMON_STATES)
  }, { trapsSelection: true }), {
    componentHelpers: COMMON_HELPERS_CONFIG,
    importPath: "@plasmicpkgs/antd5/skinny/registerInput",
    importName: "AntdInput"
  }));
}
function registerTextArea(loader) {
  registerComponentHelper(loader, AntdTextArea, {
    name: textAreaComponentName,
    parentComponentName: inputComponentName,
    displayName: "Text Area",
    styleSections: ["visibility"],
    props: __spreadValues$e({
      value: {
        type: "string",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      placeholder: {
        type: "string"
      },
      disabled: {
        type: "boolean"
      },
      maxLength: {
        type: "number",
        advanced: true
      },
      bordered: {
        type: "boolean",
        advanced: true,
        defaultValueHint: true
      },
      autoSize: {
        type: "boolean",
        displayName: "Auto grow height?"
      }
    }, COMMON_EVENT_HANDLERS),
    states: __spreadValues$e({}, COMMON_STATES),
    componentHelpers: COMMON_HELPERS_CONFIG,
    importPath: "@plasmicpkgs/antd5/skinny/registerInput",
    importName: "AntdTextArea"
  });
}
function registerPasswordInput(loader) {
  registerComponentHelper(loader, AntdPassword, {
    name: passwordComponentName,
    parentComponentName: inputComponentName,
    displayName: "Password Input",
    styleSections: ["visibility"],
    props: __spreadValues$e({
      value: {
        type: "string",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      placeholder: {
        type: "string"
      },
      disabled: {
        type: "boolean"
      },
      maxLength: {
        type: "number",
        advanced: true
      },
      bordered: {
        type: "boolean",
        advanced: true,
        defaultValueHint: true
      }
    }, COMMON_EVENT_HANDLERS),
    states: __spreadValues$e({}, COMMON_STATES),
    componentHelpers: COMMON_HELPERS_CONFIG,
    importPath: "@plasmicpkgs/antd5/skinny/registerInput",
    importName: "AntdPassword"
  });
}
function registerNumberInput(loader) {
  registerComponentHelper(loader, AntdInputNumber, __spreadProps$6(__spreadValues$e({
    name: inputNumberComponentName,
    parentComponentName: inputComponentName,
    displayName: "Number Input",
    styleSections: ["visibility"],
    props: __spreadProps$6(__spreadValues$e(__spreadValues$e(__spreadValues$e({
      value: {
        type: "number",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      placeholder: {
        type: "string"
      },
      disabled: {
        type: "boolean"
      },
      max: {
        type: "number"
      },
      min: {
        type: "number"
      },
      step: {
        type: "number",
        helpText: "Increment or decrement step"
      },
      controls: {
        type: "boolean",
        displayName: "Show add/minus controls?",
        advanced: true
      },
      type: {
        type: "choice",
        options: inputTypeOptions,
        displayName: "Input type",
        defaultValue: "number",
        advanced: true
      }
    }, COMMON_DECORATOR_PROPS), COMMON_ADVANCED_PROPS), COMMON_EVENT_HANDLERS), {
      // onChange directly called with the number
      onChange: {
        type: "eventHandler",
        argTypes: [
          {
            name: "value",
            type: "number"
          }
        ]
      }
    }),
    states: __spreadValues$e({}, COMMON_STATES)
  }, { trapsSelection: true }), {
    // don't need component helpers
    importPath: "@plasmicpkgs/antd5/skinny/registerInput",
    importName: "AntdInputNumber"
  }));
}

var __defProp$d = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$d = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$d(a, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$d(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
var __objRest$9 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$d.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$d.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const styleSections = [
  "visibility",
  "typography",
  "spacing",
  "background",
  "transform",
  "transitions",
  "layout",
  "overflow",
  "border",
  "shadows",
  "effects"
];
function AntdModal(props) {
  const _a = props, {
    onOpenChange,
    onOk,
    onCancel,
    open,
    width,
    footer,
    hideFooter,
    modalScopeClassName,
    wrapClassName,
    trigger
  } = _a, rest = __objRest$9(_a, [
    "onOpenChange",
    "onOk",
    "onCancel",
    "open",
    "width",
    "footer",
    "hideFooter",
    "modalScopeClassName",
    "wrapClassName",
    "trigger"
  ]);
  const memoOnOk = React.useMemo(() => {
    if (onOpenChange || onOk) {
      return (e) => {
        onOpenChange == null ? void 0 : onOpenChange(false);
        onOk == null ? void 0 : onOk(e);
      };
    } else {
      return void 0;
    }
  }, [onOpenChange, onOk]);
  const memoOnCancel = React.useMemo(() => {
    if (onOpenChange || onCancel) {
      return (e) => {
        onOpenChange == null ? void 0 : onOpenChange(false);
        onCancel == null ? void 0 : onCancel(e);
      };
    } else {
      return void 0;
    }
  }, [onOpenChange, onCancel]);
  const widthProp = useMemo(() => {
    if (!width)
      return void 0;
    if (typeof width === "number")
      return width;
    if (typeof width !== "string")
      return void 0;
    if (/^\d+$/.test(width)) {
      return +width;
    }
    return width;
  }, [width]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Modal,
    __spreadProps$5(__spreadValues$d({}, rest), {
      onOk: memoOnOk,
      width: widthProp,
      onCancel: memoOnCancel,
      open,
      footer: hideFooter ? null : footer != null ? footer : void 0,
      wrapClassName,
      className: `${props.className} ${props.defaultStylesClassName} ${modalScopeClassName}`
    })
  ), trigger ? /* @__PURE__ */ React.createElement("div", { onClick: () => onOpenChange == null ? void 0 : onOpenChange(true) }, trigger) : null);
}
function registerModal(loader) {
  registerComponentHelper(loader, AntdModal, {
    name: "plasmic-antd5-modal",
    displayName: "Modal",
    styleSections,
    description: "[See tutorial video](https://www.youtube.com/watch?v=TkjxNJIFun8)",
    props: {
      open: {
        type: "boolean"
      },
      width: {
        type: "string",
        defaultValueHint: "520px",
        description: "Change the width of the modal",
        helpText: "Default unit is px. You can also use % or other units for width."
      },
      children: {
        type: "slot",
        defaultValue: {
          type: "vbox",
          children: ["Modal content"]
        }
      },
      title: {
        type: "slot",
        defaultValue: "Modal title"
      },
      footer: {
        type: "slot",
        hidePlaceholder: true,
        hidden: (ps) => {
          var _a;
          return (_a = ps.hideFooter) != null ? _a : false;
        }
      },
      trigger: __spreadValues$d({
        type: "slot",
        hidePlaceholder: true,
        defaultValue: {
          type: "component",
          name: "plasmic-antd5-button",
          props: {
            children: {
              type: "text",
              value: "Show modal"
            }
          }
        }
      }, {
        mergeWithParent: true
      }),
      closeIcon: {
        type: "slot",
        hidePlaceholder: true
      },
      onOk: {
        type: "eventHandler",
        argTypes: []
      },
      onCancel: {
        type: "eventHandler",
        argTypes: []
      },
      okText: {
        type: "string",
        hidden: (ps) => !!ps.footer,
        advanced: true
      },
      cancelText: {
        type: "string",
        hidden: (ps) => !!ps.footer,
        advanced: true
      },
      hideFooter: {
        type: "boolean",
        description: "Hide the modal footer slot",
        advanced: true
      },
      onOpenChange: {
        type: "eventHandler",
        argTypes: [{ name: "open", type: "boolean" }]
      },
      maskClosable: {
        type: "boolean",
        displayName: "Close modal on outside click?",
        description: "Whether to close the modal when user clicks outside the modal",
        defaultValueHint: true
      },
      wrapClassName: {
        type: "class",
        displayName: "Modal overlay",
        styleSections: ["background"]
      },
      modalScopeClassName: {
        type: "styleScopeClass",
        scopeName: "modal"
      },
      modalContentClassName: {
        type: "class",
        displayName: "Modal content",
        noSelf: true,
        styleSections,
        selectors: [
          {
            selector: ":modal .ant-modal-content",
            label: "Base"
          }
        ]
      },
      closeButtonClassName: {
        type: "class",
        displayName: "Close button",
        noSelf: true,
        selectors: [
          {
            selector: ":modal .ant-modal-close",
            label: "Base"
          }
        ],
        advanced: true
      },
      defaultStylesClassName: {
        type: "themeResetClass"
      }
    },
    states: {
      open: {
        type: "writable",
        valueProp: "open",
        onChangeProp: "onOpenChange",
        variableType: "boolean"
      }
    },
    templates: {
      "Modal Form": {
        props: {
          children: {
            type: "component",
            name: "plasmic-antd5-form"
          },
          hideFooter: true
        }
      },
      "Generic Modal": {}
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerModal",
    importName: "AntdModal"
  });
}

var __defProp$c = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$c = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$c(a, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$c(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
var __objRest$8 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdPagination(props) {
  const _a = props, { paginatedUrl, pageSizeOptions } = _a, rest = __objRest$8(_a, ["paginatedUrl", "pageSizeOptions"]);
  useEffect(() => {
    if (props.current && props.pageSize && props.onChange) {
      props.onChange(props.current, props.pageSize);
    }
  }, []);
  return /* @__PURE__ */ React.createElement(
    Pagination,
    __spreadValues$c({
      pageSizeOptions: pageSizeOptions == null ? void 0 : pageSizeOptions.filter((i) => i == null ? void 0 : i.pageSize).map((i) => i.pageSize),
      itemRender: paginatedUrl ? (pageNo, _, originalElement) => {
        var _a2, _b;
        if (!React.isValidElement(originalElement) || !props.pageSize) {
          return originalElement;
        }
        let rel = void 0;
        if (props.current) {
          rel = pageNo === props.current ? "self" : pageNo === props.current - 1 ? "prev" : pageNo === props.current + 1 ? "next" : void 0;
        }
        const href = paginatedUrl(pageNo, props.pageSize);
        return React.cloneElement(originalElement, __spreadProps$4(__spreadValues$c({}, originalElement.props), {
          rel,
          href,
          style: __spreadProps$4(__spreadValues$c({}, (_b = (_a2 = originalElement.props) == null ? void 0 : _a2.style) != null ? _b : {}), {
            pointerEvents: "none"
          })
        }));
      } : void 0
    }, rest)
  );
}
const paginationComponentName = "plasmic-antd5-pagination";
const paginationHelpers = {
  states: {
    pageSize: {
      onChangeArgsToValue: (_, pageSize) => pageSize
    },
    startIndex: {
      onChangeArgsToValue: (currentPage, pageSize) => (currentPage - 1) * pageSize
    },
    endIndex: {
      onChangeArgsToValue: (currentPage, pageSize) => pageSize * currentPage - 1
    }
  }
};
function registerPagination(loader) {
  registerComponentHelper(loader, AntdPagination, {
    name: paginationComponentName,
    displayName: "Pagination",
    props: {
      current: {
        editOnly: true,
        uncontrolledProp: "defaultCurrent",
        type: "number",
        displayName: "Current Page",
        description: `Default current page`,
        defaultValue: 1
      },
      total: {
        type: "number",
        defaultValueHint: 0,
        description: `Total number of data items`
      },
      pageSize: {
        editOnly: true,
        uncontrolledProp: "defaultPageSize",
        type: "number",
        displayName: "Page size",
        description: `Default number of items per page`,
        defaultValue: 10
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false,
        description: `Disable pagination controls`
      },
      hideOnSinglePage: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: `Hide pager on single page`
      },
      showLessItems: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: `Show less page items`,
        hidden: (ps) => !!ps.simple
      },
      showQuickJumper: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: `Show "Go to page" control to enable jumping to pages directly`,
        hidden: (ps) => !!ps.simple
      },
      showSizeChanger: {
        type: "boolean",
        defaultValueHint: (ps) => ps.total ? ps.total > 50 : false,
        advanced: true,
        description: `Show page size selector`,
        hidden: (ps) => !!ps.simple
      },
      //   showTitle prop seems to be doing nothing, so this is skipped
      //   showTitle: {
      //     type: "boolean",
      //     defaultValueHint: true,
      //     description: `Show page item's title`,
      //   },
      showTotal: {
        type: "function",
        displayName: "Show total",
        description: "Display the total number and range",
        advanced: true,
        argNames: ["total", "range"],
        argValues: (_ps, ctx) => [ctx.data[0], ctx.data[1]]
      },
      simple: {
        type: "boolean",
        defaultValueHint: false,
        description: `Uuse simple mode (i.e. minimal controls)`
      },
      size: {
        type: "choice",
        defaultValueHint: "default",
        description: `Size of the pager`,
        options: ["default", "small"]
      },
      pageSizeOptions: {
        type: "array",
        defaultValue: [
          {
            pageSize: 10
          },
          {
            pageSize: 20
          },
          {
            pageSize: 50
          },
          {
            pageSize: 100
          }
        ],
        description: "The list of available page sizes",
        advanced: true,
        itemType: {
          type: "object",
          nameFunc: (item) => item.pageSize,
          fields: {
            pageSize: {
              type: "number",
              min: 1
            }
          }
        }
      },
      paginatedUrl: {
        type: "function",
        advanced: true,
        description: "Helps generate SEO-friendly pagination links. These links will include appropriate href attributes, ensuring that search engines can effectively crawl and index your paginated content",
        control: {
          type: "href"
        },
        argNames: ["pageNo", "pageSize"],
        argValues: (_props, ctx) => {
          var _a;
          return [
            (_a = ctx == null ? void 0 : ctx.data) == null ? void 0 : _a[0],
            _props.pageSize
          ];
        }
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [
          {
            name: "page",
            type: "number"
          },
          {
            name: "pageSize",
            type: "number"
          }
        ]
      },
      onShowSizeChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [
          {
            name: "current",
            type: "number"
          },
          {
            name: "size",
            type: "number"
          }
        ]
      }
    },
    states: {
      currentPage: {
        type: "writable",
        valueProp: "current",
        onChangeProp: "onChange",
        variableType: "number"
      },
      pageSize: __spreadValues$c({
        type: "writable",
        valueProp: "pageSize",
        onChangeProp: "onShowSizeChange",
        variableType: "number"
      }, paginationHelpers.states.pageSize),
      startIndex: __spreadValues$c({
        type: "readonly",
        variableType: "number",
        onChangeProp: "onChange"
      }, paginationHelpers.states.startIndex),
      endIndex: __spreadValues$c({
        type: "readonly",
        variableType: "number",
        onChangeProp: "onChange"
      }, paginationHelpers.states.endIndex)
    },
    componentHelpers: {
      helpers: paginationHelpers,
      importName: "paginationHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerPagination"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerPagination",
    importName: "AntdPagination"
  });
}

var __defProp$b = Object.defineProperty;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$b = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$b(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$b(a, prop, b[prop]);
    }
  return a;
};
var __objRest$7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$b.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$b.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdPopover(props) {
  const _a = props, {
    overlayClassName,
    popoverScopeClassName,
    defaultStylesClassName,
    contentText,
    content
  } = _a, rest = __objRest$7(_a, [
    "overlayClassName",
    "popoverScopeClassName",
    "defaultStylesClassName",
    "contentText",
    "content"
  ]);
  return /* @__PURE__ */ React.createElement(
    Popover,
    __spreadValues$b({
      content: content || contentText,
      overlayClassName: `${overlayClassName} ${popoverScopeClassName} ${defaultStylesClassName}`
    }, rest)
  );
}
function registerPopover(loader) {
  registerComponentHelper(loader, AntdPopover, {
    name: "plasmic-antd5-popover",
    displayName: "Popover",
    isAttachment: true,
    props: {
      open: {
        type: "boolean",
        editOnly: true,
        uncontrolledProp: "defaultOpen",
        description: "Default open state of the popover"
      },
      arrow: {
        type: "boolean",
        defaultValue: true,
        advanced: true
      },
      children: {
        type: "slot",
        defaultValue: "This text element is wrapped in a Popover component",
        mergeWithParent: true
      },
      popoverScopeClassName: {
        type: "styleScopeClass",
        scopeName: "popover"
      },
      popoverContentClassName: {
        type: "class",
        displayName: "Popover content",
        selectors: [
          {
            selector: ":popover.ant-popover .ant-popover-inner",
            label: "Base"
          }
        ]
      },
      overlayClassName: {
        type: "class",
        displayName: "Overlay"
      },
      content: {
        type: "slot",
        displayName: "Popover contents",
        defaultValue: "Popover contents",
        hidePlaceholder: true
      },
      /**
       *  NOTE: contentText ensures that the popover shows as a custom behaviour without modifications
       * (when a random element is given a custom behaviour of Popover, the props of type "slot" do not receive any default value.
       * Therefore we use the contentText which has a string default value, so that the popover shows with at least something)
       *  */
      contentText: {
        type: "string",
        displayName: "Popover contents",
        description: "What gets shown inside the popover on hover",
        defaultValue: "Popover contents",
        hidden: (ps) => !!ps.content
      },
      title: {
        type: "slot",
        displayName: "Popover title",
        hidePlaceholder: true,
        defaultValue: "Popover title"
      },
      color: {
        type: "color",
        description: "Popover fill color"
      },
      trigger: {
        type: "choice",
        options: ["hover", "focus", "click"],
        defaultValueHint: "hover",
        advanced: true
      },
      placement: {
        type: "choice",
        options: [
          "topLeft",
          "top",
          "topRight",
          "leftTop",
          "left",
          "leftBottom",
          "rightTop",
          "right",
          "rightBottom",
          "bottomLeft",
          "bottom",
          "bottomRight"
        ],
        description: "Default placement of popover",
        defaultValueHint: "top"
      },
      mouseEnterDelay: {
        type: "number",
        description: "Delay in seconds, before popover is shown on mouse enter",
        defaultValue: 0,
        advanced: true,
        hidden: (ps) => ps.trigger ? ps.trigger !== "hover" : false
      },
      mouseLeaveDelay: {
        type: "number",
        description: "Delay in seconds, before popover is hidden on mouse leave",
        defaultValue: 0,
        advanced: true,
        hidden: (ps) => ps.trigger ? ps.trigger !== "hover" : false
      },
      onOpenChange: {
        type: "eventHandler",
        argTypes: [{ name: "open", type: "boolean" }],
        advanced: true
      },
      defaultStylesClassName: {
        type: "themeResetClass"
      }
    },
    states: {
      open: {
        type: "writable",
        valueProp: "open",
        onChangeProp: "onOpenChange",
        variableType: "boolean"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerPopover",
    importName: "AntdPopover"
  });
}

var __defProp$a = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a, prop, b[prop]);
    }
  return a;
};
var __objRest$6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$a.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$a.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdProgress(props) {
  const _a = props, {
    successPercent,
    successStrokeColor,
    stepColors,
    infoFormat,
    gradient,
    strokeColor
  } = _a, rest = __objRest$6(_a, [
    "successPercent",
    "successStrokeColor",
    "stepColors",
    "infoFormat",
    "gradient",
    "strokeColor"
  ]);
  const success = useMemo(() => {
    if (!successPercent && !successStrokeColor)
      return void 0;
    const res = {
      percent: successPercent,
      strokeColor: successStrokeColor
    };
    return res;
  }, [successPercent, successStrokeColor]);
  const strokeColorProp = useMemo(() => {
    if (props.type === "line" && !!props.steps) {
      const colors = stepColors == null ? void 0 : stepColors.map((c) => c.color).filter((c) => c);
      if (colors == null ? void 0 : colors.length) {
        return colors;
      }
    }
    const res = {};
    gradient == null ? void 0 : gradient.filter((g) => g.color && g.percent !== void 0).map((g) => {
      res[g.percent] = g.color;
    });
    if (Object.keys(res).length)
      return res;
    return strokeColor;
  }, [gradient, props.steps, props.type, stepColors, strokeColor]);
  return /* @__PURE__ */ React.createElement(
    Progress,
    __spreadValues$a({
      strokeColor: strokeColorProp,
      success,
      format: infoFormat
    }, rest)
  );
}
const progressComponentName = "plasmic-antd5-progress";
function registerProgress(loader) {
  registerComponentHelper(loader, AntdProgress, {
    name: progressComponentName,
    displayName: "Progress",
    props: {
      type: {
        type: "choice",
        defaultValueHint: "line",
        options: ["line", "circle", "dashboard"]
      },
      percent: {
        type: "number",
        description: "The completion percentage",
        defaultValueHint: 0
      },
      size: {
        type: "choice",
        defaultValueHint: "default",
        description: `Size of progress`,
        advanced: true,
        options: ["default", "small"]
      },
      showInfo: {
        type: "boolean",
        displayName: "Show text",
        defaultValueHint: true,
        advanced: true,
        description: "Display the progress value and the status icon"
      },
      status: {
        type: "choice",
        defaultValueHint: "normal",
        advanced: true,
        options: ["success", "exception", "normal", "active"]
      },
      strokeColor: {
        type: "color",
        description: "The color of progress bar"
      },
      strokeLinecap: {
        type: "choice",
        description: "Style of endpoints of the progress path",
        defaultValueHint: "round",
        advanced: true,
        options: ["round", "butt", "square"]
      },
      successPercent: {
        type: "number",
        advanced: true
      },
      successStrokeColor: {
        type: "color",
        description: "Color of the progress path marked success",
        advanced: true,
        hidden: (ps) => !ps.successPercent
      },
      trailColor: {
        type: "color",
        advanced: true,
        description: "The color of unfilled part"
      },
      infoFormat: {
        type: "function",
        displayName: "Format",
        defaultValueHint: ({ percent }) => `${percent || 0}%`,
        description: "Customize the progress text",
        advanced: true,
        hidden: (ps) => ps.showInfo === void 0 ? false : !ps.showInfo,
        argNames: ["percent", "successPercent"],
        argValues: (_ps) => [
          _ps.percent,
          _ps.successPercent
        ]
      },
      steps: {
        type: "number",
        hidden: (ps) => ps.type !== "line",
        advanced: true,
        description: "The total step count"
      },
      stepColors: {
        type: "array",
        hidden: (ps) => ps.type !== "line" ? true : ps.steps == null,
        advanced: true,
        itemType: {
          type: "object",
          nameFunc: (item) => item.color,
          fields: {
            color: {
              type: "color"
            }
          }
        }
      },
      gradient: {
        type: "array",
        hidden: (ps) => ps.type === "line" && !!ps.steps,
        advanced: true,
        itemType: {
          type: "object",
          nameFunc: (item) => `${item.percent}%: ${item.color}`,
          fields: {
            color: {
              type: "color"
            },
            percent: {
              type: "number"
            }
          }
        }
      },
      strokeWidth: {
        type: "number",
        hidden: (ps) => ps.type === "line",
        description: "To set the width of the circular progress, unit: percentage of the canvas width",
        advanced: true,
        defaultValueHint: 6
      },
      gapDegree: {
        type: "number",
        hidden: (ps) => ps.type !== "dashboard",
        defaultValueHint: 75,
        advanced: true,
        description: "The gap degree of half circle",
        min: 0,
        max: 295
      },
      gapPosition: {
        type: "choice",
        hidden: (ps) => ps.type !== "dashboard",
        options: ["top", "bottom", "left", "right"],
        advanced: true,
        defaultValueHint: "bottom"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerProgress",
    importName: "AntdProgress"
  });
}

var __defProp$9 = Object.defineProperty;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdRate(props) {
  const _a = props, { character, count, tooltips, multiCharacter, symbols } = _a, rest = __objRest$5(_a, ["character", "count", "tooltips", "multiCharacter", "symbols"]);
  const symbolsProp = useMemo(
    () => {
      var _a2, _b, _c;
      return ((_c = Array.isArray((_a2 = symbols == null ? void 0 : symbols.props) == null ? void 0 : _a2.children) ? (_b = symbols == null ? void 0 : symbols.props) == null ? void 0 : _b.children : [symbols]) == null ? void 0 : _c.filter((c) => React.isValidElement(c)).map((c) => /* @__PURE__ */ React.createElement(React.Fragment, null, c))) || [];
    },
    [symbols]
  );
  const countProp = useMemo(() => {
    if (!multiCharacter)
      return count;
    return symbolsProp == null ? void 0 : symbolsProp.length;
  }, [count, multiCharacter, symbolsProp == null ? void 0 : symbolsProp.length]);
  const characterProp = useMemo(() => {
    if (!multiCharacter)
      return character || void 0;
    return (symbolsProp == null ? void 0 : symbolsProp.length) ? ({ index }) => symbolsProp[index] : character || void 0;
  }, [character, multiCharacter, symbolsProp]);
  return /* @__PURE__ */ React.createElement(
    Rate,
    __spreadValues$9({
      tooltips: tooltips == null ? void 0 : tooltips.map((t) => t == null ? void 0 : t.label),
      count: countProp,
      character: characterProp
    }, rest)
  );
}
const rateComponentName = "plasmic-antd5-rate";
function registerRate(loader) {
  registerComponentHelper(loader, AntdRate, {
    name: rateComponentName,
    displayName: "Rate",
    props: {
      allowClear: {
        type: "boolean",
        advanced: true,
        defaultValueHint: true,
        description: "Clear the rating when the user clicks again"
      },
      allowHalf: {
        type: "boolean",
        advanced: true,
        defaultValueHint: false,
        description: "Allow fractional rating."
      },
      autoFocus: {
        type: "boolean",
        description: "Focus when component is rendered",
        defaultValueHint: false,
        advanced: true
      },
      character: {
        type: "slot",
        displayName: "Symbol",
        hidePlaceholder: true,
        hidden: (ps) => Boolean(ps.multiCharacter)
      },
      multiCharacter: {
        type: "boolean",
        displayName: "Multi Symbol",
        description: "Allow different symbols for rating. (You can add these symbols in the component slots if this is enabled)",
        advanced: true
      },
      symbols: {
        type: "slot",
        displayName: "Symbols",
        hidePlaceholder: true,
        defaultValue: ["1", "2", "3", "4", "5"],
        hidden: (ps) => !ps.multiCharacter
      },
      count: {
        type: "number",
        description: "Rating count",
        defaultValueHint: 5,
        advanced: true,
        hidden: (ps) => Boolean(ps.multiCharacter)
      },
      value: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "Default rating",
        defaultValueHint: 0
      },
      disabled: {
        type: "boolean",
        description: "Read-only rating",
        defaultValueHint: false
      },
      tooltips: {
        type: "array",
        description: "Rating labels",
        displayName: "Labels",
        advanced: true,
        hidden: (ps) => !ps.count,
        itemType: {
          type: "object",
          fields: {
            label: "string"
          },
          nameFunc: (value) => value.label
        },
        validator: (value, ps) => {
          if (!ps.count)
            return true;
          if (!Array.isArray(value) || value.length === 0)
            return true;
          if (value.length < ps.count)
            return `You need ${ps.count - value.length} more labels`;
          if (value.length > ps.count)
            return "You have too many labels. Some labels will not be used";
          return true;
        }
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "number" }]
      },
      onBlur: {
        type: "eventHandler",
        advanced: true,
        argTypes: []
      },
      onFocus: {
        type: "eventHandler",
        advanced: true,
        argTypes: []
      },
      onHoverChange: {
        type: "eventHandler",
        advanced: true,
        description: "Callback when an item is hovered",
        argTypes: []
      },
      onKeyDown: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "event", type: "object" }]
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "number"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerRate",
    importName: "AntdRate"
  });
}

var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function AntdSegmented(props) {
  const _a = props, {
    optionsSlot,
    options: optionLabelObjs,
    useSlotOptions
  } = _a, rest = __objRest$4(_a, [
    "optionsSlot",
    "options",
    "useSlotOptions"
  ]);
  const options = useMemo(() => {
    var _a2;
    if (useSlotOptions) {
      const optionElts = ((_a2 = optionsSlot == null ? void 0 : optionsSlot.type) == null ? void 0 : _a2.name) == AntdSegmentedOption.name ? [optionsSlot] : optionsSlot == null ? void 0 : optionsSlot.props.children;
      return optionElts == null ? void 0 : optionElts.filter(
        (el) => {
          var _a3;
          return React.isValidElement(el) && ((_a3 = el.type) == null ? void 0 : _a3.name) === AntdSegmentedOption.name;
        }
      ).map((el) => ({
        value: el.props.value,
        label: /* @__PURE__ */ React.createElement(React.Fragment, null, el.props.children)
      }));
    }
    return (optionLabelObjs == null ? void 0 : optionLabelObjs.filter((l) => l.label && l.value)) || [];
  }, [optionsSlot, useSlotOptions, optionLabelObjs]);
  return /* @__PURE__ */ React.createElement(Segmented, __spreadValues$8({ options }, rest));
}
function AntdSegmentedOption(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, props.children);
}
function OutlineMessage$1() {
  return /* @__PURE__ */ React.createElement("div", null, "* To re-arrange options, use the Outline panel");
}
function getValueOptions(props) {
  var _a;
  if (props.useSlotOptions) {
    const res = /* @__PURE__ */ new Set();
    traverseReactEltTree(props.optionsSlot, (elt) => {
      var _a2, _b;
      if ((elt == null ? void 0 : elt.type) === AntdSegmentedOption && ((_a2 = elt.props) == null ? void 0 : _a2.value)) {
        res.add((_b = elt.props) == null ? void 0 : _b.value);
      }
    });
    return Array.from(res.keys());
  } else {
    return ((_a = props.options) == null ? void 0 : _a.filter((l) => l.label && l.value).map((l) => l.value)) || [];
  }
}
function getDefaultSlotOption(key) {
  return {
    type: "component",
    name: segmentedOptionComponentName,
    props: {
      value: `Option ${key}`,
      children: {
        type: "hbox",
        styles: {
          columnGap: "5px",
          justifyContent: "center"
        },
        children: [
          {
            type: "img",
            styles: {
              opacity: 0.5,
              objectFit: "contain"
            },
            src: "https://static1.plasmic.app/home-outlined.svg"
          },
          {
            type: "text",
            value: `Option ${key}`,
            styles: {
              width: "auto"
            }
          }
        ]
      }
    }
  };
}
const segmentedComponentName = "plasmic-antd5-segmented";
const segmentedOptionComponentName = "plasmic-antd5-segmented-option";
function registerSegmented(loader) {
  registerComponentHelper(loader, AntdSegmentedOption, {
    name: segmentedOptionComponentName,
    displayName: "Segmented Option",
    props: {
      value: {
        type: "string",
        displayName: "Name",
        description: "Name of the segment"
      },
      children: {
        type: "slot",
        hidePlaceholder: true
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSegmented",
    importName: "AntdSegmentedOption",
    parentComponentName: segmentedComponentName
  });
  registerComponentHelper(loader, AntdSegmented, {
    name: segmentedComponentName,
    displayName: "Segmented",
    props: {
      size: {
        type: "choice",
        defaultValueHint: "middle",
        description: `Set the size of segments`,
        options: ["large", "middle", "small"]
      },
      value: {
        editOnly: true,
        uncontrolledProp: "defaultValue",
        type: "choice",
        options: getValueOptions,
        displayName: "Selected option",
        description: `Default selected option`,
        hidden: (ps) => !ps.options
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false,
        description: `Disable all segments`
      },
      block: {
        type: "boolean",
        displayName: "Fill spacing",
        defaultValueHint: false,
        description: `Fill the container element, with all segments equally spaced`
      },
      useSlotOptions: {
        type: "boolean",
        defaultValue: false,
        advanced: true,
        description: "Add icons, avatars, images, and more in option labels"
      },
      options: {
        type: "array",
        hidden: (ps) => ps.useSlotOptions,
        validator: (value, ps) => {
          if (ps.useSlotOptions) {
            return true;
          }
          const badOptions = value.map((v, i) => !v.value || !v.label ? i + 1 : void 0).filter((i) => i);
          if (badOptions.length > 0) {
            return `Options at position ${badOptions.join(
              ", "
            )} are missing label or value`;
          }
          return true;
        },
        itemType: {
          type: "object",
          nameFunc: (item) => item.label,
          fields: {
            label: {
              type: "string",
              required: true
            },
            value: {
              type: "string",
              required: true
            }
          }
        },
        defaultValue: [
          {
            label: "Option 1",
            value: "Option 1"
          },
          {
            label: "Option 2",
            value: "Option 2"
          },
          {
            label: "Option 3",
            value: "Option 3"
          }
        ]
      },
      optionsSlot: {
        type: "slot",
        displayName: "Options",
        allowedComponents: [segmentedOptionComponentName],
        hidden: (ps) => !ps.useSlotOptions,
        defaultValue: [getDefaultSlotOption(1), getDefaultSlotOption(2)]
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "string" }]
      }
    },
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text"
      }
    },
    actions: [
      {
        type: "button-action",
        label: "Add new option",
        hidden: (ps) => !ps.useSlotOptions,
        onClick: ({ componentProps, studioOps }) => {
          const generateNewKey = () => {
            const existingValues = /* @__PURE__ */ new Set();
            traverseReactEltTree(componentProps.optionsSlot, (elt) => {
              var _a;
              if ((elt == null ? void 0 : elt.type) === AntdSegmentedOption && ((_a = elt == null ? void 0 : elt.props) == null ? void 0 : _a.value)) {
                existingValues.add(elt.props.value);
              }
            });
            for (let keyCandidate = 1; keyCandidate <= existingValues.size + 1; keyCandidate++) {
              const strKey = keyCandidate.toString();
              if (!existingValues.has(strKey) && !existingValues.has(`Option ${strKey}`)) {
                return strKey;
              }
            }
            return void 0;
          };
          const newKey = generateNewKey();
          if (!newKey)
            return;
          studioOps.appendToSlot(getDefaultSlotOption(newKey), "optionsSlot");
        }
      },
      {
        type: "button-action",
        hidden: (ps) => !ps.value || !ps.useSlotOptions,
        label: "Delete current option",
        onClick: ({ componentProps, studioOps }) => {
          const options = [];
          traverseReactEltTree(componentProps.optionsSlot, (elt) => {
            var _a;
            if ((elt == null ? void 0 : elt.type) === AntdSegmentedOption && ((_a = elt == null ? void 0 : elt.props) == null ? void 0 : _a.value)) {
              options.push(elt.props.value);
            }
          });
          const value = componentProps.value;
          const currPos = options.findIndex((opt) => {
            return opt === value;
          });
          if (currPos !== -1) {
            studioOps.removeFromSlotAt(currPos, "optionsSlot");
            if (options.length - 1 > 0) {
              const prevPos = (currPos - 1 + options.length) % options.length;
              studioOps.updateProps({ value: options[prevPos] });
            }
          }
        }
      },
      {
        type: "custom-action",
        hidden: (ps) => !ps.useSlotOptions,
        control: OutlineMessage$1
      }
    ],
    importPath: "@plasmicpkgs/antd5/skinny/registerSegmented",
    importName: "AntdSegmented"
  });
}

var __defProp$7 = Object.defineProperty;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useMarks({
  simpleMarks,
  stylableMarks
}) {
  const marks = useMemo(() => {
    var _a;
    const stylableMarksList = ((_a = stylableMarks == null ? void 0 : stylableMarks.type) == null ? void 0 : _a.name) == AntdSliderMark.name ? [stylableMarks] : stylableMarks == null ? void 0 : stylableMarks.props.children;
    const res = {};
    stylableMarksList == null ? void 0 : stylableMarksList.filter(
      (c) => {
        var _a2;
        return React.isValidElement(c) && ((_a2 = c.type) == null ? void 0 : _a2.name) === AntdSliderMark.name;
      }
    ).forEach((c) => {
      res[c.props.mark] = c.props.children;
    });
    simpleMarks == null ? void 0 : simpleMarks.forEach((mark) => {
      res[mark.value] = { label: mark.label };
    });
    return res;
  }, [simpleMarks, stylableMarks]);
  return marks;
}
function useTooltip({
  tooltipVisible,
  tooltipPlacement,
  tooltipPrefix,
  tooltipSuffix
}) {
  return {
    open: tooltipVisible === "unset" ? void 0 : Boolean(tooltipVisible),
    placement: tooltipPlacement,
    getPopupContainer: (node) => node,
    formatter: (value) => `${tooltipPrefix || ""}${value}${tooltipSuffix || ""}`
  };
}
function AntdRangeSlider(props) {
  const _a = props, {
    marks,
    stylableMarks,
    sliderScopeClassName,
    className,
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix,
    draggableTrack,
    valueMin,
    valueMax,
    defaultValueMin,
    defaultValueMax,
    onAfterChange
  } = _a, rest = __objRest$3(_a, [
    "marks",
    "stylableMarks",
    "sliderScopeClassName",
    "className",
    "tooltipVisible",
    "tooltipPlacement",
    "tooltipPrefix",
    "tooltipSuffix",
    "draggableTrack",
    "valueMin",
    "valueMax",
    "defaultValueMin",
    "defaultValueMax",
    "onAfterChange"
  ]);
  const marksProp = useMarks({ simpleMarks: marks, stylableMarks });
  const tooltipProp = useTooltip({
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix
  });
  return /* @__PURE__ */ React.createElement(
    Slider,
    __spreadValues$7({
      value: [valueMin || 0, valueMax || 0],
      defaultValue: [defaultValueMin || 0, defaultValueMax || 0],
      range: { draggableTrack },
      className: `${sliderScopeClassName} ${className}`,
      tooltip: tooltipProp,
      marks: marksProp,
      onChangeComplete: onAfterChange
    }, rest)
  );
}
function AntdSingleSlider(props) {
  const _a = props, {
    marks,
    stylableMarks,
    sliderScopeClassName,
    className,
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix,
    onAfterChange
  } = _a, rest = __objRest$3(_a, [
    "marks",
    "stylableMarks",
    "sliderScopeClassName",
    "className",
    "tooltipVisible",
    "tooltipPlacement",
    "tooltipPrefix",
    "tooltipSuffix",
    "onAfterChange"
  ]);
  const marksProp = useMarks({ simpleMarks: marks, stylableMarks });
  const tooltipProp = useTooltip({
    tooltipVisible,
    tooltipPlacement,
    tooltipPrefix,
    tooltipSuffix
  });
  return /* @__PURE__ */ React.createElement(
    Slider,
    __spreadValues$7({
      className: `${sliderScopeClassName} ${className}`,
      tooltip: tooltipProp,
      marks: marksProp,
      range: false,
      onChangeComplete: onAfterChange
    }, rest)
  );
}
function AntdSliderMark(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, props.children);
}
const sliderComponentName = "plasmic-antd5-slider";
const rangeSliderComponentName = "plasmic-antd5-range-slider";
const sliderMarkComponentName = "plasmic-antd5-slider-mark";
const commonProps = {
  autoFocus: {
    type: "boolean",
    description: "Focus when component is rendered",
    defaultValueHint: false,
    advanced: true
  },
  disabled: {
    type: "boolean",
    description: "If true, the slider thumb will not be draggable",
    defaultValueHint: false
  },
  keyboard: {
    type: "boolean",
    description: "Support using keyboard to move handlers",
    defaultValueHint: true,
    advanced: true
  },
  dots: {
    type: "boolean",
    displayName: "Show dots",
    description: "Show dot at every step on the slider",
    defaultValueHint: false,
    advanced: true
  },
  marks: {
    type: "array",
    description: "Specific markers or snap points on the slider",
    itemType: {
      nameFunc: (value) => `${value.value} \u2192 ${value.label}`,
      type: "object",
      fields: {
        value: {
          type: "number",
          description: "value on the slider"
        },
        label: "string"
      }
    }
  },
  stylableMarks: {
    type: "slot",
    displayName: "Stylable Marks",
    allowedComponents: [sliderMarkComponentName],
    defaultValue: [
      {
        type: "component",
        name: sliderMarkComponentName,
        props: {
          mark: 50,
          children: {
            type: "text",
            value: "Stylable Mark"
          }
        }
      }
    ]
  },
  included: {
    type: "boolean",
    description: "Fill the slider till the selected value",
    defaultValueHint: true,
    advanced: true
  },
  min: {
    type: "number",
    description: "The minimum value the slider can slide to",
    defaultValueHint: 0,
    displayName: "Slider start"
  },
  max: {
    type: "number",
    description: "The maximum value the slider can slide to",
    defaultValueHint: 100,
    displayName: "Slider end"
  },
  reverse: {
    type: "boolean",
    description: "Reverse the slider, so that the starting point is at the right end",
    defaultValueHint: false,
    advanced: true
  },
  step: {
    type: "number",
    description: "Granularity of the slider's movement",
    defaultValueHint: 1,
    min: 0
  },
  vertical: {
    type: "boolean",
    description: "Slide vertically",
    defaultValueHint: false,
    advanced: true,
    helpText: "Please increase the slider height to make the vertical slider visible"
  },
  tooltipVisible: {
    type: "choice",
    displayName: "Show tooltip",
    options: [
      {
        value: true,
        label: "Always"
      },
      {
        value: false,
        label: "Never"
      },
      {
        value: "unset",
        label: "Only on drag/hover"
      }
    ],
    defaultValueHint: "unset",
    defaultValue: "unset",
    advanced: true
  },
  tooltipPlacement: {
    type: "choice",
    options: [
      "topLeft",
      "top",
      "topRight",
      "leftTop",
      "left",
      "leftBottom",
      "rightTop",
      "right",
      "rightBottom",
      "bottomLeft",
      "bottom",
      "bottomRight"
    ].map((item) => ({
      value: item,
      label: kebabCase(item)
    })),
    description: "Default placement of tooltip",
    defaultValueHint: "top",
    advanced: true
  },
  tooltipPrefix: {
    type: "string",
    description: "Add a prefix to the slider value inside tooltip",
    advanced: true
  },
  tooltipSuffix: {
    type: "string",
    description: "Add a suffix to the slider value inside tooltip",
    advanced: true
  },
  sliderScopeClassName: {
    type: "styleScopeClass",
    scopeName: "slider"
  },
  railClassName: {
    type: "class",
    displayName: "Rail",
    description: "The path on which the thumb moves",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-rail",
        label: "Base"
      }
    ]
  },
  trackClassName: {
    type: "class",
    displayName: "Track",
    description: "The inclusive part of the slider rail",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-track",
        label: "Base"
      }
    ]
  },
  handleClassName: {
    type: "class",
    displayName: "Handle",
    description: "Thumb of the slider that moves on drag",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-handle::after",
        label: "Base"
      }
    ]
  },
  dotClassName: {
    type: "class",
    displayName: "Step dots",
    description: "The dots that represent steps on the slider rail",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-dot",
        label: "Base"
      }
    ]
  },
  activeDotClassName: {
    type: "class",
    displayName: "Active dots",
    description: "The dots within the inclusive part of the slider rail",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-dot.ant-slider-dot-active",
        label: "Base"
      }
    ]
  },
  tooltipClassName: {
    type: "class",
    displayName: "Tooltip",
    description: "The tooltip that shows the value of the slider",
    selectors: [
      {
        selector: ":slider.ant-slider .ant-slider-tooltip",
        label: "Base"
      }
    ]
  }
};
const rangeSliderHelpers = {
  states: {
    min: {
      onChangeArgsToValue: (value) => value[0]
    },
    max: {
      onChangeArgsToValue: (value) => value[1]
    }
  }
};
function registerSlider(loader) {
  registerComponentHelper(loader, AntdSingleSlider, {
    name: sliderComponentName,
    displayName: "Slider",
    defaultStyles: {
      width: "300px"
    },
    props: __spreadValues$7({
      value: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValue",
        description: "The default value of the slider",
        hidden: (ps) => !!ps.__plasmicFormField
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "number" }]
      },
      onAfterChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "number" }]
      }
    }, commonProps),
    states: {
      value: {
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSlider",
    importName: "AntdSingleSlider"
  });
  registerComponentHelper(loader, AntdRangeSlider, {
    name: rangeSliderComponentName,
    displayName: "Range Slider",
    defaultStyles: {
      width: "300px"
    },
    props: __spreadValues$7({
      draggableTrack: {
        type: "boolean",
        defaultValueHint: false,
        description: "Whether range track can be dragged"
      },
      valueMin: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValueMin",
        description: "The default minimum value of the range slider"
      },
      valueMax: {
        type: "number",
        editOnly: true,
        uncontrolledProp: "defaultValueMax",
        description: "The default maximum value of the range slider"
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "object" }]
      },
      onAfterChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "value", type: "object" }]
      }
    }, commonProps),
    states: {
      min: __spreadValues$7({
        type: "writable",
        valueProp: "valueMin",
        onChangeProp: "onChange",
        variableType: "number"
      }, rangeSliderHelpers.states.min),
      max: __spreadValues$7({
        type: "writable",
        valueProp: "valueMax",
        onChangeProp: "onChange",
        variableType: "number"
      }, rangeSliderHelpers.states.max)
    },
    componentHelpers: {
      helpers: rangeSliderHelpers,
      importName: "rangeSliderHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerSlider"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSlider",
    importName: "AntdRangeSlider"
  });
  registerComponentHelper(loader, AntdSliderMark, {
    name: sliderMarkComponentName,
    displayName: "Slider Mark",
    props: {
      mark: {
        type: "number",
        description: "value on the slider"
      },
      children: {
        type: "slot",
        hidePlaceholder: true
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSlider",
    importName: "AntdSliderMark",
    parentComponentName: sliderComponentName
  });
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
function AntdSteps(props) {
  return /* @__PURE__ */ React.createElement(Steps, __spreadValues$6({}, props));
}
function registerSteps(loader) {
  const statusOptions = ["wait", "process", "finish", "error"];
  registerComponentHelper(loader, AntdSteps, {
    name: "plasmic-antd5-steps",
    displayName: "Steps",
    props: {
      items: {
        type: "array",
        itemType: {
          type: "object",
          nameFunc: (item) => item.title,
          fields: {
            title: "string",
            description: "string",
            subTitle: "string",
            disabled: "boolean",
            status: {
              displayName: "Status",
              type: "choice",
              options: statusOptions,
              defaultValueHint: "wait"
            }
            // TODO icon: 'slot',
          }
        },
        defaultValue: [
          {
            title: "Applied",
            description: "Application has been submitted."
          },
          {
            title: "In Review",
            description: "Application is being reviewed."
          },
          {
            title: "Closed",
            description: "Final decision on the application."
          }
        ]
      },
      current: {
        type: "number",
        displayName: "Current step",
        defaultValue: 1
      },
      size: {
        type: "choice",
        options: ["small", "default"],
        description: "Set the size of steps",
        defaultValueHint: "default"
      },
      direction: {
        type: "choice",
        options: ["horizontal", "vertical"],
        description: "Direction of steps",
        defaultValueHint: "horizontal"
      },
      progressDot: {
        type: "boolean",
        displayName: "Dot style"
      },
      status: {
        displayName: "Status of current step",
        type: "choice",
        options: statusOptions,
        defaultValueHint: "process"
      },
      type: {
        type: "choice",
        options: ["default", "navigation", "inline"],
        defaultValueHint: "default"
      },
      percent: {
        advanced: true,
        type: "number",
        description: "Number between 0 to 100"
      },
      responsive: {
        advanced: true,
        type: "boolean",
        description: "Change to vertical when screen narrower than 532px"
      },
      onChange: {
        type: "eventHandler",
        argTypes: [
          {
            name: "step",
            type: "number"
          }
        ]
      }
    },
    states: {
      current: {
        type: "writable",
        valueProp: "current",
        onChangeProp: "onChange",
        variableType: "number"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSteps",
    importName: "AntdSteps"
  });
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
function AntdSwitch(props) {
  return /* @__PURE__ */ React.createElement(Switch, __spreadValues$5({}, props));
}
AntdSwitch.__plasmicFormFieldMeta = { valueProp: "checked" };
function registerSwitch(loader) {
  registerComponentHelper(loader, AntdSwitch, {
    name: switchComponentName,
    displayName: "Switch",
    props: {
      checked: {
        type: "boolean",
        editOnly: true,
        uncontrolledProp: "defaultChecked",
        description: "Whether the switch is toggled on",
        defaultValueHint: false,
        hidden: (ps) => !!ps.__plasmicFormField
      },
      disabled: {
        type: "boolean",
        description: "If switch is disabled",
        defaultValueHint: false
      },
      autoFocus: {
        type: "boolean",
        description: "If get focus when component mounted",
        defaultValueHint: false,
        advanced: true
      },
      onChange: {
        type: "eventHandler",
        argTypes: [{ name: "checked", type: "boolean" }]
      }
    },
    states: {
      checked: {
        type: "writable",
        valueProp: "checked",
        onChangeProp: "onChange",
        variableType: "boolean",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerSwitch",
    importName: "AntdSwitch"
  });
}

var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const AntdTable = React.forwardRef(function AntdTable2(props, ref) {
  const _a = props, {
    data,
    onSelectedRowKeysChange,
    onSelectedRowsChange,
    isSelectable,
    rowKey,
    setControlContextData,
    selectedRowKeys,
    defaultSelectedRowKeys
  } = _a, rest = __objRest$2(_a, [
    "data",
    "onSelectedRowKeysChange",
    "onSelectedRowsChange",
    "isSelectable",
    "rowKey",
    "setControlContextData",
    "selectedRowKeys",
    "defaultSelectedRowKeys"
  ]);
  setControlContextData == null ? void 0 : setControlContextData(data);
  const isControlled = !!selectedRowKeys;
  const [uncontrolledSelectedRowKeys, setUncontrolledSelectedRowKeys] = React.useState(defaultSelectedRowKeys != null ? defaultSelectedRowKeys : []);
  const selection = isSelectable && rowKey ? {
    onChange: (rowKeys, rows) => {
      onSelectedRowsChange == null ? void 0 : onSelectedRowsChange(rows);
      onSelectedRowKeysChange == null ? void 0 : onSelectedRowKeysChange(rowKeys);
    },
    type: isSelectable === "single" ? "radio" : "checkbox",
    selectedRowKeys: isControlled ? asArray(selectedRowKeys) : uncontrolledSelectedRowKeys
  } : void 0;
  React.useImperativeHandle(
    ref,
    () => ({
      selectRowByIndex(index) {
        if (data.data && rowKey) {
          const row = data.data[index];
          const rows = row ? [row] : [];
          this._setSelectedRows(rows);
        }
      },
      selectRowsByIndexes(indexes) {
        if (data.data && rowKey) {
          const rows = indexes.map((x) => data.data[x]).filter((x) => !!x);
          this._setSelectedRows(rows);
        }
      },
      selectRowByKey(key) {
        if (data.data && rowKey) {
          const rows = data.data.filter((r) => r[rowKey] === key);
          this._setSelectedRows(rows);
        }
      },
      selectRowsByKeys(keys) {
        if (data.data && rowKey) {
          const rows = data.data.filter((r) => keys.includes(r[rowKey]));
          this._setSelectedRows(rows);
        }
      },
      clearSelection() {
        this._setSelectedRows([]);
      },
      _setSelectedRows(rows) {
        onSelectedRowsChange == null ? void 0 : onSelectedRowsChange(rows);
        if (rowKey) {
          onSelectedRowKeysChange == null ? void 0 : onSelectedRowKeysChange(rows.map((r) => r[rowKey]));
        }
        if (!isControlled) {
          setUncontrolledSelectedRowKeys(rows.map((r) => r[rowKey]));
        }
      }
    }),
    [data, onSelectedRowKeysChange, onSelectedRowsChange, isSelectable, rowKey]
  );
  return /* @__PURE__ */ React.createElement(
    Table,
    __spreadValues$4({
      loading: data == null ? void 0 : data.isLoading,
      dataSource: data == null ? void 0 : data.data,
      rowSelection: selection,
      rowKey
    }, rest)
  );
});
const AntdColumnGroup = Table.ColumnGroup;
const AntdColumn = Table.Column;
function registerTable(loader) {
  registerComponentHelper(loader, AntdTable, {
    name: "plasmic-antd5-table",
    displayName: "Table (deprecated)",
    props: {
      data: {
        type: "dataSourceOpData",
        displayName: "Data"
      },
      children: {
        type: "slot",
        allowedComponents: [
          "plasmic-antd5-table-column",
          "plasmic-antd5-table-column-group"
        ]
      },
      bordered: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true
      },
      isSelectable: {
        type: "choice",
        options: ["single", "multiple"],
        displayName: "Select rows?"
      },
      rowKey: {
        type: "choice",
        options: (ps, ctx) => {
          if (ctx.schema) {
            return ctx.schema.fields.map((f) => ({
              value: f.id,
              label: f.label || f.id
            }));
          }
          return [];
        },
        hidden: (ps) => !ps.isSelectable
      },
      selectedRowKeys: {
        type: "choice",
        multiSelect: (ps) => ps.isSelectable === "multiple",
        options: (ps, ctx) => {
          const key = ps.rowKey;
          if (key && ctx.data) {
            return ctx.data.map((r) => r[key]);
          }
          return [];
        },
        hidden: (ps) => !ps.rowKey
      },
      onSelectedRowKeysChange: {
        type: "eventHandler",
        argTypes: [{ name: "keys", type: "object" }],
        hidden: (ps) => !ps.isSelectable
      },
      onSelectedRowsChange: {
        type: "eventHandler",
        argTypes: [{ name: "rows", type: "object" }],
        hidden: (ps) => !ps.isSelectable
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerTable",
    importName: "AntdTable",
    states: {
      selectedRowKeys: {
        type: "writable",
        valueProp: "selectedRowKeys",
        onChangeProp: "onSelectedRowKeysChange",
        variableType: "array"
      }
      // selectedRows: {
      //   type: "readonly",
      //   onChangeProp: "onSelectedRowsChange",
      // },
    },
    refActions: {
      selectRowByIndex: {
        displayName: "Select row by index",
        argTypes: [
          {
            name: "index",
            displayName: "Index",
            type: "number"
          }
        ]
      },
      selectRowByKey: {
        displayName: "Select row by key",
        argTypes: [
          {
            name: "key",
            displayName: "Row key",
            type: "string"
          }
        ]
      }
    }
  });
  registerComponentHelper(loader, AntdColumn, __spreadValues$4({
    name: "plasmic-antd5-table-column",
    displayName: "Column",
    parentComponentName: "plasmic-antd5-table",
    props: {
      title: {
        type: "slot",
        defaultValue: "Column Name"
      },
      dataIndex: {
        type: "string",
        displayName: "Column key"
      },
      render: {
        type: "slot",
        renderPropParams: ["cell", "row", "index"],
        hidePlaceholder: true,
        displayName: "Custom render"
      },
      align: {
        type: "choice",
        options: ["left", "right", "center"],
        defaultValueHint: "left"
      },
      fixed: {
        type: "choice",
        options: ["left", "right"],
        advanced: true
      },
      colSpan: {
        type: "number",
        advanced: true
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerTable",
    importName: "AntdColumn"
  }, { isRenderless: true }));
  registerComponentHelper(loader, AntdColumnGroup, __spreadValues$4({
    name: "plasmic-antd5-table-column-group",
    displayName: "Column Group",
    parentComponentName: "plasmic-antd5-table",
    props: {
      title: {
        type: "slot",
        defaultValue: "Column Group Name"
      },
      children: {
        type: "slot",
        allowedComponents: ["plasmic-antd5-table-column"]
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerTable",
    importName: "AntdColumnGroup"
  }, { isRenderless: true }));
}

var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const tabsComponentName = "plasmic-antd5-tabs";
const tabItemComponentName = "plasmic-antd5-tab-item";
const AntdTabItem = ({ children }) => {
  return /* @__PURE__ */ React.createElement("div", null, children);
};
function getTabItems(items) {
  var _a, _b, _c;
  if (!React.isValidElement(items) && Array.isArray(items))
    return [...items];
  return ((_a = items == null ? void 0 : items.type) == null ? void 0 : _a.name) == AntdTabItem.name ? [items] : (_c = (_b = items == null ? void 0 : items.props) == null ? void 0 : _b.children) == null ? void 0 : _c.flat(1);
}
function getTabItemKeys(items) {
  const keys = [];
  traverseReactEltTree(items, (elt) => {
    var _a;
    if (((_a = elt == null ? void 0 : elt.type) == null ? void 0 : _a.name) === AntdTabItem.name && typeof (elt == null ? void 0 : elt.key) === "string") {
      keys.push(`${elt.key}`);
    }
  });
  return keys;
}
function AntdTabs(props) {
  const _a = props, {
    items: itemsRaw,
    animated,
    animateTabBar,
    animateTabContent,
    tabBarExtraContentLeft,
    tabBarExtraContentRight,
    sticky,
    stickyOffset,
    tabBarBackground,
    className,
    tabPosition,
    tabsScopeClassName,
    tabsDropdownScopeClassName
  } = _a, rest = __objRest$1(_a, [
    "items",
    "animated",
    "animateTabBar",
    "animateTabContent",
    "tabBarExtraContentLeft",
    "tabBarExtraContentRight",
    "sticky",
    "stickyOffset",
    "tabBarBackground",
    "className",
    "tabPosition",
    "tabsScopeClassName",
    "tabsDropdownScopeClassName"
  ]);
  const animationProp = useMemo(
    () => animated ? {
      inkBar: animateTabBar,
      tabPane: animateTabContent
    } : false,
    [animateTabBar, animateTabContent, animated]
  );
  const items = useMemo(() => {
    const tabItems = getTabItems(itemsRaw);
    return tabItems.map((currentItem) => {
      var _a2;
      return __spreadProps$3(__spreadValues$3({}, currentItem.props), {
        key: currentItem.key,
        children: /* @__PURE__ */ React.createElement(React.Fragment, null, (_a2 = currentItem.props) == null ? void 0 : _a2.children)
      });
    }).filter((i) => i != null);
  }, [itemsRaw]);
  return /* @__PURE__ */ React.createElement(
    Tabs,
    __spreadValues$3({
      className: `${className} ${tabsScopeClassName}`,
      popupClassName: tabsDropdownScopeClassName,
      tabBarExtraContent: {
        left: /* @__PURE__ */ React.createElement(React.Fragment, null, tabBarExtraContentLeft),
        right: /* @__PURE__ */ React.createElement(React.Fragment, null, tabBarExtraContentRight)
      },
      tabPosition,
      renderTabBar: sticky && tabPosition === "top" ? (tabBarProps, DefaultTabBar) => /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            zIndex: 1,
            position: "sticky",
            top: stickyOffset || 0
          }
        },
        /* @__PURE__ */ React.createElement(
          DefaultTabBar,
          __spreadProps$3(__spreadValues$3({}, tabBarProps), {
            style: { backgroundColor: tabBarBackground }
          })
        )
      ) : void 0,
      animated: animationProp,
      items
    }, rest)
  );
}
function OutlineMessage() {
  return /* @__PURE__ */ React.createElement("div", null, "* To re-arrange tab panes, use the Outline panel");
}
function registerTabs(loader) {
  registerComponentHelper(loader, AntdTabs, {
    name: tabsComponentName,
    displayName: "Tabs",
    defaultStyles: {
      width: "stretch",
      overflow: "scroll"
    },
    props: {
      activeKey: {
        editOnly: true,
        displayName: "Active tab key",
        uncontrolledProp: "defaultActiveKey",
        type: "choice",
        description: `Initial active tab's key`,
        options: (ps) => getTabItemKeys(ps.items)
      },
      animated: {
        type: "boolean",
        defaultValue: true,
        description: "Change tabs with animation"
      },
      animateTabBar: {
        type: "boolean",
        defaultValue: true,
        description: "Animate the tab bar when switching tabs",
        hidden: (ps) => !ps.animated
      },
      animateTabContent: {
        type: "boolean",
        defaultValue: false,
        description: "Fade-in tab content when switching tabs",
        hidden: (ps) => !ps.animated
      },
      centered: {
        type: "boolean",
        description: "Center-align the tab bar"
      },
      type: {
        type: "choice",
        defaultValueHint: "line",
        options: ["line", "card"],
        description: "Basic style of tabs"
      },
      items: __spreadProps$3(__spreadValues$3({
        type: "slot",
        hidePlaceholder: true,
        allowedComponents: [tabItemComponentName]
      }, { mergeWithParent: true }), {
        // to make the tab items selectable from the components outline pane in Plasmic Studio.
        defaultValue: [
          {
            type: "component",
            name: tabItemComponentName,
            props: {
              key: "1",
              label: {
                type: "text",
                value: "First Item"
              },
              children: {
                type: "text",
                value: "First Children"
              }
            }
          },
          {
            type: "component",
            name: tabItemComponentName,
            props: {
              key: "2",
              label: {
                type: "text",
                value: "Second Item"
              },
              children: {
                type: "text",
                value: "Second Children"
              }
            }
          }
        ]
      }),
      size: {
        type: "choice",
        defaultValueHint: "middle",
        options: ["large", "middle", "small"],
        description: "Preset tab bar size"
      },
      tabBarExtraContentLeft: {
        type: "slot",
        displayName: "Extra content on left side",
        hidePlaceholder: true
      },
      tabBarExtraContentRight: {
        type: "slot",
        displayName: "Extra content on right side",
        hidePlaceholder: true
      },
      tabBarGutter: {
        type: "number",
        displayName: "Tab gap",
        description: "Gap (in pixels) between tabs",
        advanced: true
      },
      tabPosition: {
        type: "choice",
        defaultValueHint: "top",
        options: ["top", "right", "bottom", "left"],
        description: "Position of tabs"
      },
      destroyInactiveTabPane: {
        type: "boolean",
        description: `Destroy/Unmount inactive tab pane when changing tab`,
        advanced: true
      },
      sticky: {
        type: "boolean",
        advanced: true,
        description: "Stick tab bar to the top of the page when scrolling.",
        defaultValue: false,
        hidden: (ps) => ps.tabPosition !== "top"
      },
      stickyOffset: {
        type: "number",
        advanced: true,
        description: "Distance (in pixels) between the sticky tab bar and the top of the page as you scroll.",
        hidden: (ps) => ps.tabPosition !== "top" || !ps.sticky
      },
      tabBarBackground: {
        type: "color",
        advanced: true,
        defaultValue: "#FFF",
        hidden: (ps) => ps.tabPosition !== "top" || !ps.sticky
      },
      tabsScopeClassName: {
        type: "styleScopeClass",
        scopeName: "tabs"
      },
      tabBarClassName: {
        type: "class",
        displayName: "Tab bar",
        selectors: [
          {
            selector: ":tabs.ant-tabs .ant-tabs-nav",
            label: "Base"
          }
        ]
      },
      tabsDropdownScopeClassName: {
        type: "styleScopeClass",
        scopeName: "tabsDropdown"
      },
      tabsDropdownClassName: {
        type: "class",
        displayName: "Overflow tabs menu",
        selectors: [
          {
            selector: ":tabsDropdown.ant-tabs-dropdown .ant-tabs-dropdown-menu",
            label: "Base"
          }
        ]
      },
      onChange: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "activeKey", type: "string" }]
      },
      onTabClick: {
        type: "eventHandler",
        advanced: true,
        argTypes: [
          { name: "tabKey", type: "string" },
          { name: "mouseEvent", type: "object" }
        ]
      },
      onTabScroll: {
        type: "eventHandler",
        advanced: true,
        argTypes: [{ name: "scrollInfo", type: "object" }]
      }
    },
    states: {
      activeKey: {
        type: "writable",
        valueProp: "activeKey",
        onChangeProp: "onChange",
        variableType: "text"
      }
    },
    actions: [
      // {
      //   type: "custom-action",
      //   control: NavigateTabs,
      // },
      {
        type: "button-action",
        label: "Add new tab",
        onClick: ({ componentProps, studioOps }) => {
          const generateNewKey = () => {
            const existingKeys = getTabItemKeys(componentProps.items);
            for (let keyCandidate = 1; keyCandidate <= existingKeys.length + 1; keyCandidate++) {
              const strKey = keyCandidate.toString();
              const index = existingKeys.findIndex((k) => {
                return strKey === k;
              });
              if (index === -1) {
                return strKey;
              }
            }
            return void 0;
          };
          const tabKey = generateNewKey();
          studioOps.appendToSlot(
            {
              type: "component",
              name: tabItemComponentName,
              props: {
                key: tabKey,
                label: {
                  type: "text",
                  value: `Tab Label ${tabKey}`
                },
                children: {
                  type: "text",
                  value: `Tab Children ${tabKey}`
                }
              }
            },
            "items"
          );
          studioOps.updateProps({ activeKey: tabKey });
        }
      },
      {
        type: "button-action",
        label: "Delete current tab",
        onClick: ({ componentProps, studioOps }) => {
          if (componentProps.activeKey) {
            const tabPanes = getTabItemKeys(componentProps.items);
            const activeKey = componentProps.activeKey;
            const currTabPos = tabPanes.findIndex((tabKey) => {
              return tabKey === activeKey;
            });
            if (currTabPos !== -1) {
              studioOps.removeFromSlotAt(currTabPos, "items");
              if (tabPanes.length - 1 > 0) {
                const prevTabPos = (currTabPos - 1 + tabPanes.length) % tabPanes.length;
                studioOps.updateProps({ activeKey: tabPanes[prevTabPos] });
              }
            }
          }
        }
      },
      {
        type: "custom-action",
        control: OutlineMessage
      }
    ],
    importPath: "@plasmicpkgs/antd5/skinny/registerTabs",
    importName: "AntdTabs"
  });
  registerComponentHelper(loader, AntdTabItem, {
    name: tabItemComponentName,
    displayName: "Tab Item",
    props: {
      disabled: {
        type: "boolean",
        description: "Disable this tab"
      },
      forceRender: {
        type: "boolean",
        description: `Force render of content in the tab, not lazy render after clicking on the tab`,
        advanced: true
      },
      key: {
        type: "string",
        description: `Unique identifier for this tab`,
        displayName: "Tab key"
      },
      label: {
        type: "slot",
        displayName: "Tab title",
        defaultValue: "Tab"
      },
      children: {
        type: "slot",
        hidePlaceholder: true
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerTabs",
    importName: "AntdTabItem",
    parentComponentName: tabsComponentName
  });
}

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
function AntdTooltip(props) {
  return /* @__PURE__ */ React.createElement(Tooltip, __spreadProps$2(__spreadValues$2({}, props), { title: props.title || props.titleText }));
}
function registerTooltip(loader) {
  registerComponentHelper(loader, AntdTooltip, {
    name: "plasmic-antd5-tooltip",
    displayName: "Tooltip",
    isAttachment: true,
    props: {
      children: {
        type: "slot",
        defaultValue: {
          type: "text",
          value: "This text element is wrapped in a Tooltip component"
        },
        mergeWithParent: true
      },
      overlayClassName: {
        type: "class",
        displayName: "Overlay"
      },
      titleText: {
        type: "string",
        displayName: "Tooltip contents",
        description: "What gets shown inside the tooltip on hover",
        defaultValue: "Tooltip contents"
      },
      title: {
        type: "slot",
        displayName: "Tooltip contents",
        hidePlaceholder: true
      },
      color: {
        type: "color",
        description: "Tooltip fill color"
      },
      placement: {
        type: "choice",
        options: [
          "topLeft",
          "top",
          "topRight",
          "leftTop",
          "left",
          "leftBottom",
          "rightTop",
          "right",
          "rightBottom",
          "bottomLeft",
          "bottom",
          "bottomRight"
        ],
        description: "Default placement of tooltip",
        defaultValueHint: "top"
      }
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerTooltip",
    importName: "AntdTooltip"
  });
}

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
function useMunged(props) {
  const [autoExpandParent, setAutoExpandParent] = useState(
    props.autoExpandParent
  );
  const munged = __spreadProps$1(__spreadValues$1({}, props), { autoExpandParent });
  if (!props.expandedKeys) {
    delete munged["expandedKeys"];
  }
  munged.onExpand = (expandedKeys, info) => {
    var _a;
    (_a = props.onExpand) == null ? void 0 : _a.call(props, expandedKeys, info);
    setAutoExpandParent(false);
  };
  return munged;
}
function AntdTree(props) {
  const munged = useMunged(props);
  return /* @__PURE__ */ React.createElement(Tree, __spreadValues$1({}, munged));
}
function AntdDirectoryTree(props) {
  const munged = useMunged(props);
  return /* @__PURE__ */ React.createElement(Tree.DirectoryTree, __spreadValues$1({}, munged));
}
const treeHelpers_ = {
  states: {
    selectedKeys: {
      onChangeArgsToValue: (selectedKeys, _info) => {
        return selectedKeys;
      }
    },
    selectedNodes: {
      onChangeArgsToValue: (_selectedKeys, info) => {
        return info.selectedNodes;
      }
    },
    expandedKeys: {
      onChangeArgsToValue: (expandedKeys, _info) => {
        return expandedKeys;
      }
    },
    checkedKeys: {
      onChangeArgsToValue: (checkedKeys, _info) => {
        return checkedKeys;
      }
    },
    checkedNodes: {
      onChangeArgsToValue: (_checkedKeys, info) => {
        return info.checkedNodes;
      }
    },
    checkedDetails: {
      onChangeArgsToValue: (_checkedKeys, info) => {
        return {
          checkedNodesPositions: info.checkedNodesPositions,
          halfCheckedKeys: info.halfCheckedKeys
        };
      }
    }
  }
};
const treeData = [
  {
    title: "Node 0",
    key: "0",
    children: [
      {
        title: "Node 0-0",
        key: "0-0",
        children: [
          {
            title: "Node 0-0-0",
            key: "0-0-0",
            disableCheckbox: true
          },
          {
            title: "Node 0-0-1",
            key: "0-0-1",
            disabled: true
          },
          {
            title: "Node 0-0-2",
            key: "0-0-2"
          }
        ]
      },
      {
        title: "Node 0-1",
        key: "0-1",
        children: [
          {
            title: "Node 0-1-0",
            key: "0-1-0"
          },
          {
            title: "Node 0-1-1",
            key: "0-1-1"
          }
        ]
      }
    ]
  }
];
function registerTreeHelper({
  loader,
  component,
  name,
  displayName,
  importName,
  checkableDefaultValue,
  expandActionDefaultValue
}) {
  registerComponentHelper(loader, component, {
    name,
    displayName,
    props: {
      treeData: {
        type: "array",
        defaultValue: treeData
      },
      checkable: {
        type: "boolean",
        defaultValue: checkableDefaultValue
      },
      selectable: {
        type: "boolean",
        defaultValueHint: true
      },
      checkedKeys: {
        type: "array",
        editOnly: true,
        uncontrolledProp: "defaultCheckedKeys",
        description: "List of checked keys.",
        hidden: (ps) => !ps.checkable
      },
      selectedKeys: {
        type: "array",
        editOnly: true,
        uncontrolledProp: "defaultSelectedKeys",
        description: "List of selected keys.",
        hidden: (ps) => {
          var _a;
          return !((_a = ps.selectable) != null ? _a : true);
        },
        advanced: true
      },
      expandedKeys: {
        type: "array",
        editOnly: true,
        uncontrolledProp: "defaultExpandedKeys",
        description: "List of expanded keys.",
        // hidden: (ps) => !ps.expa,
        advanced: true
      },
      disabled: {
        type: "boolean",
        defaultValueHint: false
      },
      showLine: {
        type: "boolean",
        defaultValueHint: false
      },
      defaultExpandAll: {
        type: "boolean",
        description: "Whether to automatically expand all nodes at initialization",
        defaultValueHint: false,
        defaultValue: true
      },
      autoExpandParent: {
        type: "boolean",
        description: "Whether to automatically expand a parent node",
        defaultValue: true,
        advanced: true
      },
      defaultExpandParent: {
        type: "boolean",
        description: "Whether to automatically expand a parent node at initialization",
        defaultValueHint: false,
        advanced: true
      },
      expandAction: {
        type: "choice",
        options: [
          {
            label: "None",
            value: false
          },
          {
            label: "Click",
            value: "click"
          },
          {
            label: "Double click",
            value: "doubleClick"
          }
        ],
        defaultValueHint: expandActionDefaultValue
      },
      multiple: {
        type: "boolean",
        defaultValueHint: false,
        description: "Whether to allow multiple selection",
        advanced: true
      },
      titleRender: {
        type: "slot",
        hidePlaceholder: true,
        renderPropParams: ["node"]
      },
      // draggable: {
      //   type: "boolean",
      //   defaultValueHint: false,
      //   advanced: true,
      // },
      // allowDrop: {
      //   type: "boolean",
      //   defaultValueHint: false,
      //   advanced: true,
      //   description: "Whether to allow dropping on the node",
      // },
      onSelect: {
        type: "eventHandler",
        argTypes: [
          { name: "selectedKeys", type: { type: "array" } },
          {
            name: "selectedNodes",
            type: { type: "array" }
          }
        ]
      },
      onCheck: {
        type: "eventHandler",
        argTypes: [
          { name: "checkedKeys", type: { type: "array" } },
          {
            name: "checkDetails",
            type: { type: "object" }
          }
        ]
      },
      onExpand: {
        type: "eventHandler",
        argTypes: [
          { name: "expandedKeys", type: { type: "array" } },
          {
            name: "expandDetails",
            type: { type: "object" }
          }
        ]
      }
    },
    states: {
      checkedKeys: __spreadValues$1({
        type: "writable",
        valueProp: "checkedKeys",
        onChangeProp: "onCheck",
        variableType: "array"
      }, treeHelpers_.states.checkedKeys),
      checkedNodes: __spreadValues$1({
        type: "readonly",
        onChangeProp: "onCheck",
        variableType: "array",
        initVal: []
      }, treeHelpers_.states.checkedNodes),
      checkedDetails: __spreadValues$1({
        type: "readonly",
        onChangeProp: "onCheck",
        variableType: "object",
        initVal: {
          checkedNodesPositions: [],
          halfCheckedKeys: []
        }
      }, treeHelpers_.states.checkedDetails),
      selectedKeys: __spreadValues$1({
        type: "writable",
        valueProp: "selectedKeys",
        onChangeProp: "onSelect",
        variableType: "array"
      }, treeHelpers_.states.selectedKeys),
      selectedNodes: __spreadValues$1({
        type: "readonly",
        onChangeProp: "onSelect",
        variableType: "array",
        initVal: []
      }, treeHelpers_.states.selectedNodes),
      expandedKeys: __spreadValues$1({
        type: "writable",
        valueProp: "expandedKeys",
        onChangeProp: "onExpand",
        variableType: "array"
      }, treeHelpers_.states.expandedKeys)
    },
    componentHelpers: {
      helpers: treeHelpers_,
      importName: "treeHelpers",
      importPath: "@plasmicpkgs/antd5/skinny/registerTree"
    },
    importPath: "@plasmicpkgs/antd5/skinny/registerTree",
    importName
  });
}
function registerTree(loader) {
  registerTreeHelper({
    loader,
    component: AntdTree,
    name: "plasmic-antd5-tree",
    displayName: "Tree",
    importName: "AntdTree",
    checkableDefaultValue: true,
    expandActionDefaultValue: false
  });
}
function registerDirectoryTree(loader) {
  registerTreeHelper({
    loader,
    component: AntdDirectoryTree,
    name: "plasmic-antd5-directory-tree",
    displayName: "Directory Tree",
    importName: "AntdDirectoryTree",
    checkableDefaultValue: false,
    expandActionDefaultValue: "click"
  });
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function getThumbUrl(file) {
  var _a;
  if (!((_a = file == null ? void 0 : file.type) == null ? void 0 : _a.startsWith("image"))) {
    return void 0;
  }
  return `data:${file.type};base64,${file.contents}`;
}
function UploadWrapper(props) {
  const _a = props, { files, dragAndDropFiles, onFilesChange, maxCount } = _a, rest = __objRest(_a, ["files", "dragAndDropFiles", "onFilesChange", "maxCount"]);
  const filesRef = useRef();
  filesRef.current = files;
  const [previewFileId, setPreviewFileId] = useState();
  const [previewOpen, setPreviewOpen] = useState(false);
  const handleChange = (info) => {
    var _a2;
    const { file } = info;
    if (file.status === "removed") {
      return;
    }
    const metadata = {
      uid: file.uid,
      name: file.name,
      size: file.size,
      type: file.type,
      lastModified: file.lastModified
    };
    onFilesChange == null ? void 0 : onFilesChange([
      ...((_a2 = filesRef.current) != null ? _a2 : []).slice(0, (maxCount || Infinity) - 1),
      __spreadProps(__spreadValues({}, metadata), {
        status: "uploading"
      })
    ]);
    const reader = new FileReader();
    reader.onload = () => {
      var _a3, _b;
      if (!((_a3 = filesRef.current) == null ? void 0 : _a3.map((f) => f.uid).includes(metadata.uid))) {
        return;
      }
      onFilesChange == null ? void 0 : onFilesChange([
        ...((_b = filesRef.current) != null ? _b : []).filter((f) => f.uid !== file.uid),
        __spreadProps(__spreadValues({}, metadata), {
          contents: reader.result.replace(
            /^data:[^;]+;base64,/,
            ""
          ),
          status: "done"
        })
      ]);
    };
    reader.onerror = () => {
      var _a3, _b;
      if (!((_a3 = filesRef.current) == null ? void 0 : _a3.map((f) => f.uid).includes(metadata.uid))) {
        return;
      }
      onFilesChange == null ? void 0 : onFilesChange([
        ...((_b = filesRef.current) != null ? _b : []).filter((f) => f.uid !== file.uid),
        __spreadProps(__spreadValues({}, metadata), {
          status: "error"
        })
      ]);
    };
    reader.readAsDataURL(info.file);
  };
  const handleRemove = (file) => {
    onFilesChange == null ? void 0 : onFilesChange((files != null ? files : []).filter((f) => f.uid !== file.uid));
  };
  const handlePreview = async (file) => {
    var _a2;
    setPreviewFileId((_a2 = files == null ? void 0 : files.filter((f) => file.uid === f.uid)[0]) == null ? void 0 : _a2.uid);
    setPreviewOpen(true);
  };
  const handleCancel = () => setPreviewFileId(void 0);
  const previewFile = useMemo(
    () => files == null ? void 0 : files.filter((f) => previewFileId === f.uid)[0],
    [files, previewFileId]
  );
  const UploadComponent = useMemo(
    () => dragAndDropFiles ? Upload.Dragger : Upload,
    [dragAndDropFiles]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    UploadComponent,
    __spreadProps(__spreadValues({}, rest), {
      fileList: files == null ? void 0 : files.map((f) => __spreadProps(__spreadValues({}, f), {
        thumbUrl: getThumbUrl(f)
      })),
      onPreview: handlePreview,
      beforeUpload: () => {
        return false;
      },
      onChange: (info) => {
        handleChange(info);
      },
      onRemove: (file) => {
        handleRemove(file);
      }
    })
  ), previewFile && /* @__PURE__ */ React.createElement(
    Image,
    {
      wrapperStyle: { display: "none" },
      preview: {
        visible: previewOpen,
        onVisibleChange: (visible) => setPreviewOpen(visible),
        afterOpenChange: (visible) => !visible && handleCancel()
      },
      alt: previewFile == null ? void 0 : previewFile.name,
      src: getThumbUrl(previewFile)
    }
  ));
}
UploadWrapper.__plasmicFormFieldMeta = {
  valueProp: "files",
  onChangeProp: "onFilesChange"
};
function registerUpload(loader) {
  registerComponentHelper(loader, UploadWrapper, __spreadProps(__spreadValues({
    name: "plasmic-antd5-upload",
    displayName: "Upload",
    props: {
      accept: {
        type: "choice",
        displayName: "Allowed types",
        options: [
          {
            value: "",
            label: "Any kind of file"
          },
          {
            value: "image/*",
            label: "Image"
          },
          {
            value: "video/*",
            label: "Video"
          },
          {
            value: "audio/*",
            label: "Audio"
          },
          {
            value: "application/pdf",
            label: "PDF"
          }
        ],
        defaultValue: ""
      },
      listType: {
        type: "choice",
        options: ["text", "picture", "picture-card", "picture-circle"],
        defaultValueHint: "text"
      },
      dragAndDropFiles: {
        type: "boolean",
        defaultValueHint: false,
        advanced: true,
        description: "You can drag files to a specific area, to upload. Alternatively, you can also upload by selecting."
      },
      multiple: {
        type: "boolean",
        advanced: true,
        defaultValueHint: false,
        description: "Upload several files at once in modern browsers"
      },
      files: {
        type: "object",
        displayName: "Files",
        defaultValue: [],
        hidden: (ps) => !!ps.__plasmicFormField
      },
      children: {
        type: "slot",
        defaultValue: [
          {
            type: "component",
            name: "plasmic-antd5-button",
            props: {
              children: {
                type: "text",
                value: "Upload"
              }
            }
          }
        ]
      },
      maxCount: {
        type: "number",
        displayName: "Limit of files",
        advanced: true
      },
      onFilesChange: {
        type: "eventHandler",
        displayName: "On file uploaded",
        argTypes: [
          {
            name: "files",
            type: "array"
          }
        ]
      },
      showUploadList: {
        type: "boolean",
        displayName: "List files",
        defaultValue: true
      }
    },
    states: {
      files: {
        type: "writable",
        valueProp: "files",
        variableType: "array",
        onChangeProp: "onFilesChange",
        hidden: (ps) => !!ps.__plasmicFormField
      }
    }
  }, { trapsSelection: true }), {
    importPath: "@plasmicpkgs/antd5/skinny/registerUpload",
    importName: "UploadWrapper"
  }));
}

function registerAll(loader) {
  registerConfigProvider(loader);
  registerTokens(loader);
  registerSelect(loader);
  registerTable(loader);
  registerCheckbox(loader);
  registerSwitch(loader);
  registerRadio(loader);
  registerModal(loader);
  registerButton(loader);
  registerMenu(loader);
  registerDropdown(loader);
  registerForm(loader);
  registerFormItem(loader);
  registerFormGroup(loader);
  registerFormList(loader);
  registerInput(loader);
  registerPasswordInput(loader);
  registerTextArea(loader);
  registerNumberInput(loader);
  registerDatePicker(loader);
  registerDateRangePicker(loader);
  registerUpload(loader);
  registerColorPicker(loader);
  registerDrawer(loader);
  registerSteps(loader);
  registerTooltip(loader);
  registerAvatar(loader);
  registerAvatarGroup(loader);
  registerTree(loader);
  registerDirectoryTree(loader);
  registerCollapse(loader);
  registerPopover(loader);
  registerTabs(loader);
  registerRate(loader);
  registerSlider(loader);
  registerSegmented(loader);
  registerProgress(loader);
  registerPagination(loader);
  registerBreadcrumb(loader);
  registerBreadcrumbItem(loader);
}
const componentNameToInputType = {
  [inputComponentName]: InputType.Text,
  [textAreaComponentName]: InputType.TextArea,
  [passwordComponentName]: InputType.Password,
  [inputNumberComponentName]: InputType.Number,
  [selectComponentName]: InputType.Select,
  [optionComponentName]: InputType.Option,
  [optionGroupComponentName]: InputType.OptionGroup,
  [radioComponentName]: InputType.Radio,
  [radioGroupComponentName]: InputType.RadioGroup,
  [datePickerComponentName]: InputType.DatePicker,
  [checkboxComponentName]: InputType.Checkbox
};
const inputTypeToComponentName = Object.fromEntries(
  Object.entries(componentNameToInputType).map((kv) => kv.reverse())
);

export { FormType, InputType, OPTIMIZED_FORM_IMPORT, buttonComponentName, checkboxComponentName, checkboxGroupComponentName, componentNameToInputType, deriveFormFieldConfigs, formComponentName, formGroupComponentName, formItemComponentName, formListComponentName, formTypeDescription, inputComponentName, inputNumberComponentName, inputTypeToComponentName, optionComponentName, optionGroupComponentName, passwordComponentName, radioButtonComponentName, radioComponentName, radioGroupComponentName, registerAll, registerForm, selectComponentName, switchComponentName, textAreaComponentName };
//# sourceMappingURL=antd.esm.js.map
