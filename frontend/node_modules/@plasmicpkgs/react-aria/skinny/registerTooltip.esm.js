import React, { useContext, useState, useCallback, useRef } from 'react';
import { useHover, useFocusWithin, mergeProps, useId } from 'react-aria';
import { TooltipTriggerStateContext, Provider, Tooltip } from 'react-aria-components';
import { useTooltipTriggerState } from 'react-stately';
import { C as COMMON_STYLES, b as getCommonOverlayProps } from './common-3fde23cc.esm.js';
import { a as useIsOpen, r as registerComponentHelper } from './utils-b68e14cf.esm.js';
import '@plasmicapp/host';
import '@plasmicapp/host/registerComponent';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function BaseTooltip(props) {
  if (props.isOpen !== void 0) {
    return /* @__PURE__ */ React.createElement(ControlledBaseTooltip, __spreadValues({}, props));
  } else {
    return /* @__PURE__ */ React.createElement(UncontrolledBaseTooltip, __spreadValues({}, props));
  }
}
function UncontrolledBaseTooltip(_a) {
  var _b = _a, { onOpenChange } = _b, props = __objRest(_b, ["onOpenChange"]);
  var _a2;
  const [open, setOpen] = useState((_a2 = props.defaultOpen) != null ? _a2 : false);
  const onOpenChangeMerged = useCallback(
    (newOpen) => {
      setOpen(newOpen);
      onOpenChange == null ? void 0 : onOpenChange(newOpen);
    },
    [onOpenChange]
  );
  return /* @__PURE__ */ React.createElement(
    ControlledBaseTooltip,
    __spreadProps(__spreadValues({}, props), {
      isOpen: open,
      onOpenChange: onOpenChangeMerged
    })
  );
}
function ControlledBaseTooltip(props) {
  const {
    children,
    isDisabled = false,
    delay,
    closeDelay,
    trigger,
    isOpen,
    tooltipContent,
    resetClassName,
    placement,
    offset,
    crossOffset,
    shouldFlip,
    className,
    onOpenChange = () => {
    }
  } = props;
  const isCanvasAwareOpen = useIsOpen({
    triggerSlotName: "children",
    isOpen,
    props
  });
  const ref = useRef(null);
  const tooltipId = useId();
  const state = useTooltipTriggerState(__spreadProps(__spreadValues({}, props), {
    isOpen: isCanvasAwareOpen,
    trigger: trigger === "focus" ? trigger : void 0
  }));
  return (
    // TooltipTriggerStateContext used by BaseOverlayArrow
    /* @__PURE__ */ React.createElement(Provider, { values: [[TooltipTriggerStateContext, state]] }, /* @__PURE__ */ React.createElement(
      TriggerWrapper,
      {
        ref,
        className,
        tooltipId: state.isOpen ? tooltipId : void 0,
        isDisabled,
        triggerOnFocusOnly: trigger === "focus"
      },
      children
    ), /* @__PURE__ */ React.createElement(
      Tooltip,
      {
        triggerRef: ref,
        id: tooltipId,
        offset,
        delay,
        closeDelay,
        crossOffset,
        shouldFlip,
        className: resetClassName,
        onOpenChange,
        placement
      },
      tooltipContent
    ))
  );
}
const TriggerWrapper = React.forwardRef(
  function TriggerWrapper_({ children, isDisabled, triggerOnFocusOnly, tooltipId, className }, ref) {
    const state = useContext(TooltipTriggerStateContext);
    const { hoverProps } = useHover({
      isDisabled,
      onHoverStart: () => !triggerOnFocusOnly && state.open(),
      onHoverEnd: () => !triggerOnFocusOnly && state.close()
    });
    const { focusWithinProps } = useFocusWithin({
      isDisabled,
      onFocusWithin: () => state.open(),
      onBlurWithin: () => state.close()
    });
    const mergedProps = mergeProps(hoverProps, focusWithinProps, {
      "aria-describedby": tooltipId,
      // We expose className to allow user control over the wrapper div's styling.
      className,
      ref,
      style: COMMON_STYLES
    });
    return /* @__PURE__ */ React.createElement("div", __spreadValues({}, mergedProps), children);
  }
);
function registerTooltip(loader, overrides) {
  registerComponentHelper(
    loader,
    BaseTooltip,
    {
      name: "plasmic-react-aria-tooltip",
      displayName: "Aria Tooltip",
      importPath: "@plasmicpkgs/react-aria/skinny/registerTooltip",
      importName: "BaseTooltip",
      isAttachment: true,
      props: __spreadProps(__spreadValues({
        children: {
          type: "slot",
          mergeWithParent: true,
          displayName: "Trigger",
          defaultValue: {
            type: "text",
            value: "Hover me!",
            styles: {
              width: "hug"
            }
          }
        },
        tooltipContent: {
          type: "slot",
          mergeWithParent: true,
          displayName: "Tooltip Content",
          // NOTE: This is not applied in attachment
          defaultValue: {
            type: "text",
            value: "Hello from Tooltip!",
            styles: {
              background: "black",
              color: "white",
              padding: "7px",
              borderRadius: "7px"
            }
          }
        },
        resetClassName: {
          type: "themeResetClass"
        },
        isDisabled: {
          type: "boolean"
        },
        delay: {
          type: "number",
          // Default value is explicitly set to 0 to prevent users from mistakenly thinking the tooltip isn’t opening due to a delay.
          defaultValue: 0,
          defaultValueHint: 0,
          description: "The delay (in milliseconds) for the tooltip to show up."
        },
        closeDelay: {
          type: "number",
          // Default value is explicitly set to 0 to prevent users from mistakenly thinking the tooltip isn’t closing due to a delay.
          defaultValue: 0,
          defaultValueHint: 0,
          description: "The delay (in milliseconds) for the tooltip to close."
        },
        trigger: {
          type: "choice",
          options: ["focus", "focus and hover"],
          defaultValueHint: "focus and hover"
        }
      }, getCommonOverlayProps("popover", {
        placement: { defaultValueHint: "top" },
        offset: { defaultValueHint: 0 },
        containerPadding: { defaultValueHint: 12 },
        crossOffset: { defaultValueHint: 0 }
      })), {
        isOpen: {
          type: "boolean",
          editOnly: true,
          uncontrolledProp: "defaultOpen",
          description: "Whether the overlay is open by default",
          defaultValueHint: false,
          hidden: () => true
        },
        onOpenChange: {
          type: "eventHandler",
          argTypes: [{ name: "isOpen", type: "boolean" }]
        }
      }),
      states: {
        isOpen: {
          type: "writable",
          valueProp: "isOpen",
          onChangeProp: "onOpenChange",
          variableType: "boolean"
        }
      },
      trapsFocus: true
    },
    overrides
  );
}

export { BaseTooltip, registerTooltip };
//# sourceMappingURL=registerTooltip.esm.js.map
