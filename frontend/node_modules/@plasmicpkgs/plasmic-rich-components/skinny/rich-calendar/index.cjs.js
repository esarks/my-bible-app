'use strict';

var dayjs = require('dayjs');
var commonPropTypes = require('../common-prop-types-193ce561.cjs.js');
var utils = require('../utils-65c486f0.cjs.js');
var dataSources = require('@plasmicapp/data-sources');
var luxonParser = require('@plasmicpkgs/luxon-parser');
var antd = require('antd');
var groupBy = require('lodash/groupBy');
var React = require('react');
var formatting = require('../formatting-6dc71cdd.cjs.js');
var localeData = require('dayjs/plugin/localeData');
var weekday = require('dayjs/plugin/weekday');
require('../common-e1d76791.cjs.js');
require('@ctrl/tinycolor');
require('@plasmicapp/host/registerComponent');
require('@plasmicapp/host/registerGlobalContext');
require('dayjs/plugin/customParseFormat');
require('lodash/get');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var dayjs__default = /*#__PURE__*/_interopDefault(dayjs);
var groupBy__default = /*#__PURE__*/_interopDefault(groupBy);
var React__default = /*#__PURE__*/_interopDefault(React);
var localeData__default = /*#__PURE__*/_interopDefault(localeData);
var weekday__default = /*#__PURE__*/_interopDefault(weekday);

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
dayjs__default.default.extend(weekday__default.default);
dayjs__default.default.extend(localeData__default.default);
function getEventFullDate(date) {
  const parsed = luxonParser.parseDate(date);
  if (!parsed)
    return void 0;
  const yyyy = parsed.getFullYear();
  const mm = (parsed.getMonth() + 1).toString().padStart(2, "0");
  const dd = parsed.getDate().toString().padStart(2, "0");
  return `${yyyy}-${mm}-${dd}`;
}
function getEventMonthYear(date) {
  var _a;
  return (_a = getEventFullDate(date)) == null ? void 0 : _a.substring(0, 7);
}
function EventCell({ events }) {
  if (!events || !events.length)
    return null;
  return /* @__PURE__ */ React__default.default.createElement("ul", { style: { all: "unset" } }, events.map((e) => /* @__PURE__ */ React__default.default.createElement("li", { key: JSON.stringify(e), style: { all: "unset", display: "block" } }, /* @__PURE__ */ React__default.default.createElement(antd.Badge, { color: e.color || "green", text: e.title }))));
}
function RichCalendar(props) {
  const _a = props, {
    data: rawData = {
      data: [],
      schema: {
        id: "inferred",
        fields: [
          {
            id: "id",
            type: "string",
            readOnly: false
          }
        ]
      }
    },
    value: isoValue,
    defaultValue: isoDefaultValue,
    validRange: isoValidRange,
    dateCellRender,
    dateFullCellRender,
    monthCellRender,
    monthFullCellRender
  } = _a, rest = __objRest(_a, [
    "data",
    "value",
    "defaultValue",
    "validRange",
    "dateCellRender",
    "dateFullCellRender",
    "monthCellRender",
    "monthFullCellRender"
  ]);
  const data = dataSources.useNormalizedData(rawData);
  const { normalized, finalRoles: roleConfigs } = useRoleDefinitions(
    data,
    props
  );
  const {
    eventsByDate,
    eventsByMonth
  } = React.useMemo(() => {
    if (!data)
      return { eventsByDate: {}, eventsByMonth: {} };
    return data == null ? void 0 : data.data.reduce(
      (acc, item) => {
        const date = formatting.getFieldAggregateValue(item, roleConfigs.date);
        const title = formatting.getFieldAggregateValue(item, roleConfigs.title);
        const color = formatting.getFieldAggregateValue(item, roleConfigs.color);
        const event = {
          date,
          title,
          color
        };
        const keyDate = getEventFullDate(date);
        const keyMonth = getEventMonthYear(date);
        if (keyDate && keyMonth) {
          acc.eventsByDate[keyDate] = [
            ...acc.eventsByDate[keyDate] || [],
            event
          ];
          acc.eventsByMonth[keyMonth] = [
            ...acc.eventsByMonth[keyMonth] || [],
            event
          ];
        }
        return acc;
      },
      { eventsByDate: {}, eventsByMonth: {} }
    );
  }, [data, roleConfigs.color, roleConfigs.date, roleConfigs.title]);
  const value = React.useMemo(
    () => utils.isValidIsoDate(isoValue) ? dayjs__default.default(isoValue) : dayjs__default.default(),
    [isoValue]
  );
  const defaultValue = React.useMemo(
    () => utils.isValidIsoDate(isoDefaultValue) ? dayjs__default.default(isoDefaultValue) : dayjs__default.default(),
    [isoDefaultValue]
  );
  const validRange = React.useMemo(() => {
    if (!isoValidRange)
      return void 0;
    const range = isoValidRange.filter((dateIso) => utils.isValidIsoDate(dateIso)).map((d) => dayjs__default.default(d));
    if (range.length !== 2)
      return void 0;
    return [range[0], range[1]];
  }, [isoValidRange]);
  const key = React.useMemo(() => JSON.stringify(roleConfigs), [roleConfigs]);
  return /* @__PURE__ */ React__default.default.createElement(
    antd.Calendar,
    __spreadProps(__spreadValues$1({}, rest), {
      key,
      validRange,
      defaultValue,
      value,
      dateCellRender: dateCellRender ? dateCellRender : (date) => /* @__PURE__ */ React__default.default.createElement(
        EventCell,
        {
          events: eventsByDate[getEventFullDate(date.toISOString())]
        }
      ),
      monthCellRender: monthCellRender ? monthCellRender : (date) => /* @__PURE__ */ React__default.default.createElement(
        EventCell,
        {
          events: eventsByMonth[getEventMonthYear(date.toISOString())]
        }
      ),
      dateFullCellRender,
      monthFullCellRender
    })
  );
}
const defaultColumnConfig = () => ({
  key: utils.mkShortId(),
  isEditableExpr: () => false,
  disableSorting: false,
  sortByExpr: void 0,
  isHidden: false,
  formatting: {
    styles: {},
    align: "left",
    freeze: "off"
  },
  dataType: "auto",
  role: void 0
});
const roles = ["date", "title", "color", "unset"];
function useRoleDefinitions(data, props) {
  const { fields, setControlContextData } = props;
  return React__default.default.useMemo(() => {
    var _a, _b, _c, _d, _e;
    const schema = data == null ? void 0 : data.schema;
    if (!data || !schema) {
      return { normalized: [], finalRoles: {} };
    }
    function tagFieldConfigs(role) {
      var _a2;
      if (role !== "unset") {
        return utils.ensureArray((_a2 = props[role]) != null ? _a2 : []).map((field) => {
          return __spreadProps(__spreadValues$1({}, field), {
            role
          });
        });
      } else {
        return [];
      }
    }
    const specifiedFieldsPartial = [
      ...tagFieldConfigs("date"),
      ...tagFieldConfigs("color"),
      ...tagFieldConfigs("title")
    ];
    function doDeriveFieldConfigs(mode) {
      return dataSources.deriveFieldConfigs(
        mode === "defaults" ? [] : specifiedFieldsPartial,
        schema,
        (field) => __spreadValues$1(__spreadValues$1({}, defaultColumnConfig()), field && {
          key: field.id,
          fieldId: field.id,
          title: field.label || field.id,
          // undefined means not yet determined in this routine, not 'unset'
          role: void 0,
          expr: (currentItem) => currentItem[field.id]
        })
      );
    }
    const {
      mergedFields: defaultMergedFields,
      minimalFullLengthFields: defaultMinimalFullLengthFields
    } = doDeriveFieldConfigs("defaults");
    if (data.data.length > 0 && !defaultMergedFields.some((field) => field.role === "date")) {
      const sampleRows = Array.from(
        new Set(
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(
            (i) => Math.round(i / 9 * (data.data.length - 1))
          )
        )
      ).map((i) => data.data[i]);
      const dateFieldCandidates = defaultMergedFields.filter(
        (field) => !field.role && sampleRows.filter(
          (row) => field.fieldId && utils.isLikeDate(row[field.fieldId])
        ).length >= sampleRows.length / 2
      );
      const dateField = (_b = (_a = dateFieldCandidates.find(
        (f) => {
          var _a2;
          return (_a2 = f.fieldId) == null ? void 0 : _a2.match(/^(date|datetime|timestamp|eventdate)$/i);
        }
      )) != null ? _a : dateFieldCandidates.find(
        (f) => {
          var _a2;
          return (_a2 = f.fieldId) == null ? void 0 : _a2.match(/.*(date|time|event).*/i);
        }
      )) != null ? _b : dateFieldCandidates[0];
      if (dateField) {
        dateField.role = "date";
      }
    }
    if (data.data.length > 0 && !defaultMergedFields.some((field) => field.role === "color")) {
      const sampleRows = Array.from(
        new Set(
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(
            (i) => Math.round(i / 9 * (data.data.length - 1))
          )
        )
      ).map((i) => data.data[i]);
      const colorFieldCandidates = defaultMergedFields.filter(
        (field) => !field.role && sampleRows.filter(
          (row) => field.fieldId && utils.isLikeColor(row[field.fieldId])
        ).length >= sampleRows.length / 2
      );
      const colorField = (_d = (_c = colorFieldCandidates.find(
        (f) => {
          var _a2;
          return (_a2 = f.fieldId) == null ? void 0 : _a2.match(/^(color|hex|rgb|hsl|rgba|cmyk|hsv|hsb)$/i);
        }
      )) != null ? _c : colorFieldCandidates.find(
        (f) => {
          var _a2;
          return (_a2 = f.fieldId) == null ? void 0 : _a2.match(/.*(color|hex|rgb|hsl|rgba|cmyk|hsv|hsb).*/i);
        }
      )) != null ? _d : colorFieldCandidates[0];
      if (colorField) {
        colorField.role = "color";
      }
    }
    if (!defaultMergedFields.some((field) => field.role === "title")) {
      const titleField = defaultMergedFields.find(
        (field) => {
          var _a2;
          return !field.role && ((_a2 = field.fieldId) == null ? void 0 : _a2.toLowerCase().match(/^(title|name||event[ _-]?name)$/));
        }
      );
      if (titleField) {
        titleField.role = "title";
      }
    }
    const fieldIdToDefaultRole = new Map(
      defaultMergedFields.map((f) => [f.fieldId, f.role])
    );
    for (const f of defaultMinimalFullLengthFields) {
      f.role = fieldIdToDefaultRole.get(f.fieldId);
    }
    const { mergedFields, minimalFullLengthFields } = doDeriveFieldConfigs("existing");
    const minimalFullLengthFieldsWithDefaults = [
      ...minimalFullLengthFields.filter((f) => f.role && f.role !== "unset"),
      ...defaultMinimalFullLengthFields.filter(
        (f) => f.role && f.role !== "unset" && !props[f.role]
      )
    ];
    const mergedFieldsWithDefaults = [
      ...mergedFields.filter((f) => f.role && f.role !== "unset"),
      ...defaultMergedFields.filter(
        (f) => f.role && f.role !== "unset" && !props[f.role]
      )
    ];
    const roleConfigs = utils.ensure(
      groupBy__default.default(mergedFieldsWithDefaults, (f) => f.role)
    );
    const finalRoles = {};
    for (const role of roles) {
      if (role !== "unset") {
        finalRoles[role] = (_e = utils.maybe(props[role], utils.ensureArray)) != null ? _e : roleConfigs[role];
      }
    }
    setControlContextData == null ? void 0 : setControlContextData(__spreadProps(__spreadValues$1({}, data), {
      mergedFields: mergedFieldsWithDefaults,
      minimalFullLengthFields: minimalFullLengthFieldsWithDefaults
    }));
    const normalized = mergedFieldsWithDefaults;
    return { normalized, finalRoles };
  }, [data, setControlContextData, props]);
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const calendarHelpers = {
  states: {
    mode: {
      onChangeArgsToValue: (_date, mode) => mode
    },
    selectedDate: {
      onChangeArgsToValue: (date) => dayjs__default.default(date).toISOString()
    }
  }
};
const calendarComponentName = "hostless-rich-calendar";
function registerRichCalendar(loader) {
  utils.registerComponentHelper(loader, RichCalendar, {
    name: calendarComponentName,
    displayName: "Calendar",
    props: {
      data: {
        type: "dataSourceOpData",
        displayName: "Events",
        description: "The events data should be a list of records with some date, title and (optionally) color fields. The component will infer the date field from the provided data, but you can also explicitly specify that below."
      },
      title: commonPropTypes.roleProp({ role: "title" }),
      date: commonPropTypes.roleProp({ role: "date", singular: true }),
      color: commonPropTypes.roleProp({ role: "color", singular: true }),
      value: {
        // Must have a corresponding state and eventhandler for any prop that I want to be able to change in interactive mode.
        editOnly: true,
        uncontrolledProp: "defaultValue",
        type: "dateString",
        description: `The date selected by default as an ISO string`,
        validator: (value, ps) => {
          if (!ps.value)
            return true;
          if (!ps.validRange)
            return true;
          if (!utils.isValidIsoDate(value))
            return "Not a valid ISO string.";
          if (dayjs__default.default(value).isBefore(ps.validRange[0]) || dayjs__default.default(value).isAfter(ps.validRange[1]))
            return "Not within the valid range";
          return true;
        }
      },
      mode: {
        type: "choice",
        options: ["month", "year"],
        description: "The default display mode of the calendar.",
        defaultValueHint: "month"
      },
      validRange: {
        type: "dateRangeStrings",
        description: "Only allow selection of dates that lie within this range",
        advanced: true,
        validator: (value, ps) => {
          if (!value)
            return true;
          if (!Array.isArray(value) || value.length !== 2)
            return "Not an array with 2 items";
          if (!utils.isValidIsoDate(value[0]) || !utils.isValidIsoDate(value[1]))
            return "Min or max range is not in valid ISO date format.";
          return true;
        }
      },
      headerRender: {
        type: "slot",
        renderPropParams: ["headerProps"],
        hidePlaceholder: true,
        displayName: "Custom Header"
      },
      dateCellRender: {
        type: "slot",
        renderPropParams: ["dateProps"],
        hidePlaceholder: true,
        displayName: "Append Date Cell"
      },
      dateFullCellRender: {
        type: "slot",
        renderPropParams: ["dateProps"],
        hidePlaceholder: true,
        displayName: "Custom Date Cell"
      },
      monthCellRender: {
        type: "slot",
        renderPropParams: ["dateProps"],
        hidePlaceholder: true,
        displayName: "Append Month Cell"
      },
      monthFullCellRender: {
        type: "slot",
        renderPropParams: ["dateProps"],
        hidePlaceholder: true,
        displayName: "Custom Month Cell"
      },
      onPanelChange: {
        type: "eventHandler",
        description: "Triggers when the calendar mode changes (e.g. from month to year mode)",
        argTypes: [
          { name: "date", type: "object" },
          { name: "mode", type: "string" }
        ]
      },
      onChange: {
        type: "eventHandler",
        argTypes: [{ name: "date", type: "object" }]
      }
    },
    states: {
      mode: __spreadValues({
        type: "writable",
        valueProp: "mode",
        onChangeProp: "onPanelChange",
        variableType: "text"
      }, calendarHelpers.states.mode),
      selectedDate: __spreadValues({
        type: "writable",
        valueProp: "value",
        onChangeProp: "onChange",
        variableType: "text"
      }, calendarHelpers.states.selectedDate)
    },
    componentHelpers: {
      helpers: calendarHelpers,
      importName: "calendarHelpers",
      importPath: "@plasmicpkgs/plasmic-rich-components/skinny/rich-calendar"
    },
    importPath: "@plasmicpkgs/plasmic-rich-components/skinny/rich-calendar",
    importName: "RichCalendar"
  });
}

exports.RichCalendar = RichCalendar;
exports.calendarComponentName = calendarComponentName;
exports.calendarHelpers = calendarHelpers;
exports.registerRichCalendar = registerRichCalendar;
//# sourceMappingURL=index.cjs.js.map
