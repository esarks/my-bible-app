'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var commonPropTypes = require('../common-prop-types-193ce561.cjs.js');
var utils = require('../utils-65c486f0.cjs.js');
var dataSources = require('@plasmicapp/data-sources');
var antd = require('antd');
var classNames = require('classnames');
var groupBy = require('lodash/groupBy');
var React = require('react');
var fieldReactUtils = require('../field-react-utils-c717ec94.cjs.js');
var formatting = require('../formatting-6dc71cdd.cjs.js');
require('../common-e1d76791.cjs.js');
require('@ctrl/tinycolor');
require('@plasmicapp/host/registerComponent');
require('@plasmicapp/host/registerGlobalContext');
require('@plasmicpkgs/luxon-parser');
require('dayjs');
require('dayjs/plugin/customParseFormat');
require('fast-stringify');
require('lodash/get');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var classNames__default = /*#__PURE__*/_interopDefault(classNames);
var groupBy__default = /*#__PURE__*/_interopDefault(groupBy);
var React__default = /*#__PURE__*/_interopDefault(React);

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const listCss = `
.plasmic-list--grid .ant-list-items {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 16px;
}

.plasmic-list-search {
  /* Matches RichTable search. */
  max-width: 200px;
  margin-bottom: 8px;
}

.plasmic-list-item-content--unbordered {
  padding-left: 8px;
  padding-right: 8px;
}

.ant-list .plasmic-list-item {
  align-items: stretch;
}

.plasmic-list-item--clickable:hover {
  background-color: #8881;
}

.plasmic-list-item-image {
  max-width: 80px;
  max-height: 80px;
  aspect-ratio: 1/1;
  object-fit: cover;
  border-radius: 8px;
}

.plasmic-list-item-card {
  /* Unsure why needed, but cards otherwise can be much narrower. */
  width: 100%;
  /* For the body to fill the height, so all cards are the same height. */
  display: flex;
  flex-direction: column;
}

.plasmic-list-item-card > .ant-card-body {
  flex: 1;
}

.plasmic-list-item-card-cover {
  max-height: 300px;
  aspect-ratio: 1/1;
  object-fit: cover;
}
`;
function RichList(props) {
  const _a = props, {
    data: rawData = {
      data: [],
      schema: {
        id: "inferred",
        fields: [
          {
            id: "id",
            type: "string",
            readOnly: false
          }
        ]
      }
    },
    type = "list",
    bordered = true,
    className,
    size,
    header,
    footer,
    rowActions = [],
    title,
    pageSize = 10,
    hideSearch,
    rowKey,
    pagination = true,
    onRowClick
  } = _a; __objRest(_a, [
    "data",
    "type",
    "bordered",
    "className",
    "size",
    "header",
    "footer",
    "rowActions",
    "title",
    "pageSize",
    "hideSearch",
    "rowKey",
    "pagination",
    "onRowClick"
  ]);
  const normalizedData = dataSources.useNormalizedData(rawData);
  const data = React__default.default.useMemo(() => {
    if (!(normalizedData == null ? void 0 : normalizedData.data)) {
      return normalizedData;
    }
    return __spreadProps(__spreadValues$1({}, normalizedData), { data: fieldReactUtils.tagDataArray(normalizedData.data) });
  }, [normalizedData]);
  const { normalized, finalRoles: roleConfigs } = useRoleDefinitions(
    data,
    props
  );
  React.useRef();
  const linkTo = typeof props.linkTo === "function" ? props.linkTo : void 0;
  const { finalData, search, setSearch, setSortState } = fieldReactUtils.useSortedFilteredData(
    data,
    normalized
  );
  const actuallyBordered = type === "list" ? bordered : false;
  return /* @__PURE__ */ React__default.default.createElement("div", { className }, /* @__PURE__ */ React__default.default.createElement("style", { dangerouslySetInnerHTML: { __html: listCss } }), !hideSearch && /* @__PURE__ */ React__default.default.createElement(
    antd.Input.Search,
    {
      className: "plasmic-list-search",
      onChange: (e) => setSearch(e.target.value),
      value: search,
      placeholder: "Search"
    }
  ), /* @__PURE__ */ React__default.default.createElement(
    antd.List,
    {
      className: classNames__default.default({
        // We use CSS grid instead of the built-in Ant grid which can only define fixed # columns, and only at screen (and not container) breakpoints.
        "plasmic-list--grid": type === "grid"
      }),
      size,
      header,
      footer,
      dataSource: finalData,
      itemLayout: "horizontal",
      bordered: actuallyBordered,
      pagination: pagination ? {
        pageSize,
        showSizeChanger: false
      } : false,
      renderItem: (record, index) => {
        var _a2;
        const actions = fieldReactUtils.renderActions(rowActions, record, data, rowKey);
        const image = utils.maybe(
          formatting.maybeRenderString(record, (_a2 = roleConfigs.image) == null ? void 0 : _a2[0]),
          (src) => /* @__PURE__ */ React__default.default.createElement(
            "img",
            {
              src,
              className: type === "list" ? "plasmic-list-item-image" : "plasmic-list-item-card-cover"
            }
          )
        );
        const content = /* @__PURE__ */ React__default.default.createElement(
          ListItemContent,
          {
            bordered: actuallyBordered,
            image: type === "list" ? image : void 0,
            title: formatting.multiRenderValue(record, roleConfigs.title),
            subtitle: formatting.multiRenderValue(record, roleConfigs.subtitle),
            beforeTitle: formatting.multiRenderValue(record, roleConfigs.beforeTitle),
            afterTitle: formatting.multiRenderValue(record, roleConfigs.afterTitle),
            content: formatting.multiRenderValue(record, roleConfigs.content)
          }
        );
        function makeLinkWrapper() {
          if ((actions != null ? actions : []).length > 0)
            return void 0;
          const href = linkTo == null ? void 0 : linkTo(record);
          if (!href && !onRowClick)
            return void 0;
          const _linkWrapper = (x) => /* @__PURE__ */ React__default.default.createElement(
            "a",
            {
              href,
              onClick: (event) => {
                const key = fieldReactUtils.deriveKeyOfRow(
                  record,
                  fieldReactUtils.deriveRowKey(data, rowKey)
                );
                if (key != null && !utils.isInteractable(event.target)) {
                  onRowClick == null ? void 0 : onRowClick(key, record, event);
                }
              }
            },
            x
          );
          return _linkWrapper;
        }
        const linkWrapper = makeLinkWrapper();
        const hasLink = !!linkWrapper;
        function maybeLink(x) {
          var _a3;
          return (_a3 = linkWrapper == null ? void 0 : linkWrapper(x)) != null ? _a3 : x;
        }
        return type === "grid" ? /* @__PURE__ */ React__default.default.createElement(antd.List.Item, { className: "plasmic-list-item" }, maybeLink(
          /* @__PURE__ */ React__default.default.createElement(
            antd.Card,
            {
              className: "plasmic-list-item-card",
              size: "small",
              cover: image,
              hoverable: hasLink,
              actions
            },
            content
          )
        )) : maybeLink(
          /* @__PURE__ */ React__default.default.createElement(
            antd.List.Item,
            {
              actions,
              className: classNames__default.default({
                "plasmic-list-item": true,
                "plasmic-list-item--clickable": hasLink
              })
            },
            content
          )
        );
      }
    }
  ));
}
function ListItemContent(_a) {
  var _b = _a, {
    className,
    title,
    subtitle,
    image,
    beforeTitle,
    afterTitle,
    content,
    bordered
  } = _b, others = __objRest(_b, [
    "className",
    "title",
    "subtitle",
    "image",
    "beforeTitle",
    "afterTitle",
    "content",
    "bordered"
  ]);
  const prefixCls = "ant-list";
  const classString = classNames__default.default(`${prefixCls}-item-meta`, className);
  return /* @__PURE__ */ React__default.default.createElement(
    "div",
    __spreadProps(__spreadValues$1({}, others), {
      className: classNames__default.default(
        {
          "plasmic-list-item-content--unbordered": !bordered
        },
        classString
      )
    }),
    image && /* @__PURE__ */ React__default.default.createElement("div", { className: `${prefixCls}-item-meta-avatar` }, image),
    /* @__PURE__ */ React__default.default.createElement(
      "div",
      {
        className: `${prefixCls}-item-meta-content`,
        style: { display: "flex", flexDirection: "column", gap: 4 }
      },
      beforeTitle && /* @__PURE__ */ React__default.default.createElement("div", null, /* @__PURE__ */ React__default.default.createElement(antd.Tag, null, beforeTitle)),
      /* @__PURE__ */ React__default.default.createElement("div", { style: { display: "flex", gap: 8 } }, title && /* @__PURE__ */ React__default.default.createElement(
        "h4",
        {
          className: `${prefixCls}-item-meta-title`,
          style: { margin: 0 }
        },
        title
      ), afterTitle && /* @__PURE__ */ React__default.default.createElement("div", { className: `${prefixCls}-item-meta-description` }, afterTitle)),
      subtitle && /* @__PURE__ */ React__default.default.createElement("div", { className: `${prefixCls}-item-meta-description` }, subtitle),
      content && /* @__PURE__ */ React__default.default.createElement("div", null, content)
    )
  );
}
const defaultColumnConfig = () => ({
  key: utils.mkShortId(),
  isEditableExpr: () => false,
  disableSorting: false,
  sortByExpr: void 0,
  isHidden: false,
  formatting: {
    styles: {},
    align: "left",
    freeze: "off"
  },
  dataType: "auto",
  role: void 0
});
const roles = [
  "content",
  "title",
  "subtitle",
  "beforeTitle",
  "afterTitle",
  "image",
  "unset"
];
function useRoleDefinitions(data, props) {
  const { fields, setControlContextData, rowActions } = props;
  return React__default.default.useMemo(() => {
    var _a, _b, _c, _d;
    const schema = data == null ? void 0 : data.schema;
    const schemaMap = new Map((_a = data == null ? void 0 : data.schema) == null ? void 0 : _a.fields.map((f) => [f.id, f]));
    if (!data || !schema) {
      return { normalized: [], finalRoles: {} };
    }
    function tagFieldConfigs(role) {
      var _a2;
      if (role !== "unset") {
        return utils.ensureArray((_a2 = props[role]) != null ? _a2 : []).map((field) => {
          return __spreadProps(__spreadValues$1({}, field), {
            role
          });
        });
      } else {
        return [];
      }
    }
    const specifiedFieldsPartial = [
      ...tagFieldConfigs("image"),
      ...tagFieldConfigs("content"),
      ...tagFieldConfigs("title"),
      ...tagFieldConfigs("beforeTitle"),
      ...tagFieldConfigs("afterTitle"),
      ...tagFieldConfigs("subtitle")
    ];
    function doDeriveFieldConfigs(mode) {
      return dataSources.deriveFieldConfigs(
        mode === "defaults" ? [] : specifiedFieldsPartial,
        schema,
        (field) => __spreadValues$1(__spreadValues$1({}, defaultColumnConfig()), field && {
          key: field.id,
          fieldId: field.id,
          title: field.label || field.id,
          // undefined means not yet determined in this routine, not 'unset'
          role: void 0,
          expr: (currentItem) => currentItem[field.id]
        })
      );
    }
    const {
      mergedFields: defaultMergedFields,
      minimalFullLengthFields: defaultMinimalFullLengthFields
    } = doDeriveFieldConfigs("defaults");
    if (data.data.length > 0 && !defaultMergedFields.some((field) => field.role === "image")) {
      const sampleRows = Array.from(
        new Set(
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(
            (i) => Math.round(i / 9 * (data.data.length - 1))
          )
        )
      ).map((i) => data.data[i]);
      const imageFieldCandidates = defaultMergedFields.filter(
        (field) => !field.role && sampleRows.filter(
          (row) => field.fieldId && utils.isLikeImage(row[field.fieldId])
        ).length >= sampleRows.length / 2
      );
      const imageField = (_c = (_b = imageFieldCandidates.find(
        (f) => {
          var _a2;
          return (_a2 = f.fieldId) == null ? void 0 : _a2.match(
            /^(image|picture|pic|img|avatar|profile|photo|icon)$/i
          );
        }
      )) != null ? _b : imageFieldCandidates.find(
        (f) => {
          var _a2;
          return (_a2 = f.fieldId) == null ? void 0 : _a2.match(
            /.*(image|picture|pic|img|avatar|profile|photo|icon).*/i
          );
        }
      )) != null ? _c : imageFieldCandidates[0];
      if (imageField) {
        imageField.role = "image";
      }
    }
    if (!defaultMergedFields.some((field) => field.role === "title")) {
      const titleField = defaultMergedFields.find(
        (field) => {
          var _a2;
          return !field.role && ((_a2 = field.fieldId) == null ? void 0 : _a2.toLowerCase().match(/^(title|name|first[ _-]?name|full[ _-]?name)$/));
        }
      );
      if (titleField) {
        titleField.role = "title";
      }
    }
    if (!defaultMergedFields.some((field) => field.role === "content")) {
      const contentField = defaultMergedFields.find(
        (field) => {
          var _a2;
          return !field.role && field.fieldId && ((_a2 = schemaMap.get(field.fieldId)) == null ? void 0 : _a2.type) === "string";
        }
      );
      if (contentField) {
        contentField.role = "content";
      }
    }
    const fieldIdToDefaultRole = new Map(
      defaultMergedFields.map((f) => [f.fieldId, f.role])
    );
    for (const f of defaultMinimalFullLengthFields) {
      f.role = fieldIdToDefaultRole.get(f.fieldId);
    }
    const { mergedFields, minimalFullLengthFields } = doDeriveFieldConfigs("existing");
    const minimalFullLengthFieldsWithDefaults = [
      ...minimalFullLengthFields.filter((f) => f.role && f.role !== "unset"),
      ...defaultMinimalFullLengthFields.filter(
        (f) => f.role && f.role !== "unset" && !props[f.role]
      )
    ];
    const mergedFieldsWithDefaults = [
      ...mergedFields.filter((f) => f.role && f.role !== "unset"),
      ...defaultMergedFields.filter(
        (f) => f.role && f.role !== "unset" && !props[f.role]
      )
    ];
    const roleConfigs = utils.ensure(
      groupBy__default.default(mergedFieldsWithDefaults, (f) => f.role)
    );
    const finalRoles = {};
    for (const role of roles) {
      if (role !== "unset") {
        finalRoles[role] = (_d = utils.maybe(props[role], utils.ensureArray)) != null ? _d : roleConfigs[role];
      }
    }
    setControlContextData == null ? void 0 : setControlContextData(__spreadProps(__spreadValues$1({}, data), {
      mergedFields: mergedFieldsWithDefaults,
      minimalFullLengthFields: minimalFullLengthFieldsWithDefaults
    }));
    const normalized = mergedFieldsWithDefaults;
    return { normalized, finalRoles };
  }, [fields, data, setControlContextData, rowActions]);
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const richListMeta = {
  name: "hostless-rich-list",
  displayName: "Data List",
  defaultStyles: {
    width: "stretch",
    padding: "16px",
    maxHeight: "100%"
  },
  defaultDisplay: "block",
  props: __spreadValues({
    data: commonPropTypes.dataProp(),
    type: {
      type: "choice",
      options: [
        { value: "list", label: "List" },
        { value: "grid", label: "Grid" }
      ],
      defaultValueHint: "list"
    },
    header: {
      type: "slot",
      hidePlaceholder: true
    },
    footer: {
      type: "slot",
      hidePlaceholder: true
    },
    title: commonPropTypes.roleProp({ role: "title" }),
    content: commonPropTypes.roleProp({ role: "content" }),
    image: commonPropTypes.roleProp({ role: "image", singular: true }),
    subtitle: commonPropTypes.roleProp({
      role: "subtitle",
      advanced: true
    }),
    // Haven't styled these yet!
    // beforeTitle: roleProp({ role: "beforeTitle", advanced: true }),
    // afterTitle: roleProp({ role: "afterTitle", advanced: true }),
    linkTo: {
      type: "function",
      control: {
        type: "href"
      },
      argNames: ["currentItem"],
      argValues: (_props, ctx) => {
        var _a;
        return [(_a = ctx == null ? void 0 : ctx.data) == null ? void 0 : _a[0]];
      }
    },
    onRowClick: commonPropTypes.onRowClickProp(),
    rowActions: commonPropTypes.rowActionsProp(),
    bordered: {
      type: "boolean",
      defaultValue: true,
      hidden: (ps) => {
        var _a;
        return ((_a = ps.type) != null ? _a : "list") !== "list";
      }
    }
  }, commonPropTypes.commonProps()),
  importName: "RichList",
  importPath: "@plasmicpkgs/plasmic-rich-components/skinny/rich-list"
};
function registerRichList(loader) {
  utils.registerComponentHelper(loader, RichList, richListMeta);
}

exports.RichList = RichList;
exports.default = RichList;
exports.registerRichList = registerRichList;
//# sourceMappingURL=index.cjs.js.map
