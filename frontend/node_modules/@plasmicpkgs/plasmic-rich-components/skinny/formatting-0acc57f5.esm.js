import { parseDate } from '@plasmicpkgs/luxon-parser';
import { Checkbox, Switch } from 'antd';
import React from 'react';
import 'lodash/get';
import { w as withoutFalsey, h as isOneOf, m as maybe } from './utils-c32bd7ed.esm.js';

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const DEFAULT_CURRENCY_SETTINGS = {
  dataType: "currency",
  currency: "USD",
  currencyDisplay: "narrowSymbol"
};
const NUMBER_TYPES = ["number", "percent", "currency"];
const DEFAULT_DATETIME_SETTINGS = {
  dataType: "datetime",
  locale: "en-US",
  dateStyle: "short",
  timeStyle: "short",
  hour12: true
};
const DEFAULT_RELATIVE_DATETIME_SETTINGS = {
  dataType: "relative-datetime",
  locale: "en-US",
  numeric: "always",
  style: "long",
  unit: "day"
};
const DATETIME_TYPES = ["datetime", "relative-datetime"];
const DEFAULT_BOOLEAN_SETTINGS = {
  dataType: "boolean",
  showAs: "checkbox"
};
function deriveValueType(cconfig) {
  return cconfig.dataType === "auto" ? void 0 : cconfig.dataType === "string" ? "text" : cconfig.dataType === "number" ? "digit" : cconfig.dataType === "boolean" ? "switch" : void 0;
}
const NoneField = "||NoneField||";
const CustomField = "";
function getFieldSubprops(opts) {
  return __spreadValues$1(__spreadValues$1({
    key: {
      type: "string",
      hidden: () => true
    },
    fieldId: {
      type: "choice",
      displayName: "Field name",
      readOnly: !opts.canChangeField,
      options: (_props, ctx) => {
        var _a, _b;
        return withoutFalsey([
          opts.canPickNoneField && { value: NoneField, label: "None" },
          ...((_b = (_a = ctx == null ? void 0 : ctx.schema) == null ? void 0 : _a.fields) != null ? _b : []).map((f) => {
            var _a2;
            return {
              value: f.id,
              label: (_a2 = f.label) != null ? _a2 : f.id
            };
          }),
          { value: CustomField, label: "Custom value" }
        ]);
      },
      hidden: (ps, ctx, { path: _controlPath }) => {
        if (opts.canChangeField) {
          return false;
        }
        return true;
      }
    },
    title: {
      type: "string",
      displayName: "Title",
      defaultValueHint: getDefaultValueHint("title"),
      hidden: () => !!opts.noTitle
    },
    expr: __spreadProps$1(__spreadValues$1({}, rowDataType("Custom value")), {
      hidden: (ps, ctx, { item, path: _controlPath }) => {
        return false;
      }
    }),
    isHidden: {
      type: "boolean",
      displayName: "Is hidden",
      defaultValueHint: getDefaultValueHint("isHidden")
    }
  }, !opts.noDataType ? {
    dataType: {
      type: "choice",
      displayName: "Data type",
      options: [
        {
          value: "auto",
          label: "Auto"
        },
        {
          value: "number",
          label: "Number"
        },
        {
          value: "percent",
          label: "Percentage"
        },
        {
          value: "currency",
          label: "Currency"
        },
        {
          value: "string",
          label: "String"
        },
        {
          value: "boolean",
          label: "Boolean"
        },
        {
          value: "datetime",
          label: "Date / Time"
        },
        {
          value: "relative-datetime",
          label: "Date / Time relative to now"
        }
      ],
      defaultValueHint: getDefaultValueHint("dataType")
    },
    currency: {
      displayName: "Currency",
      description: "Must be a valid currency code",
      type: "string",
      defaultValueHint: "USD",
      hidden: (ps, ctx, { item }) => item.dataType !== "currency"
    },
    locale: {
      displayName: "Locale",
      description: "Must be a valid locale code",
      type: "string",
      defaultValueHint: "en-US",
      hidden: (ps, ctx, { item }) => !isOneOf(item.dataType, NUMBER_TYPES) && !isOneOf(item.dataType, DATETIME_TYPES)
    },
    notation: {
      displayName: "Notation",
      type: "choice",
      options: [
        {
          value: "standard",
          label: "Standard"
        },
        {
          value: "scientific",
          label: "Scientific notation (like 1E3)"
        },
        {
          value: "compact",
          label: "Compact (like 10K)"
        }
      ],
      defaultValueHint: "standard",
      hidden: (ps, ctx, { item }) => !isOneOf(item.dataType, NUMBER_TYPES)
    },
    signDisplay: {
      type: "choice",
      displayName: "Number sign",
      options: [
        {
          value: "auto",
          label: "Only for negative numbers (10, -10)"
        },
        {
          value: "exceptZero",
          label: "Positive or negative (+10, -10)"
        }
      ],
      defaultValueHint: "auto",
      hidden: (ps, ctx, { item }) => !isOneOf(item.dataType, NUMBER_TYPES)
    },
    maximumFractionDigits: {
      type: "number",
      displayName: "Max decimal places",
      defaultValueHint: 3,
      min: 0,
      max: 20,
      hidden: (ps, ctx, { item }) => !isOneOf(item.dataType, NUMBER_TYPES)
    },
    minimumFractionDigits: {
      type: "number",
      displayName: "Min decimal places",
      defaultValueHint: 0,
      min: 0,
      max: 20,
      hidden: (ps, ctx, { item }) => !isOneOf(item.dataType, NUMBER_TYPES)
    },
    showAs: {
      type: "choice",
      options: [
        {
          value: "checkbox",
          label: "Checkboxes"
        },
        {
          value: "switch",
          label: "Toggle switches"
        },
        {
          value: "text",
          label: "Text"
        }
      ],
      displayName: "Show as",
      defaultValueHint: "checkbox",
      hidden: (ps, ctx, { item }) => item.dataType !== "boolean"
    },
    dateStyle: {
      displayName: "Date style",
      type: "choice",
      options: [
        {
          value: "none",
          label: "None (don't display date)"
        },
        {
          value: "short",
          label: "Short (like 12/25/2023)"
        },
        {
          value: "medium",
          label: "Medium (like Dec 25, 2023)"
        },
        {
          value: "long",
          label: "Long (like December 25, 2023)"
        },
        {
          value: "full",
          label: "Full (like Monday, December 25, 2023)"
        }
      ],
      defaultValueHint: DEFAULT_DATETIME_SETTINGS.dateStyle,
      hidden: (ps, ctx, { item }) => item.dataType !== "datetime"
    },
    timeStyle: {
      displayName: "Time style",
      type: "choice",
      options: [
        {
          value: "none",
          label: "None (don't display time)"
        },
        {
          value: "short",
          label: "Short (like 4:00 PM)"
        },
        {
          value: "medium",
          label: "Medium (like 4:00:00 PM)"
        },
        {
          value: "long",
          label: "Long (like 4:00:00 PM PST)"
        },
        {
          value: "full",
          label: "Full (like 4:00:00 PM Pacific Standard Time)"
        }
      ],
      defaultValueHint: DEFAULT_DATETIME_SETTINGS.timeStyle,
      hidden: (ps, ctx, { item }) => item.dataType !== "datetime"
    },
    hour12: {
      displayName: "Use AM/PM?",
      description: "Whether to use AM/PM or 24-hour clock",
      type: "boolean",
      defaultValueHint: DEFAULT_DATETIME_SETTINGS.hour12,
      hidden: (ps, ctx, { item }) => item.dataType !== "datetime"
    },
    numeric: {
      type: "choice",
      displayName: "Use numbers?",
      options: [
        { value: "always", label: "Always use numbers" },
        {
          value: "auto",
          label: "Use words like 'Yesterday' or 'Tomorrow'"
        }
      ],
      defaultValueHint: DEFAULT_RELATIVE_DATETIME_SETTINGS.numeric,
      hidden: (ps, ctx, { item }) => item.dataType !== "relative-datetime"
    },
    unit: {
      type: "choice",
      displayName: "Time unit",
      options: [
        {
          value: "second",
          label: "Seconds"
        },
        {
          value: "minute",
          label: "Minutes"
        },
        {
          value: "hour",
          label: "Hours"
        },
        {
          value: "day",
          label: "Days"
        },
        {
          value: "week",
          label: "Weeks"
        },
        {
          value: "month",
          label: "Months"
        },
        {
          value: "year",
          label: "Years"
        }
      ],
      defaultValueHint: DEFAULT_RELATIVE_DATETIME_SETTINGS.unit,
      hidden: (ps, ctx, { item }) => item.dataType !== "relative-datetime"
    }
  } : {}), opts.fieldTypes);
}
function getDefaultValueHint(field) {
  return (_props, contextData, { item }) => {
    if (item == null ? void 0 : item.fieldId) {
      const fieldSetting = contextData == null ? void 0 : contextData.mergedFields.find(
        (f) => f.fieldId === item.fieldId
      );
      return fieldSetting == null ? void 0 : fieldSetting[field];
    }
    return void 0;
  };
}
const rowDataType = (displayName, control) => ({
  type: "function",
  displayName,
  control,
  argNames: ["currentItem", "currentValue"],
  argValues: (_props, ctx, { item }) => {
    var _a;
    const row = (_a = ctx == null ? void 0 : ctx.data) == null ? void 0 : _a[0];
    const cell = item.fieldId ? row == null ? void 0 : row[item.fieldId] : void 0;
    return [row, cell];
  }
});
function buildFieldsPropType(_a) {
  var _b = _a, {
    advanced,
    displayName,
    minimalValue = (_props, contextData) => contextData == null ? void 0 : contextData.minimalFullLengthFields
  } = _b, opts = __objRest(_b, [
    "advanced",
    "displayName",
    "minimalValue"
  ]);
  return {
    type: "array",
    advanced,
    displayName,
    hidden: (ps) => !ps.data,
    unstable__keyFunc: (x) => x.key,
    unstable__minimalValue: minimalValue,
    unstable__canDelete: (ps, _props, ctx, { item }) => {
      if (opts.canChangeField) {
        return true;
      }
      if (!(ctx == null ? void 0 : ctx.schema)) {
        return false;
      }
      if (item.fieldId && ctx.schema.fields.some((f) => f.id === item.fieldId)) {
        return false;
      }
      return true;
    },
    itemType: {
      type: "object",
      nameFunc: (_item) => {
        return _item.fieldId || _item.title || "Custom value";
      },
      fields: getFieldSubprops(opts)
    }
  };
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function multiRenderValue(record, cconfigs) {
  return cconfigs == null ? void 0 : cconfigs.flatMap(
    (cc) => cc.isHidden ? [] : [` \u2022 `, /* @__PURE__ */ React.createElement(React.Fragment, null, renderValue(record, cc))]
  ).slice(1);
}
function maybeRenderString(record, cconfig) {
  return cconfig && !cconfig.isHidden ? maybe(getFieldValue(record, cconfig), asString) : void 0;
}
function getFieldValue(record, cconfig) {
  let value = cconfig.fieldId ? record[cconfig.fieldId] : void 0;
  if (cconfig.expr) {
    value = cconfig.expr(record, value);
  }
  return value;
}
function getFieldAggregateValue(record, cconfigs, separator = ", ") {
  if (!(cconfigs == null ? void 0 : cconfigs.length))
    return void 0;
  return (cconfigs == null ? void 0 : cconfigs.length) ? cconfigs.map((item) => getFieldValue(record, item)).join(separator) : void 0;
}
function renderValue(record, cconfig) {
  const value = getFieldValue(record, cconfig);
  if (value == null) {
    return "";
  }
  if (cconfig.dataType === "auto") {
    return renderAuto(value);
  } else {
    const coerced = coerceValue(value, cconfig.dataType);
    if (isOneOf(cconfig.dataType, NUMBER_TYPES) && typeof coerced === "number") {
      return renderNumber(coerced, cconfig);
    } else if (cconfig.dataType === "boolean" && typeof coerced === "boolean") {
      return renderBoolean(coerced, cconfig);
    } else if (cconfig.dataType === "datetime" && coerced instanceof Date) {
      return renderDate(coerced, cconfig);
    } else if (cconfig.dataType === "relative-datetime" && coerced instanceof Date) {
      return renderRelativeDate(coerced, cconfig);
    }
    return asString(value);
  }
}
function renderAuto(value) {
  if (typeof value === "number") {
    return renderNumber(value, { dataType: "number" });
  } else if (typeof value === "boolean") {
    return renderBoolean(value, DEFAULT_BOOLEAN_SETTINGS);
  } else if (value instanceof Date) {
    return renderDate(value, DEFAULT_DATETIME_SETTINGS);
  } else {
    const coerced = tryCoerceAuto(value);
    if (coerced === CANNOT_COERCE) {
      return asString(value);
    } else {
      return renderAuto(coerced);
    }
  }
}
function tryCoerceAuto(value) {
  for (const dataType of [
    "number",
    "datetime"
  ]) {
    const coerced = coerceValue(value, dataType);
    if (coerced !== CANNOT_COERCE) {
      return coerced;
    }
  }
  return CANNOT_COERCE;
}
function renderNumber(value, cconfig) {
  if (cconfig.dataType === "number") {
    return new Intl.NumberFormat(cconfig.locale, cconfig).format(value);
  } else if (cconfig.dataType === "percent") {
    return new Intl.NumberFormat(cconfig.locale, __spreadProps(__spreadValues({}, cconfig), {
      style: "percent"
    })).format(value);
  } else if (cconfig.dataType === "currency") {
    return new Intl.NumberFormat(cconfig.locale, __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_CURRENCY_SETTINGS), cconfig), {
      style: "currency"
    })).format(value);
  } else {
    throw new Error(`Unexpected dataType ${cconfig.dataType}`);
  }
}
function renderDate(value, cconfig) {
  const opts = __spreadValues(__spreadValues({}, DEFAULT_DATETIME_SETTINGS), cconfig);
  if (opts.dateStyle === "none") {
    delete opts["dateStyle"];
  }
  if (opts.timeStyle === "none") {
    delete opts["timeStyle"];
  }
  return new Intl.DateTimeFormat(cconfig.locale, opts).format(value);
}
const SECOND_MS = 1e3;
const MINUTE_MS = 60 * SECOND_MS;
const HOUR_MS = 60 * MINUTE_MS;
const DAY_MS = 24 * HOUR_MS;
const WEEK_MS = 7 * DAY_MS;
const UNIT_TO_MS = {
  second: SECOND_MS,
  minute: MINUTE_MS,
  hour: HOUR_MS,
  day: DAY_MS,
  week: WEEK_MS
};
const UNITS_BY_MS = Object.keys(UNIT_TO_MS);
function renderRelativeDate(value, cconfig) {
  var _a;
  const opts = __spreadValues(__spreadValues({}, DEFAULT_RELATIVE_DATETIME_SETTINGS), cconfig);
  const unit = (_a = cconfig.unit) != null ? _a : "day";
  const formatter = new Intl.RelativeTimeFormat(cconfig.locale, opts);
  if (isOneOf(unit, UNITS_BY_MS)) {
    const diff = value.getTime() - (/* @__PURE__ */ new Date()).getTime();
    return formatter.format(Math.round(diff / UNIT_TO_MS[unit]), unit);
  } else {
    if (unit === "year") {
      const diff = value.getFullYear() - (/* @__PURE__ */ new Date()).getFullYear();
      return formatter.format(diff, unit);
    } else if (unit === "month") {
      const months = (d) => d.getFullYear() * 12 + d.getMonth() + 1;
      const diff = months(value) - months(/* @__PURE__ */ new Date());
      return formatter.format(diff, unit);
    } else {
      throw new Error(`Unexpected relative time unit ${unit}`);
    }
  }
}
function renderBoolean(value, cconfig) {
  var _a;
  const showAs = (_a = cconfig.showAs) != null ? _a : DEFAULT_BOOLEAN_SETTINGS.showAs;
  if (showAs === "checkbox") {
    return /* @__PURE__ */ React.createElement(Checkbox, { checked: value });
  } else if (showAs === "switch") {
    return /* @__PURE__ */ React.createElement(Switch, { checked: value });
  } else {
    return value ? "true" : "false";
  }
}
const CANNOT_COERCE = Symbol("plasmic-cannot-coerce");
function coerceValue(value, dataType) {
  if (value == null) {
    return null;
  }
  try {
    if (isOneOf(dataType, NUMBER_TYPES)) {
      if (typeof value === "number") {
        return value;
      } else if (typeof value === "string") {
        const maybeNumber = +value;
        if (!isNaN(maybeNumber)) {
          return maybeNumber;
        }
      }
    } else if (isOneOf(dataType, DATETIME_TYPES)) {
      if (value instanceof Date) {
        return value;
      } else if (typeof value === "number") {
        return new Date(value);
      } else if (typeof value === "string") {
        const parsed = parseDate(value);
        return parsed ? parsed : CANNOT_COERCE;
      }
    } else if (dataType === "boolean") {
      if (value === true || value === false) {
        return value;
      } else if (typeof value === "number") {
        return value !== 0;
      } else if (typeof value === "string") {
        return value.toLowerCase() === "true";
      }
    } else if (dataType === "string") {
      return asString(value);
    } else if (dataType === "auto") {
      return value;
    }
  } catch (err) {
  }
  return CANNOT_COERCE;
}
function asString(value) {
  if (value == null) {
    return "";
  } else if (typeof value === "string") {
    return value;
  } else if (typeof value === "object") {
    if ("toString" in value && typeof value.toString === "function") {
      return value.toString();
    } else {
      return JSON.stringify(value);
    }
  } else {
    return `${value}`;
  }
}

export { multiRenderValue as a, buildFieldsPropType as b, getFieldSubprops as c, deriveValueType as d, getFieldAggregateValue as g, maybeRenderString as m, renderValue as r };
//# sourceMappingURL=formatting-0acc57f5.esm.js.map
