import { ComponentMeta, default as registerComponent } from "@plasmicapp/host/registerComponent";
import { default as registerGlobalContext, GlobalContextMeta } from "@plasmicapp/host/registerGlobalContext";
import { default as registerToken } from "@plasmicapp/host/registerToken";
import React from "react";
export type Registerable = {
    registerComponent: typeof registerComponent;
    registerGlobalContext: typeof registerGlobalContext;
    registerToken: typeof registerToken;
};
export declare function makeRegisterComponent<T extends React.ComponentType<any>>(component: T, meta: ComponentMeta<React.ComponentProps<T>>): (loader?: Registerable) => void;
export declare function makeRegisterGlobalContext<T extends React.ComponentType<any>>(component: T, meta: GlobalContextMeta<React.ComponentProps<T>>): (loader?: Registerable) => void;
export declare function registerComponentHelper<T extends React.ComponentType<any>>(loader: Registerable | undefined, component: T, meta: ComponentMeta<React.ComponentProps<T>>): void;
type ReactElt = {
    children: ReactElt | ReactElt[];
    props: {
        children: ReactElt | ReactElt[];
        [prop: string]: any;
    } | null;
    type: React.ComponentType<any> | null;
    key: string | null;
} | null;
export declare function traverseReactEltTree(children: React.ReactNode, callback: (elt: ReactElt) => void): void;
export declare function asArray<T>(x: T[] | T | undefined | null): T[];
export declare function ensureNumber(x: number | string): number;
export declare function ensure<T>(x: T | null | undefined): T;
export declare function isOneOf<T, U extends T>(elem: T, arr: readonly U[]): elem is U;
export declare function maybe<T, U>(x: T | undefined | null, f: (y: T) => U): U | undefined;
/**
 *
 * @param str iso string
 * @param extendedOnly boolean for extended mode (i.e. time)
 * @returns Returns true for strings in ISO 8601 format
 */
export declare function isValidIsoDate(str: string | undefined, extendedOnly?: boolean): boolean;
export declare function isLikeDate(value: unknown): boolean;
export declare function isLikeImage(value: unknown): false | RegExpMatchArray | null;
export declare function isLikeColor(value: unknown): boolean;
export declare function isInteractable(target: HTMLElement): boolean;
export declare function ensureArray<T>(xs: T | T[]): T[];
export declare const tuple: <T extends any[]>(...args: T) => T;
export interface HasId {
    id: string;
}
export declare function mkIdMap<T extends HasId>(xs: ReadonlyArray<T>): Map<string, T>;
export declare const mkShortId: () => string;
export declare function withoutNils<T>(xs: Array<T | undefined | null>): T[];
export type Falsey = null | undefined | false | "" | 0 | 0n;
export type Truthy<T> = T extends Falsey ? never : T;
export declare function withoutFalsey<T>(xs: Array<T | Falsey>): T[];
import type { ErrorInfo } from "react";
interface ErrorBoundaryProps {
    children?: React.ReactNode;
    canvasEnvId?: number;
}
interface ErrorBoundaryState {
    hasError: boolean;
    errorInfo: string;
}
export declare class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
    state: {
        hasError: boolean;
        errorInfo: string;
    };
    static getDerivedStateFromError(error: Error): {
        hasError: boolean;
        errorInfo: string;
    };
    componentDidCatch(error: any, errorInfo: ErrorInfo): void;
    componentDidUpdate(prevProps: Readonly<ErrorBoundaryProps>, prevState: Readonly<ErrorBoundaryState>): void;
    render(): string | number | boolean | Iterable<React.ReactNode> | React.JSX.Element | null | undefined;
}
export {};
